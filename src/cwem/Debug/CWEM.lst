Microsoft (R) Macro Assembler Version 6.15.8803		    03/27/25 15:40:27
CWEM.asm						     Page 1 - 1


				
				;--- CW converts LE to P3
				;--- if image is P3 already, it displays current format with /i
				;--- or sets various parameters for CW dos extender.
				
				;--- this version has been adjusted and needs to find cwstub.exe!
				
					.386
					.model flat
					.dosseg		;WL32 needs .dosseg to ensure that stack is last
					.stack 4096
				
					include general.inc
			      C 
 = byte ptr		      C b	equ	byte ptr
 = word ptr		      C w	equ	word ptr
 = dword ptr		      C d	equ	dword ptr
			      C ;f	equ	fword ptr
			      C 
			      C Pushm	MACRO	R1,R2,R3,R4,R5,R6,R7,R8,R9,R10
			      C 	IRP	X,<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10>
			      C 	IFNB	<X>			;IF THIS PARM NOT BLANK
			      C 	PUSH	X			;SAVE THE REGISTER
			      C 	ENDIF				;END IFNB
			      C 	ENDM				;END IRP
			      C ENDM
			      C 
			      C Popm	macro	R1,R2,R3,R4,R5,R6,R7,R8,R9,R10
			      C 	IRP	X,<R10,R9,R8,R7,R6,R5,R4,R3,R2,R1> ;REPEAT FOR EACH PARM
			      C 	IFNB	<X>				;IF THIS PARM NOT BLANK
			      C 	POP	X				;POP THE REGISTER
			      C 	ENDIF					;END IFNB
			      C 	ENDM					;END IRP
			      C ENDM
			      C 
			      C 
					include ..\strucs.inc
			      C ;------------------------------------------------------------------------------
			      C ;
			      C 
 0000000C		      C ResHead struc
 00000000  00000000	      C ResHead_Prev    dd 0
 00000004  00000000	      C ResHead_Next    dd 0
 00000008  00000000	      C ResHead_Handle  dd 0
			      C ResHead ends
			      C 
 = 00001000		      C ResSize     equ 4096    ;Size of resource block.
			      C ;ResHead    equ 16      ;Size of main header.
 = 00000010		      C ResHeadSize equ 16      ;Size of main header.
 = 00000330		      C ResNum      equ ((((4096-ResHeadSize)/5) shr 2) shl 2)  ;Number of entries.
 = 0000032C		      C ResCount    equ ResNum-4        ;count for free entry checking.
			      C 
			      C ;--- resource types
 = 00000000		      C Res_NULL        equ 0   ;MUST be zero.
 = 00000001		      C Res_PSP         equ 1   ;single entry.
 = 00000002		      C Res_SEL         equ 2   ;single entry.
 = 00000003		      C Res_MEM         equ 3   ;3 entries.
 = 00000004		      C Res_LOCK        equ 4   ;2 entries.
 = 00000005		      C Res_DOSMEM      equ 5   ;?
 = 00000006		      C Res_CALLBACK    equ 6   ;3 entries.
 = 000000FE		      C Res_NOTHING     equ 254
 = 000000FF		      C Res_CHAIN       equ 255 ;single entry.
			      C 
			      C ;--- fields for page details ( 4 MB region )
			      C ;--- an "allocated" memory region start with a MEM_START, the rest is MEM_END
 = 00000000		      C MEM_FREE    equ 0   ;Free page.
 = 00000001		      C MEM_START   equ 1   ;Used page, start of block.
 = 00000002		      C MEM_END     equ 2   ;Used page, end of block.
 = 00000003		      C MEM_MASK    equ 11b ;just bits 0 & 1
			      C ;
			      C ;--- bits 2-5 are lock count
 = 00000004		      C MEM_LOCK	equ	4	;Start of lock count.
 = 0000000F		      C MEM_LOCK_MASK	equ	15	;4 bit lock count.
 = 00000002		      C MEM_LOCK_SHIFT	equ	2
			      C ;
 = 00000020		      C MEM_PHYS	equ	32	;physical mapping - not used (and should be 64, since bit 5 is used by lock cnt)
			      C ;
 = 0000003D		      C MEM_FILL	equ	(MEM_LOCK_MASK shl MEM_LOCK_SHIFT)+MEM_START
			      C 
			      C ;
 = 0000B003		      C KernalB000		equ	0b000h+3
 = 0000B803		      C KernalB800		equ	0b800h+3
 = 0000A003		      C KernalA000		equ	0a000h+3
			      C 
			      C ;
 00000008		      C Desc		struc
 00000000  0000		      C Limit		dw 0		;+0 Offset of last byte.
 00000002  0000		      C Base_l		dw 0		;+2 Low 16 bits of 32-bit address.
 00000004  00		      C Base_m		db 0		;+4 Bits 16-23 of base.
 00000005  00		      C Access		db 0		;+5 Access priviledge level.
 00000006  00		      C Gran		db 0		;+6 Granularity and limit.
 00000007  00		      C Base_H		db 0		;+7 bits 24-31 of base.
			      C Desc		ends
			      C 
 = 00000080		      C DescPresent		equ	1 shl 7	;Segment is present.
 = 00000040		      C Desc32Bit		equ	1 shl 6	;Segment is 32 bit (not 16!).
 = 00000010		      C DescAvailable	equ	1 shl 4	;Available for our use.
			      C ;
 = 00000000		      C DescPL0		equ	0 shl 5	;PL0
 = 00000020		      C DescPL1		equ	1 shl 5	;PL1
 = 00000040		      C DescPL2		equ	2 shl 5	;PL2
 = 00000060		      C DescPL3		equ	3 shl 5	;PL3
			      C ;
 = 00000010		      C DescMemory		equ	1 shl 4	;Segment is memory (not system gate etc.)
			      C ;
 = 00000000		      C DescRData		equ	0	;Read only data segment. (eg, ROM)
 = 00000002		      C DescRWData		equ	2	;Read/Write data.
 = 00000004		      C DescRDataDown	equ	4	;Read only expand down data segment.
 = 00000006		      C DescRWDataDown	equ	6	;Read/write expand down data segment.
 = 00000008		      C DescECode		equ	8	;Execute only code.
 = 0000000A		      C DescERCode		equ	10	;Execute/read code.
 = 0000000C		      C DescECCode		equ	12	;Execute only conforming code.
 = 0000000E		      C DescERCCode		equ	14	;Execute/read conforming code.
			      C ;
 = 00000001		      C Desc286Tss		equ	1	;Available 286 TSS.
 = 00000002		      C DescLDT		equ	2	;LDT.
 = 00000003		      C Desc286TssB		equ	3	;Busy 286 TSS.
 = 00000004		      C Desc286Call		equ	4	;286 call gate.
 = 00000005		      C DescTssGate		equ	5	;TSS gate.
 = 00000006		      C Desc286Int		equ	6	;286 interupt gate.
 = 00000007		      C Desc286Trap		equ	7	;286 trap gate.
 = 00000009		      C Desc386Tss		equ	9	;Available 386 TSS.
 = 0000000B		      C Desc386TssB		equ	11	;Busy 386 TSS.
 = 0000000C		      C Desc386Call		equ	12	;386 call gate.
 = 0000000E		      C Desc386Int		equ	14	;386 interupt gate.
 = 0000000F		      C Desc386Trap		equ	15	;386 trap gate.
			      C 
 00000008		      C GATE struc
 00000000  0000		      C OfsLow	dw ?
 00000002  0000		      C sel		dw ?
 00000004  0000		      C attr	dw ?
 00000006  0000		      C OfsHigh	dw ?
			      C GATE ends
			      C 
			      C ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00000068		      C TSSFields	struc
			      C ;
			      C ;Task segment structure.
			      C ;
 00000000  0000 0000	      C Back	dw ?,?  	;Back link to any previous TSS.
 00000004  00000000	      C ESP0	dd ?		;SP for level 0 interupt.
 00000008  0000 0000	      C SS0		dw ?,?
 0000000C  00000000	      C ESP1	dd ?		;Level 1 interupt handlers stack.
 00000010  0000 0000	      C SS1		dw ?,?
 00000014  00000000	      C ESP2	dd ?		;Level 2 interupt handlers stack.
 00000018  0000 0000	      C SS2		dw ?,?
 0000001C  00000000	      C tCR3	dd ?		;CR3 value.
 00000020  00000000	      C tEIP	dd ?		;Instruction pointer.
 00000024  00000000	      C tEFlags	dd ?		;EFlags.
 00000028  00000000	      C tEAX	dd ?		;AX for init.
 0000002C  00000000	      C tECX	dd ?		;CX for init.
 00000030  00000000	      C tEDX	dd ?		;DX for init.
 00000034  00000000	      C tEBX	dd ?
 00000038  00000000	      C tESP	dd ?
 0000003C  00000000	      C tEBP	dd ?
 00000040  00000000	      C tESI	dd ?
 00000044  00000000	      C tEDI	dd ?
 00000048  00000000	      C tES		dd ?
 0000004C  00000000	      C tCS		dd ?
 00000050  00000000	      C tSS		dd ?
 00000054  00000000	      C tDS		dd ?
 00000058  00000000	      C tFS		dd ?
 0000005C  00000000	      C tGS		dd ?
 00000060  0000		      C tLDT	dw ?
 00000062  0000		      C 		dw ?		;reserved.
 00000064  0000		      C 		dw ?		;reserved.
 00000066  0000		      C IOMap	dw ?		;displacement to I/O map.
			      C ;
			      C ifdef tPL2StackSize
			      C endif
			      C ifdef tPL1StackSize
			      C endif
			      C ifdef tPL0StackSize
			      C endif
			      C ;tPL0Stack	dw ?
			      C TSSFields	ends
			      C 
 00000040		      C NewHeaderStruc	struc
 00000000  00000001 [	      C NewID		db '3P'	;+0 identifier.
	    33 50
	   ]
 00000002  00000000	      C NewSize		dd ?		;+2 byte size of 3P section of file.
 00000006  00000000	      C NewLength		dd ?		;+6  byte size of exe image data.
 0000000A  00000000	      C NewAlloc		dd ?		;+10 byte size of program.
 0000000E  0000		      C NewSegments		dw ?		;+14 number of segment definitions.
 00000010  00000000	      C NewRelocs		dd ?		;+16 number of relocation table entries.
 00000014  00000000	      C NewEntryEIP		dd ?		;+20 entry offset.
 00000018  0000		      C NewEntryCS		dw ?		;+24 segment list entry number for entry CS.
 0000001A  00000000	      C NewEntryESP		dd ?		;+26 ESP offset.
 0000001E  0000		      C NewEntrySS		dw ?		;+30 segment list entry number for SS.
 00000020  00000000	      C NewFlags		dd ?		;+32 Control flags.
 00000024  00000000	      C NewAutoStack		dd ?		;+36 Auto stack size.
 00000028  0000		      C NewAutoDS		dw ?		;+40 Auto DS segment number +1
 0000002A  00000000	      C NewExports		dd ?		;+42 Length of EXPORT section.
 0000002E  00000000	      C NewImports		dd ?		;+46 Length of IMPORT section.
 00000032  00000000	      C NewImportModCnt	dd ?		;+50 Number of IMPORT modules.
			      C ;NewReserved		db 64-NewReserved dup (?)
 00000036  0000000A [	      C NewReserved		db 64-$ dup (?)
	    00
	   ]
			      C NewHeaderStruc	ends
			      C ;
			      C ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
			      C ifndef CW3
 = 00000001		      C LE_OBJ_Flags_Read       equ 1   ;Readable.
 = 00000002		      C LE_OBJ_Flags_Write      equ 2   ;Writeable.
 = 00000004		      C LE_OBJ_Flags_Exec       equ 4   ;Executable.
 = 00000008		      C LE_OBJ_Flags_Res        equ 8   ;Resource.
 = 00000010		      C LE_OBJ_Flags_Discard    equ 16  ;Discardable.
 = 00000020		      C LE_OBJ_Flags_Shared     equ 32  ;Shared.
 = 00000040		      C LE_OBJ_Flags_PreLoad    equ 64  ;Preload.
 = 00000080		      C LE_OBJ_Flags_Invalid    equ 128 ;Invalid.
 = 00000300		      C LE_OBJ_Flags_FillMsk    equ 256+512     ;Mask for fill type bits.
 = 00000000		      C LE_OBJ_Flags_Normal     equ 0   ;Normal fill type.
 = 00000100		      C LE_OBJ_Flags_Zero       equ 256 ;Zero filled.
 = 00000200		      C LE_OBJ_Flags_Res1       equ 512 ;resident.
 = 00000300		      C LE_OBJ_Flags_Res2       equ 256+512     ;resident/contiguous.
 = 00000400		      C LE_OBJ_Flags_LongLoc    equ 1024        ;long lockable.
 = 00001000		      C LE_OBJ_Flags_16Alias    equ 4096        ;16:16_ALIAS
 = 00002000		      C LE_OBJ_Flags_Big        equ 8192        ;"BIG" (Huge: 32-bit)
 = 00004000		      C LE_OBJ_Flags_Conform    equ 16384       ;Conforming.
 = 00008000		      C LE_OBJ_Flags_IOPriv     equ 32768       ;"OBJECT_I/O_PRIVILEGE_LEVEL
			      C endif
			      C 
			      C ;
			      C ;LE header format.
			      C ;
 000000C4		      C LE_Header               struc
 00000000  0000		      C LE_ID           dw ?    ;"LE" text identifier.
 00000002  00		      C LE_ByteOrder            db ?    ;byte order, 0=little-endian, none-zero=big.
 00000003  00		      C LE_WordOrder            db ?    ;word order.
 00000004  00000000	      C LE_Format               dd ?    ;format level.
			      C ;
 00000008  0000		      C LE_CPU          dw ?    ;CPU type.
 = 00000001		      C LE_CPU_286              equ 1
 = 00000002		      C LE_CPU_386              equ 2
 = 00000003		      C LE_CPU_486              equ 3
 = 00000004		      C LE_CPU_586              equ 4
 = 00000020		      C LE_CPU_i860             equ 20h
 = 00000021		      C LE_CPU_N11              equ 21h
 = 00000040		      C LE_CPU_R2000            equ 40h
 = 00000041		      C LE_CPU_R6000            equ 41h
 = 00000042		      C LE_CPU_R4000            equ 42h
			      C ;
 0000000A  0000		      C LE_OS           dw ?    ;Target operating system.
 = 00000001		      C LE_OS_OS2               equ 1
 = 00000002		      C LE_OS_Windows           equ 2
 = 00000003		      C LE_OS_DOS4              equ 3
 = 00000004		      C LE_OS_Win386            equ 4
			      C ;
 0000000C  00000000	      C LE_Version              dd ?    ;Module version.
			      C ;
 00000010  00000000	      C LE_Type         dd ?    ;Module type.
 = 00000004		      C LE_Type_InitPer equ 1 shl 2     ;initialise per process.
 = 00000010		      C LE_Type_IntFixup        equ 1 shl 4     ;no internal fixups.
 = 00000020		      C LE_Type_ExtFixup        equ 1 shl 5     ;no external fixups.
 = 00002000		      C LE_Type_NoLoad          equ 1 shl 13    ;module not loadable.
 = 00008000		      C LE_Type_DLL             equ 1 shl 15    ;DLL
			      C ;
 00000014  00000000	      C LE_Pages                dd ?    ;number of memory pages.
 00000018  00000000	      C LE_EntryCS              dd ?    ;Entry CS object.
 0000001C  00000000	      C LE_EntryEIP             dd ?    ;Entry EIP.
 00000020  00000000	      C LE_EntrySS              dd ?    ;Entry SS object.
 00000024  00000000	      C LE_EntryESP             dd ?    ;Entry ESP.
 00000028  00000000	      C LE_PageSize             dd ?    ;Page size.
 0000002C  00000000	      C LE_LastBytes            dd ?    ;Bytes on last page.
 00000030  00000000	      C LE_FixupSize            dd ?    ;fixup section size.
 00000034  00000000	      C LE_FixupChk             dd ?    ;fixup section check sum.
 00000038  00000000	      C LE_LoaderSize           dd ?    ;loader section size.
 0000003C  00000000	      C LE_LoaderChk            dd ?    ;loader section check sum.
 00000040  00000000	      C LE_ObjOffset            dd ?    ;offset of object table.
 00000044  00000000	      C LE_ObjNum               dd ?    ;object table entries
 00000048  00000000	      C LE_PageMap              dd ?    ;object page map table offset.
 0000004C  00000000	      C LE_IterateMap           dd ?    ;object iterate data map offset.
 00000050  00000000	      C LE_Resource             dd ?    ;resource table offset
 00000054  00000000	      C LE_ResourceNum          dd ?    ;resource table entries.
 00000058  00000000	      C LE_ResidentNames        dd ?    ;resident names table offset.
 0000005C  00000000	      C LE_EntryTable           dd ?    ;entry table offset.
 00000060  00000000	      C LE_Directives           dd ?    ;module directives table offset.
 00000064  00000000	      C LE_DirectivesNum        dd ?    ;module directives entries.
 00000068  00000000	      C LE_Fixups               dd ?    ;fixup page table offset.
 0000006C  00000000	      C LE_FixupsRec            dd ?    ;fixup record table offset.
 00000070  00000000	      C LE_ImportModNames       dd ?    ;imported module name table offset.
 00000074  00000000	      C LE_ImportModNum dd ?    ;imported modules count.
 00000078  00000000	      C LE_ImportNames          dd ?    ;imported procedures name table offset.
 0000007C  00000000	      C LE_PageChk              dd ?    ;per-page checksum table offset.
 00000080  00000000	      C LE_Data         dd ?    ;data pages offset.
 00000084  00000000	      C LE_PreLoadNum           dd ?    ;pre-load page count.
 00000088  00000000	      C LE_NoneRes              dd ?    ;non-resident names table offset.
 0000008C  00000000	      C LE_NoneResSize          dd ?    ;non-resident names table length.
 00000090  00000000	      C LE_NoneResChk           dd ?    ;non-resident names checksum.
 00000094  00000000	      C LE_AutoDS               dd ?    ;automatic data object.
 00000098  00000000	      C LE_Debug                dd ?    ;debug information offset.
 0000009C  00000000	      C LE_DebugSize            dd ?    ;debug information size.
 000000A0  00000000	      C LE_PreLoadInstNum       dd ?    ;pre-load instance pages number.
 000000A4  00000000	      C LE_DemandInstNum        dd ?    ;demand instance pages number.
 000000A8  00000000	      C LE_HeapExtra            dd ?    ;extra heap alloction.
 000000AC  00000014 [	      C LE_Reserved             db 20 dup (?) ;reserved.
	    00
	   ]
 000000C0  0000		      C LE_DeviceID             dw ?    ;device ID (Windows VxD only).
 000000C2  0000		      C LE_DDK          dw ?    ;DDK version number.
			      C LE_Header               ends
			      C 
			      C 
 00000100		      C PSP_Struc		struc
			      C ;
			      C ;First the standard DOS PSP structure. Won't use any of existing entries for
			      C ;extended info incase currently un-used entries get used at a later data.
			      C ;
 00000000  0000		      C  PSP_INT20		dw ?		;INT 20 instruction for CP/M CALL 0 program
			      C 				;termination the CDh 20h here is often used as a
			      C 				;signature for a valid PSP
 00000002  0000		      C  PSP_MemTop		dw ?		;segment of first byte beyond memory allocated to
			      C 				;program. N/A
 00000004  00		      C  PSP_Filler1		db ?		;unused filler
			      C 
 00000005  00		      C  PSP_CPM		db ?		;CP/M CALL 5 service request (FAR JMP to 000C0h)
			      C 				;BUG: (DOS 2+) PSPs created by INT 21/AH=4Bh
			      C 				;point at 000BEh
 00000006  0000		      C 		dw ?		;CP/M compatibility--size of first segment for
			      C 				;.COM files
 00000008  0000		      C 		dw ?		;remainder of FAR JMP at 05h
 0000000A  00000000	      C  PSP_INT22		dd ?		;stored INT 22 termination address
 0000000E  00000000	      C  PSP_INT23		dd ?		;stored INT 23 control-Break handler address
 00000012  00000000	      C  PSP_INT24		dd ?		;DOS 1.1+ stored INT 24 critical error handler
			      C 				;address
 00000016  0000		      C  PSP_Parent		dw ?		;segment of parent PSP
 00000018  00000014 [	      C  PSP_HandleList	db 20 dup (?) ;DOS 2+ Job File Table, one byte per file
	    00
	   ]
			      C 				;handle, FFh = closed
 0000002C  0000		      C  PSP_Environment	dw ?		;segment of environment for process
 0000002E  00000000	      C  PSP_INT21SSSP	dd ?		;N/A
 00000032  0000		      C  PSP_Handles		dw ?		;DOS 3+ number of entries in JFT (default 20)
 00000034  00000000	      C  PSP_HandlePtr	dd ?		;DOS 3+ pointer to JFT (default PSP:0018h)
 00000038  00000000	      C  PSP_Previous	dd ?		;DOS 3+ pointer to previous PSP (default
			      C 				;FFFFFFFFh in 3.x) used by SHARE in DOS 3.3.
 0000003C  00000000	      C  PSP_Filler2		dd ?		;unused by DOS versions <= 6.00
			      C 				;reportedly used by Novell NetWare shell 3.x
 00000040  0000		      C  PSP_DOSVersion	dw ?		;DOS 5+ version to return on INT 21/AH=30h
 00000042  0000		      C  PSP_NextPSP		dw ?		;(MSWin3) selector of next PSP (PDB) in linked
			      C 				;list Windows keeps a linked list of Windows
			      C 				;programs only
 00000044  00000000	      C  PSP_Filler3		dd ?		;unused by DOS versions <= 6.00
 00000048  00		      C  PSP_WinOldAp	db ?		;(MSWindows3) bit 0 set if non-Windows
			      C 				;application (WINOLDAP)
 00000049  00000007 [	      C  PSP_Filler4		db 7 dup (?) ;unused by DOS versions <= 6.00
	    00
	   ]
 00000050  00000003 [	      C  PSP_INT21		db 3 dup (?) ;DOS 2+ service request (INT 21/RETF instructions)
	    00
	   ]
 00000053  00000009 [	      C  PSP_Filler5		db 9 dup (?) ;unused in DOS versions <= 6.00
	    00
	   ]
 0000005C  00000010 [	      C  PSP_FCB1		db 16 dup (?) ;first default FCB, filled in from first
	    00
	   ]
			      C 				;commandline argument overwrites second FCB if
			      C 				;opened
 0000006C  00000010 [	      C  PSP_FCB2		db 16 dup (?) ;second default FCB, filled in from second
	    00
	   ]
			      C 				;commandline argument overwrites beginning of
			      C 				;commandline if opened
 0000007C  00000000	      C  PSP_Filler6		dd ?		;unused
 00000080  00000080 [	      C  PSP_CommandTail	db 128 dup (?) ;commandline / default DTA
	    00
	   ]
			      C 				;command tail is BYTE for length of tail, N BYTEs
			      C 				;for the tail, followed by a BYTE containing 0Dh
			      C PSP_Struc		ends
			      C 
			      C 
			      C 
			      C 
			      C 
				
 00000010			_Seg_	struc
 00000000  00000000		Seg_BaseAddress dd ?
 00000004  00000000		Seg_Type	dd ?
 00000008  00000000		Seg_Length	dd ?
 0000000C  00000000		Seg_Memory	dd ?
				_Seg_	ends
				
				if @Model ne 7
				endif
				
 00000000				.data
				
 00000000 00000000		psp dd ?		; PSP linear address
				
 = 00000005			ERR_NOFILES equ 5
 = 00000006			ERR_OPENFIL equ 6
 = 00000007			ERR_HDRFMT  equ 7
 = 00000008			ERR_IO      equ 8
 = 0000001A			ERR_ALREADY3P equ 26
				
 00000004 0000			ErrorNumber	dw 0
				;
 00000006			ErrorMessages label dword
 00000006  000000B6 R			dd Errorm0, Errorm1, Errorm2, Errorm3, Errorm4, Errorm5, Errorm6, Errorm7    ;0-7
	   000000DE R
	   0000011B R
	   0000013E R
	   000004E1 R
	   00000502 R
	   0000051F R
	   0000053C R
 00000026  00000557 R			dd Errorm8, ErrorM9, ErrorM10,ErrorM11,ErrorM12,ErrorM13,ErrorM14,ErrorM15   ;8-15
	   0000057B R
	   000005AB R
	   000005C7 R
	   000005F1 R
	   0000060B R
	   0000062B R
	   00000655 R
 00000046  00000684 R			dd ErrorM16,ErrorM17,ErrorM18,ErrorM19,ErrorM20,ErrorM21,ErrorM22,ErrorM23   ;16-23
	   000006AA R
	   000006CA R
	   000006EA R
	   0000070A R
	   00000732 R
	   00000746 R
	   00000776 R
 00000066  00000792 R			dd ErrorM24,ErrorM25,ErrorM26,ErrorM27,ErrorM0, ErrorM0                      ;24-29
	   000007C4 R
	   000007F8 R
	   0000081A R
	   000000B6 R
	   000000B6 R
 0000007E  000000B6 R			dd ErrorM0, ErrorM0, ErrorM32,ErrorM33,ErrorM34,ErrorM35,ErrorM36,ErrorM37   ;30-37
	   000000B6 R
	   00000836 R
	   0000085A R
	   00000875 R
	   0000089A R
	   000008B3 R
	   000008DA R
 0000009E  000008FA R			dd ErrorM38,ErrorM39,ErrorM40,ErrorM41,ErrorM42,ErrorM43                     ;38-43
	   00000926 R
	   0000094E R
	   00000970 R
	   000009A9 R
	   000009CF R
				;
 000000B6 4F 70 65 72 61	Errorm0	db 'Operation completed successfully...',13,10,13,10,'$'
	   74 69 6F 6E 20
	   63 6F 6D 70 6C
	   65 74 65 64 20
	   73 75 63 63 65
	   73 73 66 75 6C
	   6C 79 2E 2E 2E
	   0D 0A 0D 0A 24
 000000DE 55 6E 61 62 6C	Errorm1	db 'Unable to resize memory block, this should never happen...',10,13,'$'
	   65 20 74 6F 20
	   72 65 73 69 7A
	   65 20 6D 65 6D
	   6F 72 79 20 62
	   6C 6F 63 6B 2C
	   20 74 68 69 73
	   20 73 68 6F 75
	   6C 64 20 6E 65
	   76 65 72 20 68
	   61 70 70 65 6E
	   2E 2E 2E 0A 0D
	   24
 0000011B 49 6E 73 75 66	Errorm2	db 'Insufficient memory available...',13,10,'$'
	   66 69 63 69 65
	   6E 74 20 6D 65
	   6D 6F 72 79 20
	   61 76 61 69 6C
	   61 62 6C 65 2E
	   2E 2E 0D 0A 24
 0000013E 20 53 79 6E 74	Errorm3	db ' Syntax is:- CWEM Options FileName Options',13,10
	   61 78 20 69 73
	   3A 2D 20 43 57
	   45 4D 20 4F 70
	   74 69 6F 6E 73
	   20 46 69 6C 65
	   4E 61 6D 65 20
	   4F 70 74 69 6F
	   6E 73 0D 0A
 0000016A  0D 0A			db 13,10
 0000016C  20 20 20 4F 70		db '   Options:-',13,10
	   74 69 6F 6E 73
	   3A 2D 0D 0A
 0000017A  0D 0A			db 13,10
 0000017C  20 20 20 33 20		db '   3  - Enable 32 bit code segments/interupts.',13,10
	   20 2D 20 45 6E
	   61 62 6C 65 20
	   33 32 20 62 69
	   74 20 63 6F 64
	   65 20 73 65 67
	   6D 65 6E 74 73
	   2F 69 6E 74 65
	   72 75 70 74 73
	   2E 0D 0A
 000001AC  20 20 2B 62 20		db '  +b  - Bind stub loader.',13,10
	   20 2D 20 42 69
	   6E 64 20 73 74
	   75 62 20 6C 6F
	   61 64 65 72 2E
	   0D 0A
 000001C7  20 20 20 63 20		db '   c  - Config file name, eg, /c[:]example.cfg',13,10
	   20 2D 20 43 6F
	   6E 66 69 67 20
	   66 69 6C 65 20
	   6E 61 6D 65 2C
	   20 65 67 2C 20
	   2F 63 5B 3A 5D
	   65 78 61 6D 70
	   6C 65 2E 63 66
	   67 0D 0A
 000001F7  20 20 20 64 20		db '   d  - Enable dual mode operation.',13,10
	   20 2D 20 45 6E
	   61 62 6C 65 20
	   64 75 61 6C 20
	   6D 6F 64 65 20
	   6F 70 65 72 61
	   74 69 6F 6E 2E
	   0D 0A
 0000021C  20 20 20 66 20		db '   f  - Sort fixups to enable fast-load.',13,10
	   20 2D 20 53 6F
	   72 74 20 66 69
	   78 75 70 73 20
	   74 6F 20 65 6E
	   61 62 6C 65 20
	   66 61 73 74 2D
	   6C 6F 61 64 2E
	   0D 0A
 00000246  20 20 2B 67 20		db '  +g  - Enable GROUP type segments (data limits set to end of program).',13,10
	   20 2D 20 45 6E
	   61 62 6C 65 20
	   47 52 4F 55 50
	   20 74 79 70 65
	   20 73 65 67 6D
	   65 6E 74 73 20
	   28 64 61 74 61
	   20 6C 69 6D 69
	   74 73 20 73 65
	   74 20 74 6F 20
	   65 6E 64 20 6F
	   66 20 70 72 6F
	   67 72 61 6D 29
	   2E 0D 0A
 0000028F  20 20 20 69 20		db '   i  - Display 3P header information. use i, is, ir or irs.',13,10
	   20 2D 20 44 69
	   73 70 6C 61 79
	   20 33 50 20 68
	   65 61 64 65 72
	   20 69 6E 66 6F
	   72 6D 61 74 69
	   6F 6E 2E 20 75
	   73 65 20 69 2C
	   20 69 73 2C 20
	   69 72 20 6F 72
	   20 69 72 73 2E
	   0D 0A
 000002CD  20 20 20 20 20		db "        eg, /isr to see everything (s/r order not important).",13,10
	   20 20 20 65 67
	   2C 20 2F 69 73
	   72 20 74 6F 20
	   73 65 65 20 65
	   76 65 72 79 74
	   68 69 6E 67 20
	   28 73 2F 72 20
	   6F 72 64 65 72
	   20 6E 6F 74 20
	   69 6D 70 6F 72
	   74 61 6E 74 29
	   2E 0D 0A
 0000030C  20 20 20 6C 20		db '   l  - Enable LDT usage.',13,10
	   20 2D 20 45 6E
	   61 62 6C 65 20
	   4C 44 54 20 75
	   73 61 67 65 2E
	   0D 0A
 00000327  20 20 20 6E 20		db '   n  - Enable NEAR mode (code/data in same segment).',13,10
	   20 2D 20 45 6E
	   61 62 6C 65 20
	   4E 45 41 52 20
	   6D 6F 64 65 20
	   28 63 6F 64 65
	   2F 64 61 74 61
	   20 69 6E 20 73
	   61 6D 65 20 73
	   65 67 6D 65 6E
	   74 29 2E 0D 0A
 0000035E  20 20 20 73 20		db '   s  - Set auto-stack size, eg, /s2048.',13,10
	   20 2D 20 53 65
	   74 20 61 75 74
	   6F 2D 73 74 61
	   63 6B 20 73 69
	   7A 65 2C 20 65
	   67 2C 20 2F 73
	   32 30 34 38 2E
	   0D 0A
 00000388  20 20 20 75 20		db '   u  - Update copy of CauseWay in a CauseWay file.',13,10
	   20 2D 20 55 70
	   64 61 74 65 20
	   63 6F 70 79 20
	   6F 66 20 43 61
	   75 73 65 57 61
	   79 20 69 6E 20
	   61 20 43 61 75
	   73 65 57 61 79
	   20 66 69 6C 65
	   2E 0D 0A
 000003BD  20 20 2B 7A 20		db '  +z  - Append auto-stack segment to NEAR segment in NEAR model.',13,10
	   20 2D 20 41 70
	   70 65 6E 64 20
	   61 75 74 6F 2D
	   73 74 61 63 6B
	   20 73 65 67 6D
	   65 6E 74 20 74
	   6F 20 4E 45 41
	   52 20 73 65 67
	   6D 65 6E 74 20
	   69 6E 20 4E 45
	   41 52 20 6D 6F
	   64 65 6C 2E 0D
	   0A
 000003FF  0D 0A			db 13,10
 00000401  20 54 68 65 20		db ' The options above that have a + before them are ON by default.',13,10
	   6F 70 74 69 6F
	   6E 73 20 61 62
	   6F 76 65 20 74
	   68 61 74 20 68
	   61 76 65 20 61
	   20 2B 20 62 65
	   66 6F 72 65 20
	   74 68 65 6D 20
	   61 72 65 20 4F
	   4E 20 62 79 20
	   64 65 66 61 75
	   6C 74 2E 0D 0A
 00000442  20 53 77 69 74		db ' Switches are ON with + or /, OFF with -.',13,10
	   63 68 65 73 20
	   61 72 65 20 4F
	   4E 20 77 69 74
	   68 20 2B 20 6F
	   72 20 2F 2C 20
	   4F 46 46 20 77
	   69 74 68 20 2D
	   2E 0D 0A
 0000046D  20 54 68 65 20		db ' The command line can be in any order.',13,10
	   63 6F 6D 6D 61
	   6E 64 20 6C 69
	   6E 65 20 63 61
	   6E 20 62 65 20
	   69 6E 20 61 6E
	   79 20 6F 72 64
	   65 72 2E 0D 0A
 00000495  20 49 66 20 6E		db ' If no extension is specified then .EXE is used (.MAP for map files).',13,10
	   6F 20 65 78 74
	   65 6E 73 69 6F
	   6E 20 69 73 20
	   73 70 65 63 69
	   66 69 65 64 20
	   74 68 65 6E 20
	   2E 45 58 45 20
	   69 73 20 75 73
	   65 64 20 28 2E
	   4D 41 50 20 66
	   6F 72 20 6D 61
	   70 20 66 69 6C
	   65 73 29 2E 0D
	   0A
 000004DC  0D 0A 0D 0A 24		db 13,10,13,10,'$'
 000004E1 4E 6F 20 6F 70	Errorm4	db 'No operation type specified...',13,10,'$'
	   65 72 61 74 69
	   6F 6E 20 74 79
	   70 65 20 73 70
	   65 63 69 66 69
	   65 64 2E 2E 2E
	   0D 0A 24
 00000502 4E 6F 20 66 69	Errorm5	db 'No files found to alter...',13,10,'$'
	   6C 65 73 20 66
	   6F 75 6E 64 20
	   74 6F 20 61 6C
	   74 65 72 2E 2E
	   2E 0D 0A 24
 0000051F 55 6E 61 62 6C	Errorm6	db 'Unable to open EXE file...',13,10,'$'
	   65 20 74 6F 20
	   6F 70 65 6E 20
	   45 58 45 20 66
	   69 6C 65 2E 2E
	   2E 0D 0A 24
 0000053C 49 6E 63 6F 72	Errorm7	db 'Incorrect header type...',13,10,'$'
	   72 65 63 74 20
	   68 65 61 64 65
	   72 20 74 79 70
	   65 2E 2E 2E 0D
	   0A 24
 00000557 49 2F 4F 20 65	Errorm8	db 'I/O error while accessing file...',13,10,'$'
	   72 72 6F 72 20
	   77 68 69 6C 65
	   20 61 63 63 65
	   73 73 69 6E 67
	   20 66 69 6C 65
	   2E 2E 2E 0D 0A
	   24
 0000057B 43 6F 75 6C 64	Errorm9	db 'Could not find CauseWay stub file CWSTUB.EXE.',13,10,'$'
	   20 6E 6F 74 20
	   66 69 6E 64 20
	   43 61 75 73 65
	   57 61 79 20 73
	   74 75 62 20 66
	   69 6C 65 20 43
	   57 53 54 55 42
	   2E 45 58 45 2E
	   0D 0A 24
 000005AB 43 6F 75 6C 64	ErrorM10	db 'Could not find .MAP file.',13,10,'$'
	   20 6E 6F 74 20
	   66 69 6E 64 20
	   2E 4D 41 50 20
	   66 69 6C 65 2E
	   0D 0A 24
 000005C7 43 6F 75 6C 64	ErrorM11	db 'Could not identify segment list header.',13,10,'$'
	   20 6E 6F 74 20
	   69 64 65 6E 74
	   69 66 79 20 73
	   65 67 6D 65 6E
	   74 20 6C 69 73
	   74 20 68 65 61
	   64 65 72 2E 0D
	   0A 24
 000005F1 42 61 64 20 73	ErrorM12	db 'Bad segment definition.',13,10,'$'
	   65 67 6D 65 6E
	   74 20 64 65 66
	   69 6E 69 74 69
	   6F 6E 2E 0D 0A
	   24
 0000060B 4E 6F 20 73 65	ErrorM13	db 'No segment definitions found.',13,10,'$'
	   67 6D 65 6E 74
	   20 64 65 66 69
	   6E 69 74 69 6F
	   6E 73 20 66 6F
	   75 6E 64 2E 0D
	   0A 24
 0000062B 53 65 67 6D 65	ErrorM14	db 'Segment does not have recognized class.',13,10,'$'
	   6E 74 20 64 6F
	   65 73 20 6E 6F
	   74 20 68 61 76
	   65 20 72 65 63
	   6F 67 6E 69 7A
	   65 64 20 63 6C
	   61 73 73 2E 0D
	   0A 24
 00000655 55 6E 72 65 63	ErrorM15	db 'Unrecognized variable in configuration file.',13,10,'$'
	   6F 67 6E 69 7A
	   65 64 20 76 61
	   72 69 61 62 6C
	   65 20 69 6E 20
	   63 6F 6E 66 69
	   67 75 72 61 74
	   69 6F 6E 20 66
	   69 6C 65 2E 0D
	   0A 24
 00000684 53 79 6E 74 61	ErrorM16	db 'Syntax error in configuration file.',13,10,'$'
	   78 20 65 72 72
	   6F 72 20 69 6E
	   20 63 6F 6E 66
	   69 67 75 72 61
	   74 69 6F 6E 20
	   66 69 6C 65 2E
	   0D 0A 24
 000006AA 54 6F 20 6D 61	ErrorM17	db 'To many segment declarations.',13,10,'$'
	   6E 79 20 73 65
	   67 6D 65 6E 74
	   20 64 65 63 6C
	   61 72 61 74 69
	   6F 6E 73 2E 0D
	   0A 24
 000006CA 4D 61 78 69 6D	ErrorM18	db 'Maximum line length exceeded.',13,10,'$'
	   75 6D 20 6C 69
	   6E 65 20 6C 65
	   6E 67 74 68 20
	   65 78 63 65 65
	   64 65 64 2E 0D
	   0A 24
 000006EA 55 6E 61 62 6C	ErrorM19	db 'Unable to create output file.',13,10,'$'
	   65 20 74 6F 20
	   63 72 65 61 74
	   65 20 6F 75 74
	   70 75 74 20 66
	   69 6C 65 2E 0D
	   0A 24
 0000070A 45 6E 74 72 79	ErrorM20	db 'Entry point is not in a code segment.',13,10,'$'
	   20 70 6F 69 6E
	   74 20 69 73 20
	   6E 6F 74 20 69
	   6E 20 61 20 63
	   6F 64 65 20 73
	   65 67 6D 65 6E
	   74 2E 0D 0A 24
 00000732 4E 6F 20 73 74	ErrorM21	db 'No stack defined.',13,10,'$'
	   61 63 6B 20 64
	   65 66 69 6E 65
	   64 2E 0D 0A 24
 00000746 53 74 61 63 6B	ErrorM22	db 'Stack cannot be in a code segment / No stack.',13,10,'$'
	   20 63 61 6E 6E
	   6F 74 20 62 65
	   20 69 6E 20 61
	   20 63 6F 64 65
	   20 73 65 67 6D
	   65 6E 74 20 2F
	   20 4E 6F 20 73
	   74 61 63 6B 2E
	   0D 0A 24
 00000776 49 6E 76 61 6C	ErrorM23	db 'Invalid relocation entry.',13,10,'$'
	   69 64 20 72 65
	   6C 6F 63 61 74
	   69 6F 6E 20 65
	   6E 74 72 79 2E
	   0D 0A 24
 00000792 4F 6E 6C 79 20	ErrorM24	db 'Only 1 segment definition allowed in NEAR mode.',13,10,'$'
	   31 20 73 65 67
	   6D 65 6E 74 20
	   64 65 66 69 6E
	   69 74 69 6F 6E
	   20 61 6C 6C 6F
	   77 65 64 20 69
	   6E 20 4E 45 41
	   52 20 6D 6F 64
	   65 2E 0D 0A 24
 000007C4 43 6F 75 6C 64	ErrorM25	db 'Could not identify stack segment in segment list.',13,10,'$'
	   20 6E 6F 74 20
	   69 64 65 6E 74
	   69 66 79 20 73
	   74 61 63 6B 20
	   73 65 67 6D 65
	   6E 74 20 69 6E
	   20 73 65 67 6D
	   65 6E 74 20 6C
	   69 73 74 2E 0D
	   0A 24
 000007F8 20 69 73 20 61	ErrorM26	db ' is already in CauseWay format.',13,10,'$'
	   6C 72 65 61 64
	   79 20 69 6E 20
	   43 61 75 73 65
	   57 61 79 20 66
	   6F 72 6D 61 74
	   2E 0D 0A 24
 0000081A 49 6E 76 61 6C	ErrorM27	db 'Invalid auto-stack value.',13,10,'$'
	   69 64 20 61 75
	   74 6F 2D 73 74
	   61 63 6B 20 76
	   61 6C 75 65 2E
	   0D 0A 24
				;
 00000836 43 6F 75 6C 64	ErrorM32	db "Could not open specified LE file.",13,10,0
	   20 6E 6F 74 20
	   6F 70 65 6E 20
	   73 70 65 63 69
	   66 69 65 64 20
	   4C 45 20 66 69
	   6C 65 2E 0D 0A
	   00
 0000085A 45 72 72 6F 72	ErrorM33	db "Error reading LE offset.",13,10,0
	   20 72 65 61 64
	   69 6E 67 20 4C
	   45 20 6F 66 66
	   73 65 74 2E 0D
	   0A 00
 00000875 4E 6F 74 20 65	ErrorM34	db "Not enough memory to load LE file.",13,10,0
	   6E 6F 75 67 68
	   20 6D 65 6D 6F
	   72 79 20 74 6F
	   20 6C 6F 61 64
	   20 4C 45 20 66
	   69 6C 65 2E 0D
	   0A 00
 0000089A 45 72 72 6F 72	ErrorM35	db "Error reading LE file.",13,10,0
	   20 72 65 61 64
	   69 6E 67 20 4C
	   45 20 66 69 6C
	   65 2E 0D 0A 00
 000008B3 4E 6F 74 20 65	ErrorM36	db "Not enough memory to build 3P image.",13,10,0
	   6E 6F 75 67 68
	   20 6D 65 6D 6F
	   72 79 20 74 6F
	   20 62 75 69 6C
	   64 20 33 50 20
	   69 6D 61 67 65
	   2E 0D 0A 00
 000008DA 43 6F 75 6C 64	ErrorM37	db "Could not create output file.",13,10,0
	   20 6E 6F 74 20
	   63 72 65 61 74
	   65 20 6F 75 74
	   70 75 74 20 66
	   69 6C 65 2E 0D
	   0A 00
 000008FA 45 72 72 6F 72	ErrorM38	db "Error occured while writeing output file.",13,10,0
	   20 6F 63 63 75
	   72 65 64 20 77
	   68 69 6C 65 20
	   77 72 69 74 65
	   69 6E 67 20 6F
	   75 74 70 75 74
	   20 66 69 6C 65
	   2E 0D 0A 00
 00000926 4D 75 6C 74 69	ErrorM39	db "Multiple fixup records not supported.",13,10,0
	   70 6C 65 20 66
	   69 78 75 70 20
	   72 65 63 6F 72
	   64 73 20 6E 6F
	   74 20 73 75 70
	   70 6F 72 74 65
	   64 2E 0D 0A 00
 0000094E 4F 6E 6C 79 20	ErrorM40	db "Only internal fixups supported.",13,10,0
	   69 6E 74 65 72
	   6E 61 6C 20 66
	   69 78 75 70 73
	   20 73 75 70 70
	   6F 72 74 65 64
	   2E 0D 0A 00
 00000970 49 6E 76 61 6C	ErrorM41	db "Invalid fixup type, only Seg16 and Offset32 supported.",13,10,0
	   69 64 20 66 69
	   78 75 70 20 74
	   79 70 65 2C 20
	   6F 6E 6C 79 20
	   53 65 67 31 36
	   20 61 6E 64 20
	   4F 66 66 73 65
	   74 33 32 20 73
	   75 70 70 6F 72
	   74 65 64 2E 0D
	   0A 00
 000009A9 45 72 72 6F 72	ErrorM42	db "Error reading extender stub loader.",13,10,0
	   20 72 65 61 64
	   69 6E 67 20 65
	   78 74 65 6E 64
	   65 72 20 73 74
	   75 62 20 6C 6F
	   61 64 65 72 2E
	   0D 0A 00
 000009CF 55 6E 6B 6E 6F	ErrorM43	db "Unknown fixup flag settings.",13,10,0
	   77 6E 20 66 69
	   78 75 70 20 66
	   6C 61 67 20 73
	   65 74 74 69 6E
	   67 73 2E 0D 0A
	   00
				;
 000009EE 45 52 52 4F 52	ErrorText	db 'ERROR: ',0
	   3A 20 00
					if	0
					endif
 000009F6 57 41 52 4E 49	SegSamet	db 'WARNING: Segments found with same paragraph base address.',13,10,0
	   4E 47 3A 20 53
	   65 67 6D 65 6E
	   74 73 20 66 6F
	   75 6E 64 20 77
	   69 74 68 20 73
	   61 6D 65 20 70
	   61 72 61 67 72
	   61 70 68 20 62
	   61 73 65 20 61
	   64 64 72 65 73
	   73 2E 0D 0A 00
				;
 00000A32 55 73 69 6E 67	InternalConfig	db 'Using internal segment configuration details.',13,10,0
	   20 69 6E 74 65
	   72 6E 61 6C 20
	   73 65 67 6D 65
	   6E 74 20 63 6F
	   6E 66 69 67 75
	   72 61 74 69 6F
	   6E 20 64 65 74
	   61 69 6C 73 2E
	   0D 0A 00
 00000A62 4C 69 6E 6B 69	ProcessStubText db 'Linking CauseWay stub loader.',13,10,0
	   6E 67 20 43 61
	   75 73 65 57 61
	   79 20 73 74 75
	   62 20 6C 6F 61
	   64 65 72 2E 0D
	   0A 00
 00000A82 50 72 6F 63 65	ProcessMapText	db 'Processing map file.',13,10,0
	   73 73 69 6E 67
	   20 6D 61 70 20
	   66 69 6C 65 2E
	   0D 0A 00
 00000A99 50 72 6F 63 65	ProcessExeText	db 'Processing EXE relocation table.',13,10,0
	   73 73 69 6E 67
	   20 45 58 45 20
	   72 65 6C 6F 63
	   61 74 69 6F 6E
	   20 74 61 62 6C
	   65 2E 0D 0A 00
 00000ABC 47 65 6E 65 72	GenerateExeText db 'Generating new executable file.',13,10,0
	   61 74 69 6E 67
	   20 6E 65 77 20
	   65 78 65 63 75
	   74 61 62 6C 65
	   20 66 69 6C 65
	   2E 0D 0A 00
 00000ADE 0D 0A 00		CarriageReturn	db 13,10,0
 00000AE1 0D 0A 24		CarriageReturn2 db 13,10,"$"
				;
 00000AE4 63 77 65 6D 2E	ConfigName	db 'cwem.cfg',0
	   63 66 67 00
 00000AED 43 57 53 54 55	CWStubName	db "CWSTUB.EXE",0
	   42 2E 45 58 45
	   00
 00000AF8 0000			ConfigHandle	dw 0
 00000AFA 0000			SHELLHandle	dw 0
 00000AFC 45 58 45 00		EXEextension	db 'EXE',0
 00000B00 0000			EXEHandle	dw 0                  ; file handle of .EXE to patch
 00000B02 4D 41 50 00		MAPextension	db 'MAP',0
 00000B06 0000			MAPHandle	dw 0                  ; file handle of .MAP file
 00000B08 63 6B 61 6E 65	TempFileName	db 'ckanetdy.ckq',0
	   74 64 79 2E 63
	   6B 71 00
 00000B15 0000			TempHandle	dw 0
				;
 00000B17 00000000		SegmentList	dd 0
 00000B1B 00000000		SegCurrent	dd ?
 00000B1F 00000000		SegmentTotal	dd ?
 00000B23 00000000		ExeSegment	dd ?
				;
 00000000				.data?
				
 00000000  00000080 [		ConfigPath	db 128 dup (?)
	    00
	   ]
 00000080  00000080 [		SHELLFileName	db 128 dup (?)    ; name of CW.EXE binary, gotten from environment
	    00
	   ]
 00000100  00000040 [		EXEFileName	db 64 dup (?)
	    00
	   ]
 00000140  00000040 [		MAPFileName	db 64 dup (?)
	    00
	   ]
 00000180  00000400 [		LineBuffer	db 1024 dup (?)
	    00
	   ]
				
 00000B27				.data
				;
 00000B27 00000000		RelocSegment	dd ?
				;
 0000001B			MZHdr struct
 00000000  0000			Signature	dw ?	;00 Identifier text 'MZ', '3P'.
 00000002  0000			_Length		dw ?	;02 Length of file MOD 512
 00000004  0000						dw ?	;04 Length of file in 512 byte blocks.
 00000006  0000			RelocNum	dw ?	;06 Number of relocation items.
 00000008  0000			HeaderSize	dw ?	;08 Length of header in 16 byte paragraphs.
 0000000A  0000			MinAlloc	dw ?	;0A Minimum number of para's needed above program.
 0000000C  0000			MaxAlloc	dw ?	;0C Maximum number of para's needed above program.
 0000000E  0000			StackSeg	dw ?	;0E Segment displacement of stack module.
 00000010  0000			EntrySP		dw ?	;10 value for SP at entry.
 00000012  0000			CheckSum	dw ?	;12 Check sum...
 00000014  0000			EntryIP	dw ?	;14 Contents of IP at entry.
 00000016  0000			EntryCS	dw ?	;16 Segment displacement of CS at entry.
 00000018  0000			RelocFirst	dw ?	;18 First relocation item offset.
 0000001A  00			OverlayNum	db ?	;1A Overlay number.
				MZHdr ends
				
 00000B2B 0000 0000 0000	exehdr MZHdr <>
	   0000 0000 0000
	   0000 0000 0000
	   0000 0000 0000
	   0000 00
				;
 00000B46 0000 0000		ExeSize1	dw ?,?	;Header size
 00000B4A 0000 0000		ExeSize2	dw ?,?	;Real file size.
				;
 00000B4E  00000001 [		NewHeader	NewHeaderStruc <>	;make space for a header.
	    33 50
	   ] 00000000
	   00000000
	   00000000 0000
	   00000000
	   00000000 0000
	   00000000 0000
	   00000000
	   00000000 0000
	   00000000
	   00000000
	   00000000
	   0000000A [
	    00
	   ]
				;
				;List of variables for the config file.
				;
 00000B8E 00000C02 R		VariableList	dd SegHeaderVAR,WhiteSpaceString,SegHeaderText,0
	   00002D10 R
	   00000C53 R
	   00000000
 00000B9E  00000C10 R			dd SegFormatVAR,SegFormatCode,SegLayout,0
	   00002DB8 R
	   00000D22 R
	   00000000
 00000BAE  00000C1E R			dd CodeClassVAR,WhiteSpaceString,SegClassCODE,0
	   00002D10 R
	   00000E41 R
	   00000000
 00000BBE  00000C28 R			dd DataClassVAR,WhiteSpaceString,SegClassDATA,0
	   00002D10 R
	   00001647 R
	   00000000
 00000BCE  00000C32 R			dd StackClassVAR,WhiteSpaceString,SegClassSTACK,0
	   00002D10 R
	   00001E4D R
	   00000000
 00000BDE  00000C3D R			dd ConstClassVAR,WhiteSpaceString,SegClassCONST,0
	   00002D10 R
	   00002654 R
	   00000000
 00000BEE  00000C48 R			dd NearClassVAR,WhiteSpaceString,SegClassNEAR,0
	   00002D10 R
	   00002E5B R
	   00000000
 00000BFE  FFFFFFFF			dd -1
				;
 00000C02 53 65 67 6D 65	SegHeaderVAR	db 'SegmentHeader',0
	   6E 74 48 65 61
	   64 65 72 00
 00000C10 53 65 67 6D 65	SegFormatVAR	db 'SegmentFormat',0
	   6E 74 46 6F 72
	   6D 61 74 00
 00000C1E 43 6F 64 65 43	CodeClassVAR	db 'CodeClass',0
	   6C 61 73 73 00
 00000C28 44 61 74 61 43	DataClassVAR	db 'DataClass',0
	   6C 61 73 73 00
 00000C32 53 74 61 63 6B	StackClassVAR	db 'StackClass',0
	   43 6C 61 73 73
	   00
 00000C3D 43 6F 6E 73 74	ConstClassVAR	db 'ConstClass',0
	   43 6C 61 73 73
	   00
 00000C48 4E 65 61 72 43	NearClassVAR	db 'NearClass',0
	   6C 61 73 73 00
				;
				;
				;The text looked for to identify start of segment list. Any amount of white space can
				;be replaced with a single space here. search is NOT case sensitive.
				;
 00000C52  FF				db -1
 00000C53 20 73 74 61 72	SegHeaderText	db ' start stop length name class',0
	   74 20 73 74 6F
	   70 20 6C 65 6E
	   67 74 68 20 6E
	   61 6D 65 20 63
	   6C 61 73 73 00
 00000C71  00000080 [			db 128 dup (0)
	    00
	   ]
				;
 00000CF1 00000D05 R		SegFormatTexts	dd NullText,StartText,LengthText,ClassText,-1
	   00000D0A R
	   00000D10 R
	   00000D17 R
	   FFFFFFFF
 00000D05 6E 75 6C 6C 00	NullText	db 'null',0
 00000D0A 73 74 61 72 74	StartText	db 'start',0
	   00
 00000D10 6C 65 6E 67 74	LengthText	db 'length',0
	   68 00
 00000D17 63 6C 61 73 73	ClassText	db 'class',0
	   00
 00000D1D 00 00 00 00 00	SegFormatSlots	db 0,0,0,0,0
				;
				;Layout of each line.
				;
				;0	- Ignore.
				;1	- Start.
				;2	- Length.
				;3	- Class.
				;
 00000D22 01 00 02 00 03	SegLayout	db 1,0,2,0,3,-1
	   FF
 00000D28  00000100 [			db 256 dup (-1)
	    FF
	   ]
				
				;
				;List of different class's recognised.
				;
 00000E28 00000E41 R		SegClassList	dd SegClassCODE,SegClassDATA,SegClassSTACK,SegClassCONST,SegClassNEAR,-1
	   00001647 R
	   00001E4D R
	   00002654 R
	   00002E5B R
	   FFFFFFFF
				
				
				;
				;list of code segment classes seperated by a space.
				;
 00000E40  FF				db -1
 00000E41 63 6F 64 65 00	SegClassCODE	db 'code',0
 00000E46  00000800 [			db 2048 dup (0)
	    00
	   ]
				
				;
				;List of data segment classes seperated by a space.
				;
 00001646  FF				db -1
 00001647 64 61 74 61 00	SegClassDATA	db 'data',0
 0000164C  00000800 [			db 2048 dup (0)
	    00
	   ]
				
				;
				;List of stack segment classes seperated by a space.
				;
 00001E4C  FF				db -1
 00001E4D 73 74 61 63 6B	SegClassSTACK	db 'stack',0
	   00
 00001E53  00000800 [			db 2048 dup (0)
	    00
	   ]
				
				;
				;List of const segment classes seperated by a space.
				;
 00002653  FF				db -1
 00002654 63 6F 6E 73 74	SegClassCONST	db 'const',0
	   00
 0000265A  00000800 [			db 2048 dup (0)
	    00
	   ]
				
				;
				;List of flat segment classes seperated by space.
				;
 00002E5A  FF				db -1
 00002E5B 4E 45 41 52 00	SegClassNEAR	db 'NEAR',0
 00002E60  00000800 [			db 2048 dup (0)
	    00
	   ]
				
				;
 00003660 31 36 20 62 69	Bit16Text	db '16 bit application.',13,10,'$'
	   74 20 61 70 70
	   6C 69 63 61 74
	   69 6F 6E 2E 0D
	   0A 24
 00003676 33 32 20 62 69	Bit32Text	db '32 bit application.',13,10,'$'
	   74 20 61 70 70
	   6C 69 63 61 74
	   69 6F 6E 2E 0D
	   0A 24
 0000368C 44 75 61 6C 20	BitDualText	db 'Dual mode application.',13,10,'$'
	   6D 6F 64 65 20
	   61 70 70 6C 69
	   63 61 74 69 6F
	   6E 2E 0D 0A 24
 000036A5 53 70 65 65 64	SpeedLoadText	db "Speed-Load enabled.",13,10,13,10,"$"
	   2D 4C 6F 61 64
	   20 65 6E 61 62
	   6C 65 64 2E 0D
	   0A 0D 0A 24
				;
 000036BD 20 20 20 20 33	NewSizeT	db '    3P size: ',0	;byte size of 3P file.
	   50 20 73 69 7A
	   65 3A 20 00
 000036CB 20 49 6D 61 67	NewLengthT	db ' Image size: ',0	;byte size of exe image data.
	   65 20 73 69 7A
	   65 3A 20 00
 000036D9 4D 65 6D 6F 72	NewAllocT	db 'Memory size: ',0	;byte size of program.
	   79 20 73 69 7A
	   65 3A 20 00
 000036E7 20 20 20 53 65	NewSegmentsT	db '   Segments: ',0	;number of segment definitions.
	   67 6D 65 6E 74
	   73 3A 20 00
 000036F5 52 65 6C 6F 63	NewRelocsT	db 'Relocations: ',0	;number of relocation table entries.
	   61 74 69 6F 6E
	   73 3A 20 00
 00003703 20 20 45 6E 74	NewEntryEIPt	db '  Entry EIP: ',0	;entry offset.
	   72 79 20 45 49
	   50 3A 20 00
 00003711 20 20 20 45 6E	NewEntryCSt	db '   Entry CS: ',0	;segment list entry number for entry CS.
	   74 72 79 20 43
	   53 3A 20 00
 0000371F 20 20 45 6E 74	NewEntryESPt	db '  Entry ESP: ',0	;ESP offset.
	   72 79 20 45 53
	   50 3A 20 00
 0000372D 20 20 20 45 6E	NewEntrySSt	db '   Entry SS: ',0	;segment list entry number for SS.
	   74 72 79 20 53
	   53 3A 20 00
 0000373B 20 41 75 74 6F	NewEntryAutoSS	db ' Auto-Stack: ',0	;Auto stack size.
	   2D 53 74 61 63
	   6B 3A 20 00
				;
 00003749 0D 0A 52 65 61	ReadingMainText db 13,10,"Reading segments, relocations and image data.",13,10,0
	   64 69 6E 67 20
	   73 65 67 6D 65
	   6E 74 73 2C 20
	   72 65 6C 6F 63
	   61 74 69 6F 6E
	   73 20 61 6E 64
	   20 69 6D 61 67
	   65 20 64 61 74
	   61 2E 0D 0A 00
				;
 0000377B 0D 0A 20 53 65	SegmentStuff	db 13,10," Segment definition details"
	   67 6D 65 6E 74
	   20 64 65 66 69
	   6E 69 74 69 6F
	   6E 20 64 65 74
	   61 69 6C 73
 00003798  0D 0A 3D 3D 3D		db 13,10,"============================",13,10
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   0D 0A
 000037B8  0D 0A 20 4E 6F		db 13,10,' No.   Base     Limit  Class'
	   2E 20 20 20 42
	   61 73 65 20 20
	   20 20 20 4C 69
	   6D 69 74 20 20
	   43 6C 61 73 73
 000037D6  0D 0A 2D 2D 2D		db 13,10,'-----------------------------',13,10,0
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 0D 0A 00
				;
 000037F8 0D 0A 20 52 65	RelocStuff	db 13,10," Relocation entry details"
	   6C 6F 63 61 74
	   69 6F 6E 20 65
	   6E 74 72 79 20
	   64 65 74 61 69
	   6C 73
 00003813  0D 0A 3D 3D 3D		db 13,10,"==========================",13,10
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 3D 3D
	   3D 3D 3D 0D 0A
 00003831  0D 0A 20 4E 6F		db 13,10,' No.  Offset   Segment'
	   2E 20 20 4F 66
	   66 73 65 74 20
	   20 20 53 65 67
	   6D 65 6E 74
 00003849  0D 0A 2D 2D 2D		db 13,10,'-----------------------',13,10,0
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   0D 0A 00
				;
 00003865 49 4E 56 41 4C	InvalidText	db "INVALID "
	   49 44 20
				;
 0000386D 00000000		Real3POffset	dd ?
				;
 00003871 52 65 61 64 69	ReadingLEText	db "Reading specified LE file.",13,10,0
	   6E 67 20 73 70
	   65 63 69 66 69
	   65 64 20 4C 45
	   20 66 69 6C 65
	   2E 0D 0A 00
 0000388E 42 75 69 6C 64	BuildImageText	db "Building EXE and segment image.",13,10,0
	   69 6E 67 20 45
	   58 45 20 61 6E
	   64 20 73 65 67
	   6D 65 6E 74 20
	   69 6D 61 67 65
	   2E 0D 0A 00
 000038B0 42 75 69 6C 64	BuildRelocsText db "Building relocation table.",13,10,0
	   69 6E 67 20 72
	   65 6C 6F 63 61
	   74 69 6F 6E 20
	   74 61 62 6C 65
	   2E 0D 0A 00
 000038CD 42 75 69 6C 64	BuildHeaderText db "Building 3P format header.",13,10,0
	   69 6E 67 20 33
	   50 20 66 6F 72
	   6D 61 74 20 68
	   65 61 64 65 72
	   2E 0D 0A 00
 000038EA 57 72 69 74 65	Write3PText	db "Writeing 3P file.",13,10,0
	   69 6E 67 20 33
	   50 20 66 69 6C
	   65 2E 0D 0A 00
				;
 000038FE 00000000		LEAddress	dd 0
 00003902 00000000		LELength	dd 0
 00003906 00000000		LEOffset	dd 0
				;
 0000390A 00000000		ObjectCount	dd 0
 0000390E 00000000		ObjectBase	dd 0
 00003912 00000000		ObjectList	dd 0
				;
 00003916 00000000		RelocationList	dd 0
				;
 0000391A 00000000		SegmentBase	dd 0
				;
 0000391E 00000000		PageCount	dd 0,0
	   00000000
				;
 00003926  00000001 [		RealHeader	NewHeaderStruc <>
	    33 50
	   ] 00000000
	   00000000
	   00000000 0000
	   00000000
	   00000000 0000
	   00000000 0000
	   00000000
	   00000000 0000
	   00000000
	   00000000
	   00000000
	   0000000A [
	    00
	   ]
				;
 00003966 00000000		StubMem	dd 0
 0000396A 00000000		RelocationCount dd 0
				;
				if @Model ne 7
				endif
				;
 0000396E 00000000		RelocMem	dd 0,0
	   00000000
 00003976 00000000		P3Offset	dd 0
				
 0000397A  FF				db -1			;just to make sure end of segment is initialised.
				
 00000000				.code
				
 00000000 43 61 75 73 65	HiThere	 db 'CauseWay EXE maker v2.02.',13,10,'$'
	   57 61 79 20 45
	   58 45 20 6D 61
	   6B 65 72 20 76
	   32 2E 30 32 2E
	   0D 0A 24
				
				ifdef _DEBUG
				        include dprintf.inc
			      C 
			      C ;--- simple 32-bit printf() implementation;
			      C ;--- used by debug displays only.
			      C ;--- assume ds:nothing, ss:nothing
			      C 
			      C ;--- ltob(long n[eax], char *outb[ebx], int base[cx]);
			      C ;--- convert long to string;
			      C ;--- outb is assumed to be stack-located.
			      C 
			      C @dprintf macro cond,fmt,a1,a2,a3,a4,a5
			      C if DBGOPT and cond
			      C   for x,<a5,a4,a3,a2,a1>
			      C    ifnb <x>
			      C 	push x
			      C    endif
			      C   endm
			      C 	call dprintf
			      C 	db fmt,0
			      C endif
			      C endm
			      C 
 0000001C		      C ltob PROC uses edi
			      C 
 0000001D  0F B7 F9	      C 	movzx edi, cx
 00000020  B5 00	      C 	mov ch,0
 00000022  66| 83 FF F6	      C 	cmp di,-10
 00000026  75 0C	      C 	jne @F
 00000028  66| BF 000A	      C 	mov di,10
 0000002C  23 C0	      C 	and eax,eax
 0000002E  79 04	      C 	jns @F
 00000030  F7 D8	      C 	neg eax
 00000032  B5 2D	      C 	mov ch,'-'
 00000034		      C @@:
 00000034  83 C3 0A	      C 	add ebx,10
 00000037  36: C6 03 00	      C 	mov BYTE PTR ss:[ebx],0
 0000003B  4B		      C 	dec ebx
 0000003C		      C @@nextdigit:
 0000003C  33 D2	      C 	xor edx, edx
 0000003E  F7 F7	      C 	div edi
 00000040  80 C2 30	      C 	add dl,'0'
 00000043  80 FA 39	      C 	cmp dl,'9'
 00000046  76 03	      C 	jbe @F
 00000048  80 C2 27	      C 	add dl,7+20h
 0000004B		      C @@:
 0000004B  36: 88 13	      C 	mov ss:[ebx],dl
 0000004E  66| 4B	      C 	dec bx
 00000050  23 C0	      C 	and eax, eax
 00000052  75 E8	      C 	jne @@nextdigit
 00000054  80 FD 00	      C 	cmp ch,0
 00000057  74 04	      C 	je @F
 00000059  36: 88 2B	      C 	mov ss:[ebx],ch
 0000005C  4B		      C 	dec ebx
 0000005D		      C @@:
 0000005D  43		      C 	inc ebx
 0000005E  8B C3	      C 	mov eax,ebx
			      C 	ret
			      C 
 00000062		      C ltob ENDP
			      C 
 00000062		      C dprintf PROC
			      C 
			      C local size_:dword
			      C local flag:byte
			      C local longarg:byte
			      C local fill:byte
			      C local szTmp[12]:byte
			      C 
 = [ebp+4]		      C fmt equ <[ebp+4]>
			      C 
 00000068  60		      C 	pushad
 00000069  9C		      C 	pushfd
 0000006A  8D 7D 08	      C 	lea edi,[ebp+4+4]
 0000006D		      C @@L335:
 0000006D  8B 75 04	      C 	mov esi,fmt
 00000070		      C nextchar:
 00000070  2E: AC	      C 	lodsb cs:[esi]
 00000072  0A C0	      C 	or al,al
 00000074  74 0B	      C 	je done
 00000076  3C 25	      C 	cmp al,'%'
 00000078  74 1C	      C 	je formatitem
 0000007A  E8 00000134	      C 	call print_char
 0000007F  EB EF	      C 	jmp nextchar
 00000081		      C done:
 00000081  83 EF 04	      C 	sub edi,4
 00000084  36: 89 37	      C 	mov ss:[edi],esi ;store new EIP
 00000087  8B 45 00	      C 	mov eax,[ebp]    ;get old value of EBP
 0000008A  9D		      C 	popfd
 0000008B  8B EC	      C 	mov ebp,esp
 0000008D  89 45 08	      C 	mov [ebp+2*4],eax;now EBP will be restored by popad
 00000090  89 7D 20	      C 	mov [ebp+8*4],edi;finally store new SP
 00000093  61		      C 	popad
 00000094  5C		      C 	pop esp
 00000095  C3		      C 	retn
			      C 
 00000096		      C formatitem:
 00000096  68 0000006D R      C 	push @@L335
 0000009B  33 D2	      C 	xor edx,edx
 0000009D  88 55 FA	      C 	mov [longarg],dl
 000000A0  B3 01	      C 	mov bl,1
 000000A2  B1 20	      C 	mov cl,' '
 000000A4  2E: 80 3E 2D	      C 	cmp BYTE PTR cs:[esi],'-'
 000000A8  75 02	      C 	jne @F
 000000AA  4B		      C 	dec ebx
 000000AB  46		      C 	inc esi
 000000AC		      C @@:
 000000AC  88 5D FB	      C 	mov [flag],bl
 000000AF  2E: 80 3E 30	      C 	cmp BYTE PTR cs:[esi],'0'
 000000B3  75 03	      C 	jne @F
 000000B5  B1 30	      C 	mov cl,'0'
 000000B7  46		      C 	inc esi
 000000B8		      C @@:
 000000B8  88 4D F9	      C 	mov [fill],cl
 000000BB  8B DA	      C 	mov ebx,edx
			      C 
			      C 	.while byte ptr cs:[esi] >= '0' && byte ptr cs:[esi] <= '9'
 000000BF  2E: AC	      C 		lodsb cs:[esi]
 000000C1  2C 30	      C 		sub al,'0'
 000000C3  0F B6 C0	      C 		movzx eax,al
 000000C6  D1 E3	      C 		shl ebx,1           ;ebx*2
 000000C8  8D 1C 9B	      C 		lea ebx,[ebx*4+ebx]	;ebx*10
 000000CB  03 D8	      C 		add ebx,eax
			      C 	.endw
			      C 
 000000D9  89 5D FC	      C 	mov [size_],ebx
 000000DC  2E: 80 3E 6C	      C 	cmp BYTE PTR cs:[esi],'l'
 000000E0  75 05	      C 	jne @F
 000000E2  C6 45 FA 01	      C 	mov [longarg],1
 000000E6  46		      C 	inc esi
 000000E7		      C @@:
 000000E7  2E: AC	      C 	lodsb cs:[esi]
 000000E9  89 75 04	      C 	mov fmt,esi
 000000EC  3C 78	      C 	cmp al,'x'
 000000EE  74 2F	      C 	je handle_x
 000000F0  3C 58	      C 	cmp al,'X'
 000000F2  74 2B	      C 	je handle_x
 000000F4  3C 63	      C 	cmp al,'c'
 000000F6  74 1B	      C 	je handle_c
 000000F8  3C 64	      C 	cmp al,'d'
 000000FA  74 29	      C 	je handle_d
 000000FC  3C 69	      C 	cmp al,'i'
 000000FE  74 25	      C 	je handle_i
 00000100  3C 73	      C 	cmp al,'s'
 00000102  74 4E	      C 	je handle_s
 00000104  3C 75	      C 	cmp al,'u'
 00000106  74 23	      C 	je handle_u
 00000108  3C 00	      C 	cmp al,0
 0000010A  75 0D	      C 	jnz @@L359
 0000010C  66| 58	      C 	pop ax
 0000010E  E9 FFFFFF6E	      C 	jmp done
 00000113		      C handle_c:
 00000113  36: 8B 07	      C 	mov eax,ss:[edi]
 00000116  83 C7 04	      C 	add edi,4
 00000119		      C @@L359:
 00000119  E8 00000095	      C 	call print_char
 0000011E  C3		      C 	retn
			      C 
 0000011F		      C handle_x:
 0000011F  66| B9 0010	      C 	mov cx,16
 00000123  EB 0A	      C 	jmp @@lprt262
 00000125		      C handle_d:
 00000125		      C handle_i:
 00000125  66| B9 FFF6	      C 	mov cx,-10
 00000129  EB 04	      C 	jmp @@lprt262
 0000012B		      C handle_u:
 0000012B  66| B9 000A	      C 	mov cx,10
 0000012F		      C @@lprt262:
 0000012F  36: 8B 07	      C 	mov eax,ss:[edi]
 00000132  83 C7 04	      C 	add edi,4
 00000135  80 7D FA 00	      C 	cmp [longarg],0
 00000139  75 03	      C 	jne @F
 0000013B  0F B7 C0	      C 	movzx eax,ax
 0000013E		      C @@:
 0000013E  8D 5D ED	      C 	lea ebx,[szTmp]
 00000141  E8 FFFFFED6	      C 	call ltob
 00000146  8B F0	      C 	mov esi,eax
 00000148  1E		      C 	push ds
 00000149  16		      C 	push ss
 0000014A  1F		      C 	pop ds
 0000014B  E8 0000001D	      C 	call print_string
 00000150  1F		      C 	pop ds
 00000151  C3		      C 	retn
			      C 
 00000152		      C handle_s:
 00000152  36: 8B 37	      C 	mov esi,ss:[edi]
 00000155  83 C7 04	      C 	add edi,4
 00000158  80 7D FA 00	      C 	cmp [longarg],0
 0000015C  74 0F	      C 	je print_string
 0000015E  1E		      C 	push ds
 0000015F  36: 8E 1F	      C 	mov ds,ss:[edi]
 00000162  66| 83 C7 04	      C 	add di,4
 00000166  E8 00000002	      C 	call print_string
 0000016B  1F		      C 	pop ds
 0000016C  C3		      C 	retn
			      C 
 0000016D		      C print_string:	;display string at ds:si
 0000016D  8B C6	      C 	mov eax,esi
 0000016F  8B 5D FC	      C 	mov ebx,size_
			      C 	.while byte ptr [esi]
 00000174  46		      C 		inc esi
			      C 	.endw
 0000017A  2B F0	      C 	sub esi,eax
 0000017C  96		      C 	xchg eax,esi
 0000017D  2B D8	      C 	sub ebx,eax
			      C 	.if flag == 1
			      C 		.while sdword ptr ebx > 0
 00000187  8A 45 F9	      C 			mov al,[fill]
 0000018A  E8 00000024	      C 			call print_char
 0000018F  4B		      C 			dec ebx
			      C 		.endw
			      C 	.endif
			      C 
			      C 	.while byte ptr [esi]
 00000197  AC		      C 		lodsb
 00000198  E8 00000016	      C 		call print_char
			      C 	.endw
			      C 
			      C 	.while sdword ptr ebx > 0
 000001A4  8A 45 F9	      C 		mov al,[fill]
 000001A7  E8 00000007	      C 		call print_char
 000001AC  4B		      C 		dec ebx
			      C 	.endw
 000001B2  C3		      C 	retn
 000001B3		      C print_char:
 000001B3  3C 0A	      C 	cmp al,10
 000001B5  75 09	      C 	jnz @F
 000001B7  B0 0D	      C 	mov al,13
 000001B9  E8 00000002	      C 	call @F
 000001BE  B0 0A	      C 	mov al,10
 000001C0		      C @@:
 000001C0  53		      C 	push ebx
 000001C1  33 DB	      C 	xor ebx,ebx
 000001C3  B4 0E	      C 	mov ah,0Eh
 000001C5  CD 10	      C 	int 10h
 000001C7  5B		      C 	pop ebx
 000001C8  C3		      C 	retn
			      C 
 = 			      C fmt equ <>
			      C 
 000001C9		      C dprintf ENDP
			      C 
			      C 	align 4
			      C 
				 ifndef DBGOPT
 =-00000001			DBGOPT = -1
				 endif
				else
				endif
				
				ifndef CWAPP
				else
 000001CC			start:
				endif
 000001CC			Entry	proc	far
				
				ifndef CWAPP
				else
 000001CC  8C C3			mov ebx, es
 000001CE  66| B8 0006			mov ax, 6
 000001D2  CD 31			int 31h
 000001D4  66| 8B C1			mov ax, cx
 000001D7  C1 E0 10			shl eax, 16
 000001DA  66| 8B C2			mov ax, dx
 000001DD  A3 00000000 R		mov [psp], eax
 000001E2  1E				push ds
 000001E3  07				pop es
				endif
				if @Model ne 7
				endif
					;
 000001E4  BA 00000000 R		mov	edx,offset HiThere
 000001E9  B4 09			mov	ah,9
 000001EB  CD 21			int	21h
 000001ED  66| C7 05			mov	ErrorNumber,3
	   00000004 R
	   0003
					;
 000001F6  BF 00000B50 R		mov	edi,offset NewHeader+2
 000001FB  B9 0000003E			mov	ecx,size NewHeaderStruc-2
 00000200  32 C0			xor	al,al
 00000202  F3/ AA			rep	stosb
					;
 00000204  C6 05 000039C3 R		mov	OptionTable+'G','+'	;default to groups.
	   2B
 0000020B  C6 05 000039BE R		mov	OptionTable+'B','+'	;default to bind loader.
	   2B
 00000212  C6 05 000039D6 R		mov	OptionTable+'Z','+'	;default to auto stack on near.
	   2B
					;
 00000219  E8 00002CB5			call	ReadCommand		;read the command line.
 0000021E  66| 83 F8 01			cmp	ax,1
 00000222  0F 82 000002FC		jc	System		;need at least 2 names.
 00000228  66| C7 05			mov	ErrorNumber,5
	   00000004 R
	   0005
					@dprintf 1,<"debug messages ON",10>
 00000231  E8 FFFFFE2C	     1		call dprintf
 00000236  64 65 62 75 67    1		db "debug messages ON",10,0
	   20 6D 65 73 73
	   61 67 65 73 20
	   4F 4E 0A 00
 00000249  66| 83 3D			cmp	w[OptionTable+128],0	;get file name mask.
	   000039FC R 00
 00000251  0F 84 000002CD		jz	System		;must have a name.
 00000257  80 3D 000039CA R		cmp	OptionTable+'N',0
	   00
 0000025E  74 07			jz	@@NoGroupDel
 00000260  C6 05 000039C3 R		mov	OptionTable+'G',0	;turn group stuff off.
	   00
 00000267			@@NoGroupDel:	;
					;Read config file.
					;
 00000267  E8 000028F8			call	ReadConfig
 0000026C  0F 85 000002B2		jnz	System
					;
					;Get the .EXE file name and add .EXE if needed.
					;
 00000272  8B 35 000039FC R		mov	esi,d[OptionTable+128]	;get file name mask.
 00000278  BF 00000100 R		mov	edi,offset EXEFileName
 0000027D  FC				cld
 0000027E  32 C0			xor	al,al
 00000280			@@0:
 00000280  A4				movsb
 00000281  80 7E FF 2E			cmp	b[esi-1],'.'
 00000285  75 02			jnz	@@1
 00000287  B0 01			mov	al,1
 00000289			@@1:
 00000289  80 7E FF 00			cmp	b[esi-1],0
 0000028D  75 F1			jnz	@@0
 0000028F  0A C0			or	al,al
 00000291  75 10			jnz	@@2
 00000293  C6 47 FF 2E			mov	b[edi-1],'.'
 00000297  BE 00000AFC R		mov	esi,offset EXEextension
 0000029C			@@4:
 0000029C  A4				movsb
 0000029D  80 7E FF 00			cmp	b[esi-1],0
 000002A1  75 F9			jnz	@@4
					;
 000002A3			@@2:	;Generate .MAP file name.
					;
 000002A3  BE 00000100 R		mov	esi,offset EXEFileName
 000002A8  BF 00000140 R		mov	edi,offset MapFileName
 000002AD			@@3:
 000002AD  A4				movsb
 000002AE  80 7E FF 2E			cmp	b[esi-1],'.'
 000002B2  75 F9			jnz	@@3
 000002B4  BE 00000B02 R		mov	esi,offset MAPextension
 000002B9			@@5:
 000002B9  A4				movsb
 000002BA  80 7E FF 00			cmp	b[esi-1],0
 000002BE  75 F9			jnz	@@5
					;
					;Generate shell file name.
					;
 000002C0  8B 1D 00000000 R		mov	ebx, psp
 000002C6  66| 8B 5B 2C			mov	bx,[ebx+2ch]		;Get enviroment string selector
 000002CA  66| B8 0006			mov ax,6
 000002CE  CD 31			int 31h
 000002D0  66| 51			push cx
 000002D2  66| 52			push dx
 000002D4  5E				pop esi			;Point at the enviroment string.
 000002D5			@@10a:
 000002D5  8A 06			mov	al,[esi]		;Get a byte.
 000002D7  46				inc	esi		;/
 000002D8  0A C0			or	al,al		;End of a string?
 000002DA  75 F9			jnz	@@10a		;keep looking.
 000002DC  8A 06			mov	al,[esi]		;Double zero?
 000002DE  0A C0			or	al,al		;/
 000002E0  75 F3			jnz	@@10a		;keep looking.
 000002E2  83 C6 03			add	esi,3		;Skip last 0 and word count.
 000002E5  FC				cld			;/
 000002E6  BF 00000080 R		mov	edi,offset SHELLFileName	;Where we're gonna put it.
 000002EB  8B D7		    mov	edx,edi
 000002ED			@@70:
 000002ED  AC				lodsb
 000002EE  AA			    stosb
 000002EF  3C 5C		    cmp al,'\'
 000002F1  75 02		    jnz noslash
 000002F3  8B D7		    mov edx,edi
 000002F5			noslash:
 000002F5  3C 00			cmp	al,0		;copy till end.
 000002F7  75 F4			jnz	@@70
 000002F9  8B FA			mov edi, edx
 000002FB  BE 00000AED R	    mov esi, offset CWStubName
 00000300			nextchar:
 00000300  AC			    lodsb
 00000301  AA			    stosb
 00000302  22 C0		    and al,al
 00000304  75 FA		    jnz nextchar
					;
					;Check file type.
					;
				;	mov	bx,EXEHandle
				;	call	CloseFile
 00000306  BA 00000100 R		mov	edx,offset EXEFileName
 0000030B  E8 00002D0B			call	OpenFile		;Open the .EXE file.
 00000310  66| C7 05			mov	ErrorNumber,6	;default to not found.
	   00000004 R
	   0006
 00000319  0F 82 00000205		jc	System
					@dprintf 1,<"Entry: open file %s ok",10>,edx
 0000031F  52		     2		push edx
 00000320  E8 FFFFFD3D	     1		call dprintf
 00000325  45 6E 74 72 79    1		db "Entry: open file %s ok",10,0
	   3A 20 6F 70 65
	   6E 20 66 69 6C
	   65 20 25 73 20
	   6F 6B 0A 00
 0000033D  66| A3			mov	EXEHandle,ax
	   00000B00 R
 00000343  66| 8B D8			mov	bx,ax
					;
					;See if EXE is LE format.
					;
 00000346  BA 00000B2B R		mov edx, offset exehdr
 0000034B  B9 0000001B			mov ecx, sizeof MZHdr
 00000350  B4 3F			mov	ah,3fh
 00000352  CD 21			int	21h		;read the .EXE header.
 00000354  66| 83 F8 1B			cmp	ax,sizeof MZHdr
 00000358  75 72			jnz	@@LEReset
 0000035A  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Correct ID?
	   00000B2B R
	   5A4D
 00000363  75 67			jnz	@@LEReset
 00000365  66| 83 3D			cmp	exehdr.HeaderSize, 4	; at least 40h byte header?
	   00000B33 R 04
 0000036D  72 5D			jb	@@LEReset
				    
 0000036F  66| BA 003C			mov	dx,3ch
 00000373  66| 33 C9			xor	cx,cx
 00000376  66| B8 4200			mov	ax,4200h
 0000037A  CD 21			int	21h
 0000037C  52				push	edx
 0000037D  8B D4			mov	edx,esp
 0000037F  B9 00000004			mov	ecx,4
 00000384  B4 3F			mov	ah,3fh
 00000386  CD 21			int	21h		;Fetch LE offset.
 00000388  5D				pop	ebp
 00000389  72 41			jc	@@LEReset
 0000038B  66| 3B C1			cmp	ax,cx
 0000038E  75 3C			jnz	@@LEReset
 00000390  0B ED			or	ebp,ebp		;We get anything?
 00000392  74 38			jz	@@LEReset
 00000394  66| 8B D5			mov	dx,bp
 00000397  C1 ED 10			shr	ebp,16
 0000039A  66| 8B CD			mov	cx,bp
 0000039D  66| B8 4200			mov	ax,4200h
 000003A1  CD 21			int	21h		;Move to LE section.
 000003A3  52				push	edx
 000003A4  8B D4			mov	edx,esp
 000003A6  B9 00000002			mov	ecx,2
 000003AB  B4 3F			mov	ah,3fh
 000003AD  CD 21			int	21h
 000003AF  5A				pop	edx
 000003B0  72 1A			jc	@@LEReset
 000003B2  66| 3B C1			cmp	ax,cx
 000003B5  75 15			jnz	@@LEReset
 000003B7  66| 81 FA 454C		cmp	dx,"EL"		;LE?
 000003BC  75 0E			jnz	@@LEReset
				
 000003BE  B4 3E			mov	ah,3eh
 000003C0  CD 21			int	21h		;close .EXE file.
					;
 000003C2  E8 000004D0			call	LEProcess		;convert LE file.
 000003C7  E9 00000158			jmp	System
					;
 000003CC			@@LEReset:	;Reset to start of file again.
					;
 000003CC  66| 33 D2			xor	dx,dx
 000003CF  66| 33 C9			xor	cx,cx
 000003D2  66| B8 4200			mov	ax,4200h
 000003D6  CD 21			int	21h
					;
					;See if EXE is already 3P.
					;
				if 0 ; exehdr was already read
				else
 000003D8  66| 81 3D			cmp exehdr.Signature,'P3'   ;is .EXE a plain 3P file without MZ header?
	   00000B2B R
	   5033
 000003E1  75 43			jnz @@DoExe
					@dprintf 1,<"Entry: file in 3P format, displaying info",10>
 000003E3  E8 FFFFFC7A	     1		call dprintf
 000003E8  45 6E 74 72 79    1		db "Entry: file in 3P format, displaying info",10,0
	   3A 20 66 69 6C
	   65 20 69 6E 20
	   33 50 20 66 6F
	   72 6D 61 74 2C
	   20 64 69 73 70
	   6C 61 79 69 6E
	   67 20 69 6E 66
	   6F 0A 00
 00000413  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 0000041C  E8 00001328			call NewExeInfo
 00000421  E9 000000FE			jmp	System
				endif
					;
 00000426			@@DoEXE:
 00000426  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 0000042C  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 00000434  74 02			je	medexe2		; not rounded if no modulo
				
 00000436  66| 48			dec	ax		;lose 1 cos its rounded up
				
 00000438			medexe2:
 00000438  0F B7 C0			movzx eax, ax
 0000043B  69 C0 00000200		imul eax, 200h
 00000441  0F B7 15			movzx edx,exehdr._Length	;add length mod 512
	   00000B2D R
 00000448  03 C2			add eax, edx
 0000044A  50				push eax
 0000044B  66| 5A			pop dx
 0000044D  66| 59			pop cx
 0000044F  66| B8 4200			mov	ax,4200h
 00000453  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 0000045A  CD 21			int	21h
					;
 0000045C  BA 00000B2B R		mov	edx,offset exehdr
 00000461  B9 00000002			mov	ecx,2
 00000466  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 0000046D  B4 3F			mov	ah,3fh
 0000046F  CD 21			int	21h		;read the .EXE header.
 00000471  72 23			jc	@@Reset
 00000473  66| C7 05			mov	ErrorNumber,ERR_HDRFMT	;stub file error.
	   00000004 R
	   0007
 0000047C  66| 83 F8 02			cmp	ax,2
 00000480  75 14			jnz	@@Reset
 00000482  66| C7 05			mov	ErrorNumber,ERR_ALREADY3P
	   00000004 R
	   001A
 0000048B  66| 81 3D			cmp	exehdr.Signature,'P3'	;Correct ID '3P'?
	   00000B2B R
	   5033
 00000494  74 1D			jz	@@Info
					;
 00000496			@@Reset:
 00000496  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 0000049D  B4 3E			mov	ah,3eh
 0000049F  CD 21			int	21h
 000004A1  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
					;
					;Now do some real processing.
					;
 000004AA  E8 0000125E			call	ExeAndMap2NewExe
 000004AF  75 73			jnz	System
 000004B1  EB 30			jmp	@@InfoDump
					;
 000004B3  80 3D 000039CC R	@@Info:	cmp	OptionTable+"P",0	;Post-mortem?
	   00
 000004BA  74 07			jz	@@update
 000004BC  E8 000000C6			call	PostMortem
 000004C1  EB 20			jmp	@@InfoDump
					;
 000004C3			@@update:
 000004C3  80 3D 000039D1 R		cmp	OptionTable+'U',0	;Update?
	   00
 000004CA  74 07			jz	@@fastload
 000004CC  E8 00000E0C			call	NewCauseWay
 000004D1  EB 10			jmp	@@InfoDump
				
 000004D3			@@fastload:
 000004D3  80 3D 000039C2 R		cmp	OptionTable+"F",0	;fast load?
	   00
 000004DA  74 07			jz	@@DualMode
 000004DC  E8 000000A7			call	FastLoad3P
 000004E1  EB 00			jmp	@@InfoDump
				
 000004E3			@@DualMode:
				;	cmp	OptionTable+'D',0	; dual mode?
				;	jz	@@InfoDump
				;	call	EXEDualMode
				
 000004E3			@@InfoDump:
 000004E3  80 3D 000039C5 R		cmp	OptionTable+'I',0	;Info?
	   00
 000004EA  74 38			jz	System
 000004EC  66| FF 35			push	ErrorNumber
	   00000004 R
 000004F3  E8 00001251			call	NewExeInfo
 000004F8  66| 83 3D			cmp	ErrorNumber,0
	   00000004 R 00
 00000500  75 22			jnz	System
 00000502  66| 8F 05			pop	ErrorNumber
	   00000004 R
 00000509  66| 83 3D			cmp	ErrorNumber,26
	   00000004 R 1A
 00000511  75 11			jnz	System
 00000513  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 0000051C  EB 06			jmp	System
				
					;
 0000051E  66| B8 4C00		@@9:	mov	ax,4c00h
 00000522  CD 21			int	21h
 00000524			Entry	endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00000524			System	proc	near
					;
					;Make sure temp file is deleted.
					;
 00000524  BA 00000B08 R		mov	edx,offset TempFileName	;get file name.
 00000529  B4 41			mov	ah,41h
 0000052B  CD 21			int	21h
					;
 0000052D  66| 83 3D			cmp	ErrorNumber,0
	   00000004 R 00
 00000535  74 16			jz	@@NoError
 00000537  66| 83 3D			cmp	ErrorNumber,3
	   00000004 R 03
 0000053F  74 0C			jz	@@NoError
 00000541  BA 000009EE R		mov	edx,offset ErrorText
 00000546  E8 00002CF5			call	StringPRint
 0000054B  EB 0A			jmp	@@DoneError
 0000054D			@@NoError:	;
 0000054D  BA 00000ADE R		mov	edx,offset CarriageReturn
 00000552  E8 00002CE9			call	StringPrint
 00000557			@@DoneError:	;
 00000557  66| 83 3D			cmp	ErrorNumber,26
	   00000004 R 1A
 0000055F  75 0A			jnz	@@NoName
 00000561  BA 00000100 R		mov	edx,offset EXEFileName
 00000566  E8 00002CD5			call	StringPrint
 0000056B			@@NoName:
 0000056B  0F B7 1D			movzx	ebx,ErrorNumber
	   00000004 R
 00000572  C1 E3 02			shl	ebx,2
 00000575  81 C3 00000006 R		add	ebx,offset ErrorMessages	;get error message.
 0000057B  8B 13			mov	edx,[ebx]
 0000057D  B4 09			mov	ah,9
 0000057F  CD 21			int	21h		;print it.
					;
 00000581  66| B8 4C00			mov	ax,4c00h
 00000585  CD 21			int	21h
 00000587			System	endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				;Add post-mortem dump code and SYM file to 3P EXE.
				;
 00000587			PostMortem	proc	near
 00000587  C3				ret
 00000588			PostMortem	endp
				
				
				COMMENT !
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				;Set the EXE dual mode flag
				;
				EXEDualMode	proc	near
					;Open the source EXE
					;
					mov	bx,EXEHandle
					call	CloseFile
					mov	edx,offset EXEFileName
					call	OpenFile		;Open the .EXE file.
					mov	ErrorNumber,6	;default to not found.
					jc	@@9
					mov	EXEHandle,ax
					;
					mov	edx,offset exehdr
					mov	ecx,sizeof MZHdr
					mov	bx,EXEHandle
					mov	ah,3fh
					int	21h		;read the .EXE header.
					mov	ErrorNumber,8	;default to IO error.
					jc	@@9
					mov	ErrorNumber,9	;stub file error.
					cmp	ax,sizeof MZHdr
					jnz	@@9
					cmp	exehdr.Signature,'ZM'	;Correct ID?
					jnz	@@9
					;
					mov	ax,exehdr._Length+2	;get length in 512 byte blocks
					cmp	exehdr._Length,0
					je	medexe10	; not rounded if no modulo
				
					dec	ax		;lose 1 cos its rounded up
				
				medexe10:
					add	ax,ax		;mult by 2
					mov	dh,0
					mov	dl,ah
					mov	ah,al
					mov	al,dh		;mult by 256=*512
					add	ax,exehdr._Length	;add length mod 512
					adc	dx,0		;add any carry to dx
					mov	cx,ax
					xchg	cx,dx
					shl	ecx,16
					mov	cx,dx
					movzx	ebx,EXEHandle
					xor	al,al
					call	LESetFilePointer	;point to 3P bit of the file.
					mov	P3Offset,ecx
					;
					;Read the 3P header.
					;
					mov	edx,offset RealHeader
					mov	ecx,size NewHeaderStruc
					movzx	ebx,EXEHandle
					call	LEReadFile
					jc	@@9
					cmp	eax,ecx
					jnz	@@9
					;
					call	SetSystemConfig	; update with new info
					;put the pointer back to the header.
					;
					mov	ecx,P3Offset
					xor	al,al
					call	LESetFilePointer
					;
					;Update the header
					;
					mov	edx,offset RealHeader
					mov	ecx,size NewHeaderStruc
					movzx	ebx,EXEHandle
					call	LEWriteFile
					jc	@@9
					cmp	eax,ecx
					jnz	@@9
				
				@@8:
					movzx	ebx,EXEHandle
					call	LECloseFile
				
					mov	ErrorNumber,0
					clc
				
				@@9:
					ret
				
				EXEDualMode	ENDP
				END COMMENT !
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				;Sort 3P file fixups into order and set fast load flag.
				;
 00000588			FastLoad3P	proc	near
					local @@SymbolCount:dword, @@iValue:dword, @@vValue:dword
					;
					;Open the source EXE
					;
 0000058E  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00000595  E8 00002B6B			call	CloseFile
 0000059A  BA 00000100 R		mov	edx,offset EXEFileName
 0000059F  E8 00002A77			call	OpenFile		;Open the .EXE file.
 000005A4  66| C7 05			mov	ErrorNumber,6	;default to not found.
	   00000004 R
	   0006
 000005AD  0F 82 000002E2		jc	@@9
 000005B3  66| A3			mov	EXEHandle,ax
	   00000B00 R
					;
 000005B9  BA 00000B2B R		mov	edx,offset exehdr
 000005BE  B9 0000001B			mov	ecx,sizeof MZHdr
 000005C3  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 000005CA  B4 3F			mov	ah,3fh
 000005CC  CD 21			int	21h		;read the .EXE header.
 000005CE  66| C7 05			mov	ErrorNumber,8	;default to IO error.
	   00000004 R
	   0008
 000005D7  0F 82 000002B8		jc	@@9
 000005DD  66| C7 05			mov	ErrorNumber,9	;stub file error.
	   00000004 R
	   0009
 000005E6  66| 83 F8 1B			cmp	ax,sizeof MZHdr
 000005EA  0F 85 000002A5		jnz	@@9
 000005F0  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Correct ID?
	   00000B2B R
	   5A4D
 000005F9  0F 85 00000296		jnz	@@9
					;
 000005FF  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 00000605  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 0000060D  74 02			je	medexe3		; not rounded if no modulo
				
 0000060F  66| 48			dec	ax		;lose 1 cos its rounded up
				
 00000611			medexe3:
 00000611  66| 03 C0			add	ax,ax		;mult by 2
 00000614  B6 00			mov	dh,0
 00000616  8A D4			mov	dl,ah
 00000618  8A E0			mov	ah,al
 0000061A  8A C6			mov	al,dh		;mult by 256=*512
 0000061C  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 00000623  66| 83 D2 00			adc	dx,0		;add any carry to dx
 00000627  66| 8B C8			mov	cx,ax
 0000062A  66| 87 CA			xchg	cx,dx
 0000062D  C1 E1 10			shl	ecx,16
 00000630  66| 8B CA			mov	cx,dx
 00000633  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 0000063A  32 C0			xor	al,al
 0000063C  E8 00000C5B			call	LESetFilePointer	;point to 3P bit of the file.
 00000641  89 0D 00003976 R		mov	P3Offset,ecx
					;
					;Read the 3P header.
					;
 00000647  BA 00003926 R		mov	edx,offset RealHeader
 0000064C  B9 00000040			mov	ecx,size NewHeaderStruc
 00000651  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 00000658  E8 00000C0A			call	LEReadFile
 0000065D  0F 82 00000232		jc	@@9
 00000663  3B C1			cmp	eax,ecx
 00000665  0F 85 0000022A		jnz	@@9
					;
					;Check it is a 3P section.
					;
 0000066B  66| 81 3D			cmp	w[RealHeader.NewID],"P3"
	   00003926 R
	   5033
 00000674  0F 85 0000021B		jnz	@@9
					;
					;Get some memory for the relocation table.
					;
 0000067A  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 00000680  83 F9 02			cmp	ecx,1+1
 00000683  0F 82 000001F6		jc	@@8
 00000689  C1 E1 02			shl	ecx,2
 0000068C  E8 00000BC6			call	LEMalloc
 00000691  0F 82 000001FE		jc	@@9
 00000697  89 35 0000396E R		mov	RelocMem,esi
 0000069D  E8 00000BB5			call	LEMalloc
 000006A2  0F 82 000001ED		jc	@@9
 000006A8  89 35 00003972 R		mov	RelocMem+4,esi
					;
					;Move to the relocations.
					;
 000006AE  0F B7 0D			movzx	ecx,[RealHeader.NewSegments]
	   00003934 R
 000006B5  C1 E1 03			shl	ecx,3
 000006B8  B0 01			mov	al,1
 000006BA  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 000006C1  E8 00000BD6			call	LESetFilePointer
					;
					;Read the relocations.
					;
 000006C6  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 000006CC  C1 E1 02			shl	ecx,2
 000006CF  8B 15 0000396E R		mov	edx,RelocMem
 000006D5  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 000006DC  E8 00000B86			call	LEReadFile
 000006E1  0F 82 000001AE		jc	@@9
 000006E7  3B C1			cmp	eax,ecx
 000006E9  0F 85 000001A6		jnz	@@9
				
					;
					;Make the table.
					;
 000006EF  8B 3D 00003972 R		mov	edi,RelocMem+4
 000006F5  A1 0000396E R		mov	eax,RelocMem
 000006FA  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 00000700  1E				push	ds
 00000701  07				pop	es
 00000702  FC				cld
 00000703			@@00:
 00000703  AB				stosd
 00000704  83 C0 04			add	eax,4
 00000707  49				dec	ecx
 00000708  75 F9			jnz	@@00
				
				
				;
				;Thingy sort the relocation pointers.
				;
 0000070A  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 00000710  89 4D FC			mov	@@SymbolCount,ecx
					;
					;Now do the sort.
					;
 00000713  8B 45 FC			mov	eax,@@SymbolCount
 00000716  83 F8 01			cmp	eax,1
 00000719  0F 86 000000CD		jbe	@@sortend		; sorted by definition
 0000071F  33 DB			xor	ebx,ebx
 00000721  8B D3			mov	edx,ebx
 00000723  B3 09			mov	bl,9
 00000725  F7 F3			div	ebx
 00000727  8B C8			mov	ecx,eax		; ecx == quotient, N/9
				;
				; for (h=1;h<=N/9;h=3*h+1);
				;
 00000729  8B C3			mov	eax,ebx		; eax==9
 0000072B  B0 01			mov	al,1		; eax==1, h
 0000072D  B3 03			mov	bl,3		; ebx==3
 0000072F  33 D2			xor	edx,edx		; zero for multiply loop
 00000731			@@sethloop:	;
 00000731  3B C1			cmp	eax,ecx		; h<=N/9
 00000733  77 05			ja	@@sort2
 00000735  F7 E3			mul	ebx		; 3*h, assume 32-bit result (pretty safe bet)
 00000737  40				inc	eax		; 3*h+1
 00000738  EB F7			jmp	@@sethloop
				;
				; ebx will play role of j, edx will play role of h
				;
 0000073A  8B D0		@@sort2:	mov	edx,eax		; edx == h
				;
				; for (;h>0;...
				;
 0000073C			@@hloop:
 0000073C  0B D2			or	edx,edx		; h>0
 0000073E  0F 84 000000A8		je	@@sortend
				;
				; for(i=h+1...
				;
 00000744  8B C2			mov	eax,edx
 00000746  40				inc	eax
 00000747  89 45 F8			mov	@@iValue,eax
				;
				; for(...;i<=N;...){
				;
 0000074A  8B 45 F8		@@iloop:	mov	eax,@@iValue
 0000074D  3B 45 FC			cmp	eax,@@SymbolCount
 00000750  0F 87 00000085		ja	@@nexth
					;
 00000756  8B 0D 00003972 R		mov	ecx,RelocMem+4
 0000075C  8B 4C 81 FC			mov	ecx,[ecx-4+eax*4]
 00000760  89 4D F4			mov	@@vValue,ecx		; v=a[i]
 00000763  8B D8			mov	ebx,eax		; j=i
				;
				; while(j>h && a[j-h]>v){
				;
 00000765			@@whileloop:
 00000765  3B DA			cmp	ebx,edx		; j>h
 00000767  76 55			jbe	@@whilefail
					;
 00000769  8B C3			mov	eax,ebx
 0000076B  2B C2			sub	eax,edx		; eax==j-h
 0000076D  8B 35 00003972 R		mov	esi,RelocMem+4
 00000773  8B 74 86 FC			mov	esi,[esi-4+eax*4]	; esi==a[j-h]
 00000777  8B 7D F4			mov	edi,@@vValue		; edi==v
 0000077A  33 C9			xor	ecx,ecx		; zero high bytes of register for following repe
				;
				; a[j-h] > v
				;
					pushm	esi,edi
 0000077C  56		     2		PUSH	esi			;SAVE THE REGISTER
 0000077D  57		     2		PUSH	edi			;SAVE THE REGISTER
 0000077E  8B 36			mov	esi,[esi]
 00000780  8B 3F			mov	edi,[edi]
 00000782  81 E6 0FFFFFFF		and	esi,0FFFFFFFh
 00000788  81 E7 0FFFFFFF		and	edi,0FFFFFFFh
 0000078E  3B F7			cmp	esi,edi
					popm	esi,edi
 00000790  5F		     2		POP	edi				;POP THE REGISTER
 00000791  5E		     2		POP	esi				;POP THE REGISTER
 00000792  76 2A			jbe	@@whilefail		; first < second, a[j-h]<v
				
 00000794			@@dochange:	;
 00000794  8B C3			mov	eax,ebx
 00000796  2B C2			sub	eax,edx		; eax==j-h
 00000798  8D 04 85			lea	eax,[eax*4]
	   00000000
 0000079F  03 05 00003972 R		add	eax,RelocMem+4
 000007A5  8B 40 FC			mov	eax,[eax-4]		; eax==a[j-h]
 000007A8  53				push	ebx
 000007A9  8D 1C 9D			lea	ebx,[ebx*4]
	   00000000
 000007B0  03 1D 00003972 R		add	ebx,RelocMem+4
 000007B6  89 43 FC			mov	[ebx-4],eax		; a[j]=a[j-h]
 000007B9  5B				pop	ebx
 000007BA  2B DA			sub	ebx,edx		; j-=h
 000007BC  EB A7			jmp	@@whileloop
 000007BE			@@whilefail:	;
 000007BE  8B 45 F4			mov	eax,@@vValue
 000007C1  53				push	ebx
 000007C2  8D 1C 9D			lea	ebx,[ebx*4]
	   00000000
 000007C9  03 1D 00003972 R		add	ebx,RelocMem+4
 000007CF  89 43 FC			mov	[ebx-4],eax		; a[j]=v
 000007D2  5B				pop	ebx
				;
				; for(...;i++){
				;
 000007D3  FF 45 F8			inc	@@iValue
 000007D6  E9 FFFFFF6F			jmp	@@iloop
				;
				; for (...;h/=3){
				;
 000007DB  8B C2		@@nexth:	mov	eax,edx
 000007DD  33 D2			xor	edx,edx
 000007DF  8B CA			mov	ecx,edx
 000007E1  B1 03			mov	cl,3
 000007E3  F7 F1			div	ecx
 000007E5  8B D0			mov	edx,eax
 000007E7  E9 FFFFFF50			jmp	@@hloop
 000007EC			@@sortend:	;
				
				
				;
				;Use list to order output.
				;
 000007EC  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 000007F2  8B 3D 00003972 R		mov	edi,RelocMem+4
 000007F8			@@01:
 000007F8  8B 37			mov	esi,[edi]
 000007FA  A5				movsd
 000007FB  49				dec	ecx
 000007FC  75 FA			jnz	@@01
				
				;
				;Copy second table back to first.
				;
 000007FE  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 00000804  8B 35 00003972 R		mov	esi,RelocMem+4
 0000080A  8B 3D 0000396E R		mov	edi,RelocMem
 00000810  F3/ A5			rep	movsd
				
				
				;
				;Set speed load flag in the header.
				;
 00000812  81 0D 00003946 R		or	d[RealHeader.NewFlags],1 shl 30
	   40000000
				
					;
					;Put the pointer back to start of relocations.
					;
 0000081C  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 00000822  C1 E1 02			shl	ecx,2
 00000825  F7 D9			neg	ecx
 00000827  B0 01			mov	al,1
 00000829  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 00000830  E8 00000A67			call	LESetFilePointer
					;
					;Write new relocations.
					;
 00000835  8B 0D 00003936 R		mov	ecx,d[RealHeader.NewRelocs]
 0000083B  C1 E1 02			shl	ecx,2
 0000083E  8B 15 0000396E R		mov	edx,RelocMem
 00000844  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 0000084B  E8 000009B7			call	LEWriteFile
 00000850  72 43			jc	@@9
 00000852  3B C1			cmp	eax,ecx
 00000854  75 3F			jnz	@@9
				
					;
					;put the pointer back to the header.
					;
 00000856  8B 0D 00003976 R		mov	ecx,P3Offset
 0000085C  32 C0			xor	al,al
 0000085E  E8 00000A39			call	LESetFilePointer
					;
					;Update the header
					;
 00000863  BA 00003926 R		mov	edx,offset RealHeader
 00000868  B9 00000040			mov	ecx,size NewHeaderStruc
 0000086D  0F B7 1D			movzx	ebx,EXEHandle
	   00000B00 R
 00000874  E8 0000098E			call	LEWriteFile
 00000879  72 1A			jc	@@9
 0000087B  3B C1			cmp	eax,ecx
 0000087D  75 16			jnz	@@9
				
				
 0000087F  0F B7 1D		@@8:	movzx	ebx,EXEHandle
	   00000B00 R
 00000886  E8 000009C5			call	LECloseFile
				
 0000088B  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 00000894  F8				clc
				
				
 00000895			@@9:	ret
 00000897			FastLoad3P	endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				;Convert an LE format file into 3P format.
				;
 00000897			LEProcess	proc	near
 00000897  E8 00000872			call	FetchLEFile		;Read the LE file.
 0000089C  72 26			jc	@@9
 0000089E  E8 000006D9			call	Create3PFile		;Create the 3P image.
 000008A3  72 1F			jc	@@9
 000008A5  E8 000002E5			call	CreateRelocations	;Build relocation list.
 000008AA  72 18			jc	@@9
 000008AC  E8 0000025A			call	Create3PHeader	;Build the header.
 000008B1  72 11			jc	@@9
 000008B3  E8 0000000D			call	Write3PFile		;Now write the 3P file.
 000008B8  72 0A			jc	@@9
 000008BA  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 000008C3  F8				clc
 000008C4  C3			@@9:	ret
 000008C5			LEProcess	endp
				
				
				;------------------------------------------------------------------------------
				;
				;Write the file at last.
				;
 000008C5			Write3PFile	proc	near
 000008C5  BE 000038EA R		mov	esi,offset Write3PText
 000008CA  E8 000009FA			call	LEPrintString
					;
					;Load the extender stub CWSTUB.EXE
					;
 000008CF  BA 00000080 R		mov	edx,offset SHELLFileName	; get extender stub CWSTUB.EXE
					@dprintf 1,<"Write3PFile: open stub %s",10>,edx
 000008D4  52		     2		push edx
 000008D5  E8 FFFFF788	     1		call dprintf
 000008DA  57 72 69 74 65    1		db "Write3PFile: open stub %s",10,0
	   33 50 46 69 6C
	   65 3A 20 6F 70
	   65 6E 20 73 74
	   75 62 20 25 73
	   0A 00
 000008F5  E8 000009BA			call	LEOpenFile
 000008FA  66| C7 05			mov	ErrorNumber,42              ;open error
	   00000004 R
	   002A
 00000903  0F 82 00000200		jc	@@9
 00000909  BA 00000B2B R		mov	edx,offset exehdr
 0000090E  B9 0000001B			mov	ecx,sizeof MZHdr
					@dprintf 1,<"Write3PFile: read header",10>
 00000913  E8 FFFFF74A	     1		call dprintf
 00000918  57 72 69 74 65    1		db "Write3PFile: read header",10,0
	   33 50 46 69 6C
	   65 3A 20 72 65
	   61 64 20 68 65
	   61 64 65 72 0A
	   00
 00000932  E8 00000930			call	LEReadFile
 00000937  0F 82 000001CC		jc	@@9
 0000093D  3B C1			cmp	eax,ecx
 0000093F  0F 85 000001C4		jnz	@@9
 00000945  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 0000094B  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 00000953  74 02			je	medexe4		; not rounded if no modulo
				
 00000955  66| 48			dec	ax		;lose 1 cos its rounded up
				
 00000957			medexe4:
 00000957  66| 03 C0			add	ax,ax		;mult by 2
 0000095A  B6 00			mov	dh,0
 0000095C  8A D4			mov	dl,ah
 0000095E  8A E0			mov	ah,al
 00000960  8A C6			mov	al,dh		;mult by 256=*512
 00000962  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 00000969  66| 83 D2 00			adc	dx,0		;add any carry to dx
 0000096D  66| 8B C8			mov	cx,ax
 00000970  66| 87 CA			xchg	cx,dx
 00000973  C1 E1 10			shl	ecx,16
 00000976  66| 8B CA			mov	cx,dx
 00000979  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00000982  83 C1 04			add	ecx,4
 00000985  E8 000008CD			call	LEMalloc
 0000098A  0F 82 00000179		jc	@@9
 00000990  83 E9 04			sub	ecx,4
 00000993  89 35 00003966 R		mov	StubMem,esi
 00000999  89 0E			mov	d[esi],ecx
 0000099B  83 C6 04			add	esi,4
					pushm	ecx,esi
 0000099E  51		     2		PUSH	ecx			;SAVE THE REGISTER
 0000099F  56		     2		PUSH	esi			;SAVE THE REGISTER
 000009A0  33 C9			xor	ecx,ecx
 000009A2  32 C0			xor	al,al
 000009A4  E8 000008F3			call	LESetFilePointer
					popm	ecx,esi
 000009A9  5E		     2		POP	esi				;POP THE REGISTER
 000009AA  59		     2		POP	ecx				;POP THE REGISTER
 000009AB  66| C7 05			mov	ErrorNumber,42
	   00000004 R
	   002A
 000009B4  8B D6			mov	edx,esi
 000009B6  E8 000008AC			call	LEReadFile
 000009BB  0F 82 00000148		jc	@@9
 000009C1  3B C1			cmp	eax,ecx
 000009C3  0F 85 00000140		jnz	@@9
					;
					;Create the output file.
					;
 000009C9  BA 00000B08 R		mov	edx,offset TEMPFileName
					@dprintf 1,<"Write3PFile: create temp file %s",10>,edx
 000009CE  52		     2		push edx
 000009CF  E8 FFFFF68E	     1		call dprintf
 000009D4  57 72 69 74 65    1		db "Write3PFile: create temp file %s",10,0
	   33 50 46 69 6C
	   65 3A 20 63 72
	   65 61 74 65 20
	   74 65 6D 70 20
	   66 69 6C 65 20
	   25 73 0A 00
 000009F6  E8 000007F4			call	LECreateFile
 000009FB  66| C7 05			mov	ErrorNumber,37
	   00000004 R
	   0025
 00000A04  0F 82 000000FF		jc	@@9
					;
					;Write the stub.
					;
 00000A0A  66| C7 05			mov	ErrorNumber,38
	   00000004 R
	   0026
 00000A13  8B 15 00003966 R		mov	edx,StubMem
 00000A19  8B 0A			mov	ecx,[edx]
 00000A1B  83 C2 04			add	edx,4
 00000A1E  E8 000007E4			call	LEWriteFile
 00000A23  0F 82 000000E0		jc	@@9
 00000A29  3B C1			cmp	eax,ecx
 00000A2B  0F 85 000000D8		jnz	@@9
					;
					;Write the main header.
					;
 00000A31  BA 00003926 R		mov	edx,offset RealHeader
 00000A36  B9 00000040			mov	ecx,size NewHeaderStruc
 00000A3B  E8 000007C7			call	LEWriteFile
 00000A40  66| C7 05			mov	ErrorNumber,38
	   00000004 R
	   0026
 00000A49  0F 82 000000BA		jc	@@9
 00000A4F  3B C1			cmp	eax,ecx
 00000A51  0F 85 000000B2		jnz	@@9
					;
					;Write the segment definitions.
					;
 00000A57  8B 35 00003912 R		mov	esi,ObjectList	;Point to the segment list.
 00000A5D  8B 2E			mov	ebp,[esi]		;Get number of entries.
 00000A5F  83 C6 04			add	esi,4
 00000A62			@@0:
 00000A62  8B D6			mov	edx,esi		;Point to segment defintion.
 00000A64  B9 00000008			mov	ecx,4+4
 00000A69  E8 00000799			call	LEWriteFile		;Write this entry.
 00000A6E  66| C7 05			mov	ErrorNumber,38
	   00000004 R
	   0026
 00000A77  0F 82 0000008C		jc	@@9
 00000A7D  3B C1			cmp	eax,ecx
 00000A7F  0F 85 00000084		jnz	@@9
 00000A85  83 C6 10			add	esi,size _Seg_	;Next entry.
 00000A88  4D				dec	ebp
 00000A89  75 D7			jnz	@@0		;Do all segments.
					;
					;Write the relocation entries.
					;
 00000A8B  8B 35 00003916 R		mov	esi,RelocationList
 00000A91  0B F6			or	esi,esi
 00000A93  74 1E			jz	@@1
 00000A95  8B 0E			mov	ecx,[esi]		;Get number of entries.
 00000A97  C1 E1 02			shl	ecx,2		;Dword per entry.
 00000A9A  83 C6 04			add	esi,4
 00000A9D  8B D6			mov	edx,esi		;Point to data.
 00000A9F  E8 00000763			call	LEWriteFile
 00000AA4  66| C7 05			mov	ErrorNumber,38
	   00000004 R
	   0026
 00000AAD  72 5A			jc	@@9
 00000AAF  3B C1			cmp	eax,ecx
 00000AB1  75 56			jnz	@@9
					;
 00000AB3			@@1:	;Write the EXE image.
					;
 00000AB3  8B 35 00003912 R		mov	esi,ObjectList	;Point to object definitions.
 00000AB9  8B 2E			mov	ebp,[esi]		;Get number of entries.
 00000ABB  83 C6 04			add	esi,4		;Point to real data.
 00000ABE			@@2:
 00000ABE  8B 4E 08			mov	ecx,_Seg_.Seg_Length[esi]	;Get segments length.
 00000AC1  8B 56 0C			mov	edx,[esi]._Seg_.Seg_Memory	;point to segments image.
 00000AC4  E8 0000073E			call	LEWriteFile
 00000AC9  66| C7 05			mov	ErrorNumber,38
	   00000004 R
	   0026
 00000AD2  72 35			jc	@@9
 00000AD4  3B C1			cmp	eax,ecx
 00000AD6  75 31			jnz	@@9
 00000AD8  83 C6 10			add	esi,size _Seg_	;point to next entry.
 00000ADB  4D				dec	ebp
 00000ADC  75 E0			jnz	@@2		;Do all entries.
					;
					;Close the output file.
					;
 00000ADE  E8 0000076D			call	LECloseFile
					;
					;Delete origional .EXE
					;
 00000AE3  BA 00000100 R		mov	edx,offset EXEFileName	;get file name mask.
 00000AE8  B4 41			mov	ah,41h
 00000AEA  CD 21			int	21h
 00000AEC  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00000AF5  72 12			jc	@@9
					;
					;now rename it.
					;
 00000AF7  BA 00000B08 R		mov	edx,offset TempFileName
 00000AFC  BF 00000100 R		mov	edi,offset EXEFileName		;get file name mask.
 00000B01  B4 56			mov	ah,56h
 00000B03  CD 21			int	21h
 00000B05  72 02			jc	@@9
					;
 00000B07  F8				clc
 00000B08  C3				ret
					;
 00000B09  F9			@@9:	stc
 00000B0A  C3				ret
 00000B0B			Write3PFile	endp
				
				
				;------------------------------------------------------------------------------
				;
				;Create 3P header data.
				;
 00000B0B			Create3PHeader	proc	near
 00000B0B  BE 000038CD R		mov	esi,offset BuildHeaderText
 00000B10  E8 000007B4			call	LEPrintString
					;
 00000B15  BF 00003926 R		mov	edi,offset RealHeader
					;
					;Set auto DS object number if there is one.
					;
 00000B1A  8B 35 000038FE R		mov	esi,LEAddress
 00000B20  8B 86 00000094		mov	eax,[esi+94h]
 00000B26  66| 89 47 28			mov	[edi].NewHeaderStruc.NewAutoDS,ax
					;
					;Set number of segments and increase file length field.
					;
 00000B2A  8B 35 00003912 R		mov	esi,ObjectList
 00000B30  8B 06			mov	eax,[esi]		;Get number of segments.
 00000B32  66| 89 47 0E			mov	[edi].NewHeaderStruc.NewSegments,ax
 00000B36  C1 E0 03			shl	eax,3		;8 bytes per seg.
 00000B39  89 47 02			mov	[edi].NewHeaderStruc.NewSize,eax
					;
					;Set number of relocations and increase file length field.
					;
 00000B3C  8B 35 00003916 R		mov	esi,RelocationList
 00000B42  33 C0			xor	eax,eax
 00000B44  0B F6			or	esi,esi
 00000B46  74 02			jz	@@0
 00000B48  8B 06			mov	eax,[esi]
 00000B4A			@@0:
 00000B4A  89 47 10			mov	[edi].NewHeaderStruc.NewRelocs,eax
 00000B4D  C1 E0 02			shl	eax,2		;4 bytes per entry.
 00000B50  01 47 02			add	[edi].NewHeaderStruc.NewSize,eax
					;
					;Set EXE image length and increase file length field.
					;
 00000B53  A1 0000391A R		mov	eax,SegmentBase	;This is now total length.
 00000B58  89 47 06			mov	[edi].NewHeaderStruc.NewLength,eax
 00000B5B  89 47 0A			mov	[edi].NewHeaderStruc.NewAlloc,eax
 00000B5E  01 47 02			add	[edi].NewHeaderStruc.NewSize,eax
					;
					;Include header in length field.
					;
 00000B61  83 47 02 40			add	[edi].NewHeaderStruc.NewSize,size NewHeaderStruc
					;
					;Set entry CS:EIP
					;
 00000B65  8B 35 000038FE R		mov	esi,LEAddress
 00000B6B  8B 46 18			mov	eax,[esi+18h]	;CS object number.
 00000B6E  48				dec	eax
 00000B6F  66| 89 47 18			mov	[edi].NewHeaderStruc.NewEntryCS,ax
 00000B73  8B 46 1C			mov	eax,[esi+1Ch]	;EIP value.
 00000B76  89 47 14			mov	[edi].NewHeaderStruc.NewEntryEIP,eax
					;
					;Set entry SS:ESP
					;
 00000B79  8B 35 000038FE R		mov	esi,LEAddress
 00000B7F  8B 46 20			mov	eax,[esi+20h]	;SS object number.
 00000B82  48				dec	eax
 00000B83  66| 89 47 1E			mov	[edi].NewHeaderStruc.NewEntrySS,ax
 00000B87  8B 46 24			mov	eax,[esi+24h]	;ESP value.
 00000B8A  89 47 1A			mov	[edi].NewHeaderStruc.NewEntryESP,eax
					;
 00000B8D  F8				clc
 00000B8E  C3				ret
 00000B8F			Create3PHeader	endp
				
				
				;------------------------------------------------------------------------------
				;
				;Create a 3P format relocation table from the LE fixup tables.
				;
 00000B8F			CreateRelocations proc near
					@dprintf 1,<"CreateRelocations enter",10>
 00000B8F  E8 FFFFF4CE	     1		call dprintf
 00000B94  43 72 65 61 74    1		db "CreateRelocations enter",10,0
	   65 52 65 6C 6F
	   63 61 74 69 6F
	   6E 73 20 65 6E
	   74 65 72 0A 00
 00000BAD  BE 000038B0 R		mov	esi,offset BuildRelocsText
 00000BB2  E8 00000712			call	LEPrintString
					;
					;Setup a pointer to the object definitions.
					;
 00000BB7  C7 05 0000396A R		mov	RelocationCount,0
	   00000000
					;
 00000BC1  8B 35 000038FE R		mov	esi,LEAddress
 00000BC7  8B 4E 44			mov	ecx,[esi+44h]	;Get number of Objects.
 00000BCA  03 76 40			add	esi,[esi+40h]	;Point to object table.
 00000BCD  89 0D 0000390A R		mov	ObjectCount,ecx
 00000BD3  89 35 0000390E R		mov	ObjectBase,esi
 00000BD9  A1 00003912 R		mov	eax,ObjectList
 00000BDE  83 C0 04			add	eax,4
 00000BE1  A3 00000B17 R		mov	SegmentList,eax
					;
 00000BE6			@@0:
 00000BE6  8B 35 0000390E R		mov	esi,ObjectBase
 00000BEC  8B 4E 10			mov	ecx,[esi+10h]	;Get number of pages.
 00000BEF  89 0D 0000391E R		mov	PageCount,ecx
 00000BF5  C7 05 00003922 R		mov	PageCount+4,0
	   00000000
 00000BFF  8B 56 0C			mov	edx,[esi+0Ch]	;Get page table index.
 00000C02  4A				dec	edx
 00000C03  8B EA			mov	ebp,edx		;Set base page map entry.
 00000C05			@@1:	;
 00000C05  8B D5			mov	edx,ebp
 00000C07  8B 35 000038FE R		mov	esi,LEAddress
 00000C0D  03 76 68			add	esi,[esi+68h]	;Point to fixup page maps.
 00000C10  8B 4C 96 04			mov	ecx,[esi+4+edx*4]	;Get next offset.
 00000C14  8B 14 96			mov	edx,[esi+edx*4]	;Get start offset.
 00000C17  2B CA			sub	ecx,edx		;Get number of bytes
 00000C19  0F 84 000002DF		jz	@@4
					;
 00000C1F  8B 35 000038FE R		mov	esi,LEAddress
 00000C25  03 76 6C			add	esi,[esi+6Ch]	;Point to fixup data.
 00000C28  03 F2			add	esi,edx		;Move to start of this pages fixups.
					;
 00000C2A			@@2:
 00000C2A  8A 06			mov	al,[esi]		;Get type byte.
 00000C2C  8A D8			mov	bl,al
 00000C2E  C0 EB 04			shr	bl,4		;Get single/multiple flag.
 00000C31  8A F8			mov	bh,al
 00000C33  80 E7 0F			and	bh,15		;Get type.
 00000C36  46				inc	esi
 00000C37  49				dec	ecx
 00000C38  8A 06			mov	al,[esi]		;Get second type byte.
 00000C3A  8A D0			mov	dl,al
 00000C3C  80 E2 03			and	dl,3		;Get internal/external specifier.
 00000C3F  8A F0			mov	dh,al
 00000C41  C0 EE 02			shr	dh,2		;Get destination type.
 00000C44  46				inc	esi
 00000C45  49				dec	ecx
					;
 00000C46  66| C7 05			mov	ErrorNumber,39
	   00000004 R
	   0027
 00000C4F  0A DB			or	bl,bl		;Check it's a single entry.
 00000C51  0F 85 000002D6		jnz	@@9
					;
 00000C57  66| C7 05			mov	ErrorNumber,40
	   00000004 R
	   0028
 00000C60  0A D2			or	dl,dl		;Check it's an internal target.
 00000C62  0F 85 000002C5		jnz	@@9
					;
 00000C68  66| C7 05			mov	ErrorNumber,43
	   00000004 R
	   002B
 00000C71  F6 C6 3B			test	dh,111011b		;Check for un-known bits.
 00000C74  0F 85 000002B3		jnz	@@9
					;
 00000C7A  80 FF 02			cmp	bh,0010b		;Word segment?
 00000C7D  74 29			jz	@@Seg16
 00000C7F  80 FF 07			cmp	bh,0111b		;32-bit offset?
 00000C82  0F 84 0000008E		jz	@@32BitOff
 00000C88  80 FF 06			cmp	bh,0110b		;Seg:32-bit offset?
 00000C8B  0F 84 00000182		jz	@@Seg1632BitOff
 00000C91  80 FF 08			cmp	bh,1000b		;32-bit self relative?
 00000C94  0F 84 0000010D		jz	@@Self32Off
					;
 00000C9A  66| C7 05			mov	ErrorNumber,41
	   00000004 R
	   0029
 00000CA3  E9 00000285			jmp	@@9
					;
 00000CA8			@@Seg16:	;Deal with a 16-bit segment.
					;
					;EBP	- Page offset within segment.
					;w[esi] - offset within page.
					;b[esi+2] - target object+1.
					;
 00000CA8  66| C7 05			mov	ErrorNumber,43
	   00000004 R
	   002B
 00000CB1  F6 C6 04			test	dh,4
 00000CB4  0F 85 00000273		jnz	@@9
					;
 00000CBA  8B 3D 00000B17 R		mov	edi,SegmentList
 00000CC0  8B 7F 0C			mov	edi,[edi]._Seg_.Seg_Memory
 00000CC3  A1 00003922 R		mov	eax,PageCount+4	;Get page number.
 00000CC8  C1 E0 0C			shl	eax,12
 00000CCB  03 F8			add	edi,eax		;Point to the right page.
 00000CCD  0F BF 06			movsx	eax,w[esi]
 00000CD0  0B C0			or	eax,eax
 00000CD2  78 37			js	@@Neg0
 00000CD4  03 F8			add	edi,eax		;Point to the right offset.
 00000CD6  0F B6 46 02			movzx	eax,b[esi+2]		;Get the target segment.
 00000CDA  48				dec	eax
 00000CDB  66| 89 07			mov	[edi],ax		;Store target.
					;
 00000CDE  8B 3D 00000B17 R		mov	edi,SegmentList
 00000CE4  8B 3F			mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
 00000CE6  A1 00003922 R		mov	eax,PageCount+4	;Get page number within segment.
 00000CEB  C1 E0 0C			shl	eax,12
 00000CEE  03 F8			add	edi,eax		;Include page offset.
 00000CF0  0F B7 06			movzx	eax,w[esi]
 00000CF3  03 F8			add	edi,eax		;Include byte offset.
 00000CF5  8B C7			mov	eax,edi
 00000CF7  E8 00000233			call	AddRelocationEntry	;Add it to the list.
 00000CFC  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00000D05  0F 82 00000222		jc	@@9
					;
 00000D0B			@@Neg0:
 00000D0B  83 C6 03			add	esi,2+1
 00000D0E  83 E9 03			sub	ecx,2+1
 00000D11  E9 000001DA			jmp	@@3
					;
 00000D16			@@32BitOff:	;Deal with a 32-bit offset.
					;
					;EBP	- Page offset within segment.
					;w[esi] - offset within page.
					;b[esi+2] - target object+1
					;w[esi+3] - target offset.
					;
 00000D16  8B 3D 00000B17 R		mov	edi,SegmentList
 00000D1C  8B 7F 0C			mov	edi,[edi]._Seg_.Seg_Memory
 00000D1F  A1 00003922 R		mov	eax,PageCount+4	;Get page number.
 00000D24  C1 E0 0C			shl	eax,12
 00000D27  03 F8			add	edi,eax		;Point to the right page.
 00000D29  0F BF 06			movsx	eax,w[esi]
 00000D2C  0B C0			or	eax,eax
 00000D2E  78 5D			js	@@Neg1
 00000D30  03 F8			add	edi,eax		;Point to the right offset.
 00000D32  0F B6 46 02			movzx	eax,b[esi+2]		;Get the target segment.
 00000D36  48				dec	eax
 00000D37  52				push	edx
 00000D38  BA 00000010			mov	edx,size _Seg_
 00000D3D  F7 E2			mul	edx
 00000D3F  5A				pop	edx
 00000D40  83 C0 04			add	eax,4		;skip dword count.
 00000D43  03 05 00003912 R		add	eax,ObjectList	;point to target segment details.
 00000D49  8B 00			mov	eax,[eax]._Seg_.Seg_BaseAddress	;Get target segments offset from start of image.
 00000D4B  0F B7 5E 03			movzx	ebx,w[esi+3]		;Get target offset.
 00000D4F  F6 C6 04			test	dh,4
 00000D52  74 03			jz	@@Big0
 00000D54  8B 5E 03			mov	ebx,[esi+3]		;Get target offset.
 00000D57			@@Big0:
 00000D57  03 C3			add	eax,ebx
 00000D59  89 07			mov	[edi],eax
					;
 00000D5B  8B 3D 00000B17 R		mov	edi,SegmentList
 00000D61  8B 3F			mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
 00000D63  A1 00003922 R		mov	eax,PageCount+4	;Get page number within segment.
 00000D68  C1 E0 0C			shl	eax,12
 00000D6B  03 F8			add	edi,eax		;Include page offset.
 00000D6D  0F B7 06			movzx	eax,w[esi]
 00000D70  03 F8			add	edi,eax		;Include byte offset.
 00000D72  8B C7			mov	eax,edi
 00000D74  0D 10000000			or	eax,1 shl 28		;Mark it as a 32-bit offset.
 00000D79  E8 000001B1			call	AddRelocationEntry	;Add it to the list.
 00000D7E  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00000D87  0F 82 000001A0		jc	@@9
					;
 00000D8D  83 C6 05		@@Neg1:	add	esi,2+1+2
 00000D90  83 E9 05			sub	ecx,2+1+2
 00000D93  F6 C6 04			test	dh,4
 00000D96  0F 84 00000154		jz	@@3
 00000D9C  83 C6 02			add	esi,2
 00000D9F  83 E9 02			sub	ecx,2
 00000DA2  E9 00000149			jmp	@@3
				
					;
 00000DA7			@@Self32Off:	;Deal with a 32-bit self relative offset.
					;
					;EBP	- Page offset within segment.
					;w[esi] - offset within page.
					;b[esi+2] - target object+1
					;w[esi+3] - target offset.
					;
 00000DA7  8B 3D 00000B17 R		mov	edi,SegmentList
 00000DAD  8B 1F			mov	ebx,[edi]._Seg_.Seg_BaseAddress
 00000DAF  8B 7F 0C			mov	edi,[edi]._Seg_.Seg_Memory
 00000DB2  A1 00003922 R		mov	eax,PageCount+4	;Get page number.
 00000DB7  C1 E0 0C			shl	eax,12
 00000DBA  03 D8			add	ebx,eax
 00000DBC  03 F8			add	edi,eax		;Point to the right page.
 00000DBE  0F BF 06			movsx	eax,w[esi]
 00000DC1  0B C0			or	eax,eax
 00000DC3  78 34			js	@@sfNeg1
 00000DC5  03 D8			add	ebx,eax
 00000DC7  03 F8			add	edi,eax		;Point to the right offset.
 00000DC9  0F B6 46 02			movzx	eax,b[esi+2]		;Get the target segment.
 00000DCD  48				dec	eax
 00000DCE  52				push	edx
 00000DCF  BA 00000010			mov	edx,size _Seg_
 00000DD4  F7 E2			mul	edx
 00000DD6  5A				pop	edx
 00000DD7  83 C0 04			add	eax,4		;skip dword count.
 00000DDA  03 05 00003912 R		add	eax,ObjectList	;point to target segment details.
 00000DE0  8B 00			mov	eax,[eax]._Seg_.Seg_BaseAddress	;Get target segments offset from start of image.
 00000DE2  53				push	ebx
 00000DE3  0F B7 5E 03			movzx	ebx,w[esi+3]		;Get target offset.
 00000DE7  F6 C6 04			test	dh,4
 00000DEA  74 03			jz	@@sfBig0
 00000DEC  8B 5E 03			mov	ebx,[esi+3]		;Get target offset.
 00000DEF			@@sfBig0:
 00000DEF  03 C3			add	eax,ebx
 00000DF1  5B				pop	ebx
 00000DF2  83 C3 04			add	ebx,4
 00000DF5  2B C3			sub	eax,ebx
 00000DF7  89 07			mov	[edi],eax
					;
 00000DF9			@@sfNeg1:
 00000DF9  83 C6 05			add	esi,2+1+2
 00000DFC  83 E9 05			sub	ecx,2+1+2
 00000DFF  F6 C6 04			test	dh,4
 00000E02  0F 84 000000E8		jz	@@3
 00000E08  83 C6 02			add	esi,2
 00000E0B  83 E9 02			sub	ecx,2
 00000E0E  E9 000000DD			jmp	@@3
				
					;
 00000E13			@@Seg1632BitOff: ;Deal with an FWORD fixup by splitting into a seg16 and 32-bit
					;offset relocation entry.
					;
					;EBP	- Page offset within segment.
					;w[esi] - offset within page.
					;b[esi+2] - target object+1
					;w[esi+3] - target offset.
					;
 00000E13  8B 3D 00000B17 R		mov	edi,SegmentList
 00000E19  8B 7F 0C			mov	edi,[edi]._Seg_.Seg_Memory
 00000E1C  A1 00003922 R		mov	eax,PageCount+4	;Get page number.
 00000E21  C1 E0 0C			shl	eax,12
 00000E24  03 F8			add	edi,eax		;Point to the right page.
 00000E26  0F BF 06			movsx	eax,w[esi]
 00000E29  0B C0			or	eax,eax
 00000E2B  0F 88 000000AC		js	@@Neg2
 00000E31  03 F8			add	edi,eax		;Point to the right offset.
 00000E33  83 C7 04			add	edi,4		;Point to the seg bit.
 00000E36  0F B6 46 02			movzx	eax,b[esi+2]		;Get the target segment.
 00000E3A  48				dec	eax
 00000E3B  66| 89 07			mov	[edi],ax		;Store target.
					;
 00000E3E  8B 3D 00000B17 R		mov	edi,SegmentList
 00000E44  8B 3F			mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
 00000E46  A1 00003922 R		mov	eax,PageCount+4	;Get page number within segment.
 00000E4B  C1 E0 0C			shl	eax,12
 00000E4E  03 F8			add	edi,eax		;Include page offset.
 00000E50  0F B7 06			movzx	eax,w[esi]
 00000E53  03 F8			add	edi,eax		;Include byte offset.
 00000E55  83 C7 04			add	edi,4		;Point to the seg bit.
 00000E58  8B C7			mov	eax,edi
 00000E5A  E8 000000D0			call	AddRelocationEntry	;Add it to the list.
 00000E5F  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00000E68  0F 82 000000BF		jc	@@9
					;
 00000E6E  8B 3D 00000B17 R		mov	edi,SegmentList
 00000E74  8B 7F 0C			mov	edi,[edi]._Seg_.Seg_Memory
 00000E77  A1 00003922 R		mov	eax,PageCount+4	;Get page number.
 00000E7C  C1 E0 0C			shl	eax,12
 00000E7F  03 F8			add	edi,eax		;Point to the right page.
 00000E81  0F B7 06			movzx	eax,w[esi]
 00000E84  03 F8			add	edi,eax		;Point to the right offset.
 00000E86  0F B6 46 02			movzx	eax,b[esi+2]		;Get the target segment.
 00000E8A  48				dec	eax
 00000E8B  52				push	edx
 00000E8C  BA 00000010			mov	edx,size _Seg_
 00000E91  F7 E2			mul	edx
 00000E93  5A				pop	edx
 00000E94  83 C0 04			add	eax,4		;skip dword count.
 00000E97  03 05 00003912 R		add	eax,ObjectList	;point to target segment details.
 00000E9D  8B 00			mov	eax,[eax]._Seg_.Seg_BaseAddress	;Get target segments offset from start of image.
 00000E9F  0F B7 5E 03			movzx	ebx,w[esi+3]		;Get target offset.
 00000EA3  F6 C6 04			test	dh,4
 00000EA6  74 03			jz	@@Big1
 00000EA8  8B 5E 03			mov	ebx,[esi+3]		;Get target offset.
 00000EAB			@@Big1:
 00000EAB  03 C3			add	eax,ebx
 00000EAD  89 07			mov	[edi],eax
					;
 00000EAF  8B 3D 00000B17 R		mov	edi,SegmentList
 00000EB5  8B 3F			mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
 00000EB7  A1 00003922 R		mov	eax,PageCount+4	;Get page number within segment.
 00000EBC  C1 E0 0C			shl	eax,12
 00000EBF  03 F8			add	edi,eax		;Include page offset.
 00000EC1  0F B7 06			movzx	eax,w[esi]
 00000EC4  03 F8			add	edi,eax		;Include byte offset.
 00000EC6  8B C7			mov	eax,edi
 00000EC8  0D 10000000			or	eax,1 shl 28		;Mark it as a 32-bit offset.
 00000ECD  E8 0000005D			call	AddRelocationEntry	;Add it to the list.
 00000ED2  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00000EDB  72 50			jc	@@9
					;
 00000EDD  83 C6 05		@@Neg2:	add	esi,2+1+2
 00000EE0  83 E9 05			sub	ecx,2+1+2
 00000EE3  F6 C6 04			test	dh,4
 00000EE6  74 08			jz	@@3
 00000EE8  83 C6 02			add	esi,2
 00000EEB  83 E9 02			sub	ecx,2
 00000EEE  EB 00			jmp	@@3
					;
 00000EF0			@@3:
 00000EF0  FF 05 0000396A R		inc	RelocationCount
 00000EF6  0B C9			or	ecx,ecx
 00000EF8  0F 85 FFFFFD2C		jnz	@@2
					;
 00000EFE			@@4:
 00000EFE  45				inc	ebp
 00000EFF  FF 05 00003922 R		inc	PageCount+4
 00000F05  FF 0D 0000391E R		dec	PageCount
 00000F0B  0F 85 FFFFFCF4		jnz	@@1
					;
 00000F11  83 05 00000B17 R		add	SegmentList,size _Seg_
	   10
 00000F18  83 05 0000390E R		add	ObjectBase,18h
	   18
 00000F1F  FF 0D 0000390A R		dec	ObjectCount
 00000F25  0F 85 FFFFFCBB		jnz	@@0
					;
 00000F2B			@@8:
 00000F2B  F8				clc
 00000F2C  C3				ret
					;
 00000F2D			@@9:
 00000F2D  F9				stc
 00000F2E  C3				ret
 00000F2F			CreateRelocations endp
				
				
				;------------------------------------------------------------------------------
				;
				;Add an entry to the relocation list.
				;
				;On Entry:
				;
				;EAX	- Item to add.
				;
				;On Exit:
				;
				;Carry set on error else,
				;
				;All registers preserved.
				;
 00000F2F			AddRelocationEntry proc near
 00000F2F  60				pushad
 00000F30  83 3D 00003916 R		cmp	RelocationList,0
	   00
 00000F37  75 18			jnz	@@0
 00000F39  B9 00000004			mov	ecx,4
 00000F3E  E8 00000314			call	LEMalloc
 00000F43  72 34			jc	@@9
 00000F45  89 35 00003916 R		mov	RelocationList,esi
 00000F4B  C7 06 00000000		mov	d[esi],0
					;
 00000F51			@@0:
 00000F51  8B 35 00003916 R		mov	esi,RelocationList
 00000F57  8B 0E			mov	ecx,[esi]		;Get current number of entries.
 00000F59  41				inc	ecx
 00000F5A  C1 E1 02			shl	ecx,2		;dword per entry.
 00000F5D  83 C1 04			add	ecx,4		;allow for count dword.
 00000F60  E8 000002D9			call	LEReMalloc
 00000F65  72 12			jc	@@9
 00000F67  89 35 00003916 R		mov	RelocationList,esi	;store new list address.
 00000F6D  FF 06			inc	d[esi]		;increase entry count.
 00000F6F  03 F1			add	esi,ecx
 00000F71  83 EE 04			sub	esi,4		;point to new entry.
 00000F74  89 06			mov	[esi],eax		;store entry.
					;
 00000F76  F8				clc
 00000F77  EB 01			jmp	@@10
					;
 00000F79			@@9:
 00000F79  F9				stc
 00000F7A			@@10:
 00000F7A  61				popad
 00000F7B  C3				ret
 00000F7C			AddRelocationEntry endp
				
				
				;------------------------------------------------------------------------------
				;
				;Create 3P version of LE file in memory.
				;
 00000F7C			Create3PFile	proc	near
					@dprintf 1,<"Create3PFile enter",10>
 00000F7C  E8 FFFFF0E1	     1		call dprintf
 00000F81  43 72 65 61 74    1		db "Create3PFile enter",10,0
	   65 33 50 46 69
	   6C 65 20 65 6E
	   74 65 72 0A 00
 00000F95  BE 0000388E R		mov	esi,offset BuildImageText
 00000F9A  E8 0000032A			call	LEPrintString
					;
 00000F9F  8B 35 000038FE R		mov	esi,LEAddress
 00000FA5  8B 4E 44			mov	ecx,[esi+44h]	;Get number of Objects.
 00000FA8  03 76 40			add	esi,[esi+40h]	;Point to object table.
 00000FAB  89 0D 0000390A R		mov	ObjectCount,ecx
 00000FB1  89 35 0000390E R		mov	ObjectBase,esi
					;
 00000FB7			@@0:                    ;<--- loop
 00000FB7  83 3D 00003912 R		cmp	ObjectList,0	;Started object list yet?
	   00
 00000FBE  75 25			jnz	@@0_0
 00000FC0  B9 00000004			mov	ecx,4
 00000FC5  E8 0000028D			call	LEMalloc
 00000FCA  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00000FD3  0F 82 00000133		jc	@@9
 00000FD9  89 35 00003912 R		mov	ObjectList,esi
 00000FDF  C7 06 00000000		mov	d[esi],0
 00000FE5			@@0_0:
 00000FE5  8B 35 00003912 R		mov	esi,ObjectList
 00000FEB  8B 06			mov	eax,[esi]		;Get number of entries.
 00000FED  40				inc	eax
 00000FEE  BA 00000010			mov	edx,size _Seg_
 00000FF3  F7 E2			mul	edx
 00000FF5  83 C0 04			add	eax,4
 00000FF8  8B C8			mov	ecx,eax
 00000FFA  E8 0000023F			call	LEReMalloc		;Enlarge it.
 00000FFF  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 00001008  0F 82 000000FE		jc	@@9
 0000100E  89 35 00003912 R		mov	ObjectList,esi
 00001014  FF 06			inc	d[esi]
 00001016  03 F1			add	esi,ecx
 00001018  83 EE 10			sub	esi,size _Seg_	;Point to new entry.
 0000101B  8B FE			mov	edi,esi
 0000101D  B9 00000010			mov	ecx,size _Seg_
 00001022  32 C0			xor	al,al
 00001024  F3/ AA			rep	stosb		;Clear it out.
 00001026  8B FE			mov	edi,esi
					;
 00001028  A1 0000391A R		mov	eax,SegmentBase
 0000102D  89 07			mov	[edi]._Seg_.Seg_BaseAddress,eax
 0000102F  8B 35 0000390E R		mov	esi,ObjectBase
 00001035  8B 0E			mov	ecx,[esi]		;Get segments size.
				;	add	ecx,15
				;	and	ecx,not 15
 00001037  01 0D 0000391A R		add	SegmentBase,ecx
 0000103D  89 4F 08			mov	[edi]._Seg_.Seg_Length,ecx	;Set segments size.
					;
 00001040  E8 00000212			call	LEMalloc
 00001045  66| C7 05			mov	ErrorNumber,36
	   00000004 R
	   0024
 0000104E  0F 82 000000B8		jc	@@9
 00001054  89 77 0C			mov	[edi]._Seg_.Seg_Memory,esi	;Store segments address.
					pushm	eax,ecx,edi
 00001057  50		     2		PUSH	eax			;SAVE THE REGISTER
 00001058  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001059  57		     2		PUSH	edi			;SAVE THE REGISTER
 0000105A  8B FE			mov	edi,esi
 0000105C  32 C0			xor	al,al
 0000105E  F3/ AA			rep	stosb
					popm	eax,ecx,edi
 00001060  5F		     2		POP	edi				;POP THE REGISTER
 00001061  59		     2		POP	ecx				;POP THE REGISTER
 00001062  58		     2		POP	eax				;POP THE REGISTER
					;
 00001063  8B 35 0000390E R		mov	esi,ObjectBase
 00001069  8B 46 08			mov	eax,[esi+08h]	;Get objects flags.
 0000106C  33 DB			xor	ebx,ebx
 0000106E  A9 00000004			test	eax,4		;Executable?
 00001073  75 08			jnz	@@1
 00001075  43				inc	ebx		;Make it Data.
 00001076  A9 00000002			test	eax,2		;Writeable?
 0000107B  74 00			jz	@@1
				;	add	ebx,2		;Read only data.
 0000107D			@@1:
 0000107D  C1 E3 18			shl	ebx,24
 00001080  A9 00002000			test	eax,2000h		;Big bit set?
 00001085  74 08			jz	@@2
 00001087  81 CB 04000000		or	ebx,1 shl 26		;Force 32-bit.
 0000108D  EB 06			jmp	@@3
 0000108F			@@2:
 0000108F  81 CB 02000000		or	ebx,1 shl 25		;Force 16-bit.
 00001095			@@3:
 00001095  8B 47 08			mov	eax,[edi]._Seg_.Seg_Length
 00001098  3D 00100000			cmp	eax,100000h		;>1M?
 0000109D  72 08			jc	@@4
 0000109F  C1 E8 0C			shr	eax,12
 000010A2  0D 00100000			or	eax,1 shl 20
 000010A7			@@4:
 000010A7  0B D8			or	ebx,eax		;Include length.
 000010A9  81 CB 08000000		or	ebx,1 shl 27		;mark target type
 000010AF  89 5F 04			mov	[edi]._Seg_.Seg_Type,ebx	;Store the 3P type.
					;
 000010B2  8B 35 0000390E R		mov	esi,ObjectBase
 000010B8  8B 4E 10			mov	ecx,[esi+10h]	;Get number of pages.
 000010BB  8B 56 0C			mov	edx,[esi+0Ch]	;Get page table index.
 000010BE  8B 6F 08			mov	ebp,[edi]._Seg_.Seg_Length	;Get maximum length again.
 000010C1  8B 7F 0C			mov	edi,[edi]._Seg_.Seg_Memory	;Point to segments memory.
 000010C4  8B 1D 000038FE R		mov	ebx,LEAddress
 000010CA  03 9B 00000080		add	ebx,[ebx+80h]
 000010D0  2B 1D 00003906 R		sub	ebx,LEOffset
					;
 000010D6			@@5:
 000010D6  8B C2			mov	eax,edx		;Get page number.
 000010D8  48				dec	eax		;make it base 0.
 000010D9  C1 E0 0C			shl	eax,12		;*4096.
 000010DC  03 C3			add	eax,ebx		;Make offset from data pages.
 000010DE  8B F0			mov	esi,eax
					;
 000010E0  B8 00001000			mov	eax,4096		;Default page size.
 000010E5			@@6:
 000010E5  3B E8			cmp	ebp,eax		;Want whole page?
 000010E7  73 02			jnc	@@7
 000010E9  8B C5			mov	eax,ebp		;Force smaller value.
 000010EB			@@7:
 000010EB  51				push	ecx
 000010EC  8B C8			mov	ecx,eax		;Get length to copy.
 000010EE  F3/ A4			rep	movsb		;Copy this page.
 000010F0  59				pop	ecx
 000010F1  2B E8			sub	ebp,eax		;Update length remaining.
 000010F3  42				inc	edx		;Next page index.
 000010F4  49				dec	ecx
 000010F5  75 EE			jnz	@@6		;Get all pages.
					;
 000010F7  83 05 0000390E R		add	ObjectBase,18h	;Next object
	   18
 000010FE  FF 0D 0000390A R		dec	ObjectCount
 00001104  0F 85 FFFFFEAD		jnz	@@0		;Do all objects.
					;
 0000110A  F8				clc
 0000110B  C3				ret
					;
 0000110C			@@9:
 0000110C  F9				stc
 0000110D  C3				ret
 0000110E			Create3PFile	endp
				
				
				;------------------------------------------------------------------------------
				;
				;Fetch the specified LE file, just the LE bit not its stub.
				;
 0000110E			FetchLEFile	proc	near
					@dprintf 1,<"FetchLEFile enter",10>
 0000110E  E8 FFFFEF4F	     1		call dprintf
 00001113  46 65 74 63 68    1		db "FetchLEFile enter",10,0
	   4C 45 46 69 6C
	   65 20 65 6E 74
	   65 72 0A 00
 00001126  BE 00003871 R		mov	esi,offset ReadingLEText
 0000112B  E8 00000199			call	LEPrintString
					;
 00001130  BA 00000100 R		mov	edx,offset EXEFileName
 00001135  E8 0000017A			call	LEOpenFile
 0000113A  66| C7 05			mov	ErrorNumber,32
	   00000004 R
	   0020
 00001143  0F 82 000000A4		jc	@@9
 00001149  B9 0000003C			mov	ecx,3ch
 0000114E  32 C0			xor	al,al
 00001150  E8 00000147			call	LESetFilePointer	;Move to the LE bit.
 00001155  52				push	edx
 00001156  8B D4			mov	edx,esp
 00001158  B9 00000004			mov	ecx,4
 0000115D  E8 00000105			call	LEReadFile		;Read offset to LE.
 00001162  5A				pop	edx
 00001163  89 15 00003906 R		mov	LEOffset,edx
 00001169  66| C7 05			mov	ErrorNumber,33
	   00000004 R
	   0021
 00001172  72 79			jc	@@9
 00001174  3B C1			cmp	eax,ecx
 00001176  75 75			jnz	@@9
 00001178  33 C9			xor	ecx,ecx
 0000117A  B0 02			mov	al,2
 0000117C  E8 0000011B			call	LESetFilePointer	;Get file length.
 00001181  2B CA			sub	ecx,edx		;Lose stub section from length.
 00001183  87 CA			xchg	ecx,edx
 00001185  32 C0			xor	al,al
 00001187  E8 00000110			call	LESetFilePointer	;Point to LE section.
 0000118C  87 CA			xchg	ecx,edx
 0000118E  51				push	ecx
 0000118F  81 C1 00000FFF		add	ecx,4095
 00001195  81 E1 FFFFF000		and	ecx,not 4095
 0000119B  E8 000000B7			call	LEMalloc		;Get memory for the file.
 000011A0  59				pop	ecx
 000011A1  66| C7 05			mov	ErrorNumber,34
	   00000004 R
	   0022
 000011AA  72 41			jc	@@9
					pushm	eax,ecx,edi
 000011AC  50		     2		PUSH	eax			;SAVE THE REGISTER
 000011AD  51		     2		PUSH	ecx			;SAVE THE REGISTER
 000011AE  57		     2		PUSH	edi			;SAVE THE REGISTER
 000011AF  81 C1 00000FFF		add	ecx,4095
 000011B5  81 E1 FFFFF000		and	ecx,not 4095
 000011BB  8B FE			mov	edi,esi
 000011BD  32 C0			xor	al,al
 000011BF  F3/ AA			rep	stosb
					popm	eax,ecx,edi
 000011C1  5F		     2		POP	edi				;POP THE REGISTER
 000011C2  59		     2		POP	ecx				;POP THE REGISTER
 000011C3  58		     2		POP	eax				;POP THE REGISTER
 000011C4  8B D6			mov	edx,esi
 000011C6  E8 0000009C			call	LEReadFile		;Read the file.
 000011CB  66| C7 05			mov	ErrorNumber,35
	   00000004 R
	   0023
 000011D4  72 17			jc	@@9
 000011D6  3B C1			cmp	eax,ecx
 000011D8  75 13			jnz	@@9
 000011DA  E8 00000071			call	LECloseFile		;Close the file again.
					;
 000011DF  89 35 000038FE R		mov	LEAddress,esi	;Store LE files address.
 000011E5  89 0D 00003902 R		mov	LELength,ecx		;Store its length as well.
 000011EB  F8				clc
 000011EC  C3				ret
					;
 000011ED  F9			@@9:	stc
 000011EE  C3				ret
 000011EF			FetchLEFile	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Create a file.
				;
				;On Entry:
				;
				;EDX	- File name.
				;
				;On Exit:
				;
				;Carry set on error and EBX=0 else,
				;
				;EBX	- File handle.
				;
 000011EF			LECreateFile	proc	near
					pushm	eax,ecx
 000011EF  50		     2		PUSH	eax			;SAVE THE REGISTER
 000011F0  51		     2		PUSH	ecx			;SAVE THE REGISTER
 000011F1  B4 3C			mov	ah,3ch		;Create function.
 000011F3  66| 33 C9			xor	cx,cx		;normal attributes.
 000011F6  CD 21			int	21h
 000011F8  66| 8B D8			mov	bx,ax
 000011FB  73 04			jnc	l0
 000011FD  66| 33 DB			xor	bx,bx
 00001200  F9				stc
 00001201			l0:
 00001201  0F B7 DB			movzx	ebx,bx
					popm	eax,ecx
 00001204  59		     2		POP	ecx				;POP THE REGISTER
 00001205  58		     2		POP	eax				;POP THE REGISTER
 00001206  C3				ret
 00001207			LECreateFile	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Write some data to a file.
				;
				;On Entry:
				;
				;EDX	- Address to write from.
				;ECX	- Length to write.
				;EBX	- file handle.
				;
				;On Exit:
				;
				;EAX	- Bytes written.
				;
 00001207			LEWriteFile	proc	near
					pushm	ecx,edx,esi
 00001207  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001208  52		     2		PUSH	edx			;SAVE THE REGISTER
 00001209  56		     2		PUSH	esi			;SAVE THE REGISTER
 0000120A  33 F6			xor	esi,esi
 0000120C			@@0:
					pushm	ebx,ecx,edx,esi
 0000120C  53		     2		PUSH	ebx			;SAVE THE REGISTER
 0000120D  51		     2		PUSH	ecx			;SAVE THE REGISTER
 0000120E  52		     2		PUSH	edx			;SAVE THE REGISTER
 0000120F  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001210  81 F9 0000FFFF		cmp	ecx,65535		;size of chunks to load.
 00001216  72 05			jc	@@1
 00001218  B9 0000FFFF			mov	ecx,65535		;as close to 64k as can get.
 0000121D			@@1:
 0000121D  B4 40			mov	ah,40h
 0000121F  CD 21			int	21h		;read from the file.
					popm	ebx,ecx,edx,esi
 00001221  5E		     2		POP	esi				;POP THE REGISTER
 00001222  5A		     2		POP	edx				;POP THE REGISTER
 00001223  59		     2		POP	ecx				;POP THE REGISTER
 00001224  5B		     2		POP	ebx				;POP THE REGISTER
 00001225  72 11			jc	@@2
 00001227  0F B7 C0			movzx	eax,ax		;get length read.
 0000122A  03 F0			add	esi,eax		;update length read counter.
 0000122C  03 D0			add	edx,eax		;move memory pointer.
 0000122E  2B C8			sub	ecx,eax		;update length counter.
 00001230  74 06			jz	@@2		;read as much as was wanted.
 00001232  0B C0			or	eax,eax		;did we write anything?
 00001234  74 02			jz	@@2
 00001236  EB D4			jmp	@@0
 00001238			@@2:
 00001238  8B C6			mov	eax,esi
					popm	ecx,edx,esi
 0000123A  5E		     2		POP	esi				;POP THE REGISTER
 0000123B  5A		     2		POP	edx				;POP THE REGISTER
 0000123C  59		     2		POP	ecx				;POP THE REGISTER
 0000123D  C3				ret
 0000123E			LEWriteFile	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Re-size previously allocated memory.
				;
				;On Entry:
				;
				;ECX	- New size.
				;ESI	- Current address of memory.
				;
				;On Exit:
				;
				;Carry set on error and ESI=0 else,
				;
				;ESI	- New address of memory.
				;
				;All other registers preserved.
				;
 0000123E			LEReMalloc	proc	near
					pushm	eax,edx
 0000123E  50		     2		PUSH	eax			;SAVE THE REGISTER
 0000123F  52		     2		PUSH	edx			;SAVE THE REGISTER
				if @Model ne 7
				endif
 00001240  E8 00001C72			call	ResMemLinear32
 00001245  72 03			jc	l0
				if @Model ne 7
				endif
 00001247  F8				clc
 00001248  EB 03			jmp	l1
 0000124A			l0:
 0000124A  33 F6			xor	esi,esi
 0000124C  F9				stc
 0000124D			l1:	popm	eax,edx
 0000124D  5A		     2		POP	edx				;POP THE REGISTER
 0000124E  58		     2		POP	eax				;POP THE REGISTER
 0000124F  C3				ret
 00001250			LEReMalloc	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Close a file.
				;
				;On Entry:
				;
				;EBX	- file handle.
				;
 00001250			LECloseFile	proc	near
 00001250  50				push	eax
 00001251  B4 3E			mov	ah,3eh
 00001253  CD 21			int	21h
 00001255  58				pop	eax
 00001256  C3				ret
 00001257			LECloseFile	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Allocate some DS relative memory.
				;
				;On Entry:
				;
				;ECX	- Bytes required.
				;
				;On Exit:
				;
				;Carry set on error and ESI=0 else,
				;
				;ESI	- DS relative address of allocated memory.
				;
				;All other registers preserved.
				;
 00001257			LEMalloc	proc	near
 00001257  50				push	eax
 00001258  E8 00001C2F			call	GetMemLinear32
 0000125D  72 03			jc	l0
				if @Model ne 7
				endif
 0000125F  F8				clc
 00001260  EB 03			jmp	l1
 00001262			l0:
 00001262  33 F6			xor	esi,esi
 00001264  F9				stc
 00001265			l1:
 00001265  58				pop	eax
 00001266  C3				ret
 00001267			LEMalloc	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Read some data from a file.
				;
				;On Entry:
				;
				;EDX	- Address to read to.
				;ECX	- length to read.
				;EBX	- file handle.
				;
				;On Exit:
				;
				;EAX	- bytes read.
				;
 00001267			LEReadFile	proc	near
					pushm	ecx,edx,esi
 00001267  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001268  52		     2		PUSH	edx			;SAVE THE REGISTER
 00001269  56		     2		PUSH	esi			;SAVE THE REGISTER
 0000126A  33 F6			xor	esi,esi		;reset length read.
 0000126C			@@0:
					pushm	ebx,ecx,edx,esi
 0000126C  53		     2		PUSH	ebx			;SAVE THE REGISTER
 0000126D  51		     2		PUSH	ecx			;SAVE THE REGISTER
 0000126E  52		     2		PUSH	edx			;SAVE THE REGISTER
 0000126F  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001270  81 F9 0000FFFF		cmp	ecx,65535		;size of chunks to load.
 00001276  72 05			jc	@@1
 00001278  B9 0000FFFF			mov	ecx,65535		;as close to 64k as can get.
 0000127D			@@1:
 0000127D  B4 3F			mov	ah,3fh
 0000127F  CD 21			int	21h		;read from the file.
					popm	ebx,ecx,edx,esi
 00001281  5E		     2		POP	esi				;POP THE REGISTER
 00001282  5A		     2		POP	edx				;POP THE REGISTER
 00001283  59		     2		POP	ecx				;POP THE REGISTER
 00001284  5B		     2		POP	ebx				;POP THE REGISTER
 00001285  72 0F			jc	@@2		;DOS error so exit NOW.
 00001287  0F B7 C0			movzx	eax,ax		;get length read.
 0000128A  03 F0			add	esi,eax		;update length read counter.
 0000128C  03 D0			add	edx,eax		;move memory pointer.
 0000128E  2B C8			sub	ecx,eax		;update length counter.
 00001290  74 04			jz	@@2		;read as much as was wanted.
 00001292  0B C0			or	eax,eax		;did we read anything?
 00001294  75 D6			jnz	@@0
 00001296			@@2:
 00001296  8B C6			mov	eax,esi
					popm	ecx,edx,esi
 00001298  5E		     2		POP	esi				;POP THE REGISTER
 00001299  5A		     2		POP	edx				;POP THE REGISTER
 0000129A  59		     2		POP	ecx				;POP THE REGISTER
 0000129B  C3				ret
 0000129C			LEReadFile	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Set the file pointer position for a file.
				;
				;On Entry:
				;
				;AL	- method.
				;EBX	- handle.
				;ECX	- position.
				;
				;Methods are:
				;
				;0	- Absolute offset from start.
				;1	- signed offset from current position.
				;2	- signed offset from end of file.
				;
				;On Exit:
				;
				;ECX	- absolute offset from start of file.
				;
 0000129C			LESetFilePointer proc near
					pushm	eax,edx
 0000129C  50		     2		PUSH	eax			;SAVE THE REGISTER
 0000129D  52		     2		PUSH	edx			;SAVE THE REGISTER
 0000129E  66| 8B D1			mov	dx,cx
 000012A1  C1 E9 10			shr	ecx,16
 000012A4  B4 42			mov	ah,42h		;set pointer function.
 000012A6  CD 21			int	21h
 000012A8  66| 8B CA			mov	cx,dx
 000012AB  C1 E1 10			shl	ecx,16
 000012AE  66| 8B C8			mov	cx,ax		;fetch small result.
					popm	eax,edx
 000012B1  5A		     2		POP	edx				;POP THE REGISTER
 000012B2  58		     2		POP	eax				;POP THE REGISTER
 000012B3  C3				ret
 000012B4			LESetFilePointer endp
				
				
				;-------------------------------------------------------------------------
				;
				;Open a file.
				;
				;On Entry:
				;
				;EDX	- File name.
				;
				;On Exit:
				;
				;Carry set on error and EBX=0 else,
				;
				;EBX	- File handle.
				;
 000012B4			LEOpenFile	proc	near
 000012B4  50				push	eax
 000012B5  66| B8 3D02			mov	ax,3d02h		;Open with read & write access.
 000012B9  CD 21			int	21h
 000012BB  66| 8B D8			mov	bx,ax
 000012BE  73 04			jnc	l0
 000012C0  66| 33 DB			xor	bx,bx
 000012C3  F9				stc
 000012C4			l0:
 000012C4  58				pop	eax
 000012C5  0F B7 DB			movzx	ebx,bx
 000012C8  C3				ret
 000012C9			LEOpenFile	endp
				
				
				;-------------------------------------------------------------------------
				;
				;Print null terminated string on screen via DOS.
				;
				;On Entry:
				;
				;ESI	- pointer to string to print.
				;
 000012C9			LEPrintString	proc	near
					pushm	eax,esi,edx
 000012C9  50		     2		PUSH	eax			;SAVE THE REGISTER
 000012CA  56		     2		PUSH	esi			;SAVE THE REGISTER
 000012CB  52		     2		PUSH	edx			;SAVE THE REGISTER
 000012CC			l0:
 000012CC  8A 16			mov	dl,[esi]
 000012CE  46				inc	esi
 000012CF  0A D2			or	dl,dl
 000012D1  74 06			jz	l1
 000012D3  B4 02			mov	ah,2
 000012D5  CD 21			int	21h
 000012D7  EB F3			jmp	l0
 000012D9			l1:
					popm	eax,esi,edx
 000012D9  5A		     2		POP	edx				;POP THE REGISTER
 000012DA  5E		     2		POP	esi				;POP THE REGISTER
 000012DB  58		     2		POP	eax				;POP THE REGISTER
 000012DC  C3				ret
 000012DD			LEPrintString	endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 000012DD			NewCauseWay	proc	near
				;
				;Write new CauseWay loader to a 3P file.
				;
					@dprintf 1,<"NewCauseWay enter",10>
 000012DD  E8 FFFFED80	     1		call dprintf
 000012E2  4E 65 77 43 61    1		db "NewCauseWay enter",10,0
	   75 73 65 57 61
	   79 20 65 6E 74
	   65 72 0A 00
 000012F5  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 000012FC  E8 00001E04			call	CloseFile
 00001301  BA 00000100 R		mov	edx,offset EXEFileName
 00001306  E8 00001D10			call	OpenFile		;Open the .EXE file.
 0000130B  66| C7 05			mov	ErrorNumber,6	;default to not found.
	   00000004 R
	   0006
 00001314  0F 82 0000035C		jc	@@9
 0000131A  66| A3			mov	EXEHandle,ax
	   00000B00 R
					;
					;Create temp file.
					;
 00001320  BA 00000B08 R		mov	edx,offset TempFileName	;get DOS to give us a temp file.
 00001325  E8 00001D24			call	CreateFile
 0000132A  66| C7 05			mov	ErrorNumber,19	;default to can't create output.
	   00000004 R
	   0013
 00001333  0F 82 0000033D		jc	@@9		;oops.
 00001339  66| A3			mov	TempHandle,ax
	   00000B15 R
					;
					;Copy 386SHELL to temp file.
					;
 0000133F  BA 00000080 R		mov	edx,offset SHELLFileName	;get extender stub (stub from CW.EXE)
 00001344  E8 00001CD2			call	OpenFile
 00001349  66| C7 05			mov	ErrorNumber,9	;no stub file.
	   00000004 R
	   0009
 00001352  0F 82 0000031E		jc	@@9
 00001358  66| A3			mov	SHELLHandle,ax
	   00000AFA R
					;
 0000135E  BA 00000A62 R		mov	edx,offset ProcessStubText
 00001363  E8 00001ED8			call	StringPrint
					;
				
 00001368  BA 00000B2B R		mov	edx,offset exehdr
 0000136D  B9 0000001B			mov	ecx,sizeof MZHdr
 00001372  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 00001379  B4 3F			mov	ah,3fh
 0000137B  CD 21			int	21h		;read the .EXE header.
 0000137D  66| C7 05			mov	ErrorNumber,8	;default to IO error.
	   00000004 R
	   0008
 00001386  0F 82 000002EA		jc	@@9
 0000138C  66| C7 05			mov	ErrorNumber,9	;stub file error.
	   00000004 R
	   0009
 00001395  66| 83 F8 1B			cmp	ax,sizeof MZHdr
 00001399  0F 85 000002D7		jnz	@@9
 0000139F  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Correct ID?
	   00000B2B R
	   5A4D
 000013A8  0F 85 000002C8		jnz	@@9
					;
 000013AE  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 000013B4  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 000013BC  74 02			je	medexe5		; not rounded if no modulo
				
 000013BE  66| 48			dec	ax		;lose 1 cos its rounded up
				
 000013C0			medexe5:
 000013C0  66| 03 C0			add	ax,ax		;mult by 2
 000013C3  B6 00			mov	dh,0
 000013C5  8A D4			mov	dl,ah
 000013C7  8A E0			mov	ah,al
 000013C9  8A C6			mov	al,dh		;mult by 256=*512
 000013CB  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 000013D2  66| 83 D2 00			adc	dx,0		;add any carry to dx
 000013D6  66| 8B C8			mov	cx,ax
					pushm	cx,dx
 000013D9  66| 51	     2		PUSH	cx			;SAVE THE REGISTER
 000013DB  66| 52	     2		PUSH	dx			;SAVE THE REGISTER
 000013DD  66| BA FFE5			mov	dx,-1bh
 000013E1  66| B9 FFFF			mov	cx,-1
 000013E5  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 000013EC  66| B8 4201			mov	ax,4201h
 000013F0  CD 21			int	21h		;move back to start of CWSTUB.EXE
					popm	cx,dx
 000013F2  66| 5A	     2		POP	dx				;POP THE REGISTER
 000013F4  66| 59	     2		POP	cx				;POP THE REGISTER
					;
					;Get memory for shell.
					;
 000013F6  8B DA			mov	ebx,edx
 000013F8  C1 E3 10			shl	ebx,16
 000013FB  66| 8B D9			mov	bx,cx
				;	push	ebx
				;	sys	GetMemNear		;get memory for shell.
				;	pop	ebx
 000013FE  8B CB			mov	ecx,ebx
 00001400  E8 00001A87			call	GetMemLinear32
				
 00001405  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 0000140E  0F 82 00000262		jc	@@9
					;
					;Read shell into memory.
					;
					pushm	ebx,esi
 00001414  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001415  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001416  8B CB			mov	ecx,ebx
 00001418  8B FE			mov	edi,esi
 0000141A  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 00001421  E8 00001C6B			call	ReadFile
					popm	ebx,esi
 00001426  5E		     2		POP	esi				;POP THE REGISTER
 00001427  5B		     2		POP	ebx				;POP THE REGISTER
 00001428  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001431  0F 82 0000023F		jc	@@9
 00001437  3B C3			cmp	eax,ebx		;did we read enough?
 00001439  0F 85 00000237		jnz	@@9
					pushm	ebx,esi
 0000143F  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001440  56		     2		PUSH	esi			;SAVE THE REGISTER
					;
					;Write shell to temp.
					;
					popm	ebx,esi
 00001441  5E		     2		POP	esi				;POP THE REGISTER
 00001442  5B		     2		POP	ebx				;POP THE REGISTER
					pushm	ebx,esi
 00001443  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001444  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001445  8B CB			mov	ecx,ebx
 00001447  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 0000144E  E8 00001C78			call	WriteFile
					popm	ebx,esi
 00001453  5E		     2		POP	esi				;POP THE REGISTER
 00001454  5B		     2		POP	ebx				;POP THE REGISTER
 00001455  0F 82 0000021B		jc	@@9
 0000145B  3B C3			cmp	eax,ebx		;did we write enough?
 0000145D  0F 85 00000213		jnz	@@9
				
					@dprintf 1,<"NewCauseWay: at memory release",10>
 00001463  E8 FFFFEBFA	     1		call dprintf
 00001468  4E 65 77 43 61    1		db "NewCauseWay: at memory release",10,0
	   75 73 65 57 61
	   79 3A 20 61 74
	   20 6D 65 6D 6F
	   72 79 20 72 65
	   6C 65 61 73 65
	   0A 00
				
				;	sys	RelMemNear		;release memory now.
 00001488  E8 00001A1C			call	RelMemLinear32
				
					;
					;Skip past old CauseWay.
					;
 0000148D  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001496  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 0000149D  BA 00000B2B R		mov	edx,offset exehdr	;somewhere to put the info.
 000014A2  B9 0000001B			mov	ecx,sizeof MZHdr	;size of it.
 000014A7  B4 3F			mov	ah,3fh
 000014A9  CD 21			int	21h
 000014AB  0F 82 000001C5		jc	@@9
 000014B1  66| 83 F8 1B			cmp	ax,sizeof MZHdr		;did we read right amount?
 000014B5  0F 85 000001BB		jnz	@@9
					;
					;Check for normal MZ header first.
					;
 000014BB  66| C7 05			mov	ErrorNumber,7
	   00000004 R
	   0007
 000014C4  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Normal EXE?
	   00000B2B R
	   5A4D
 000014CD  0F 85 000001A3		jnz	@@9
					;
 000014D3  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 000014D9  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 000014E1  74 02			je	medexe6		; not rounded if no modulo
				
 000014E3  66| 48			dec	ax		;lose 1 cos its rounded up
				
 000014E5			medexe6:
 000014E5  66| 03 C0			add	ax,ax		;mult by 2
 000014E8  B6 00			mov	dh,0
 000014EA  8A D4			mov	dl,ah
 000014EC  8A E0			mov	ah,al
 000014EE  8A C6			mov	al,dh		;mult by 256=*512
 000014F0  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 000014F7  66| 83 D2 00			adc	dx,0		;add any carry to dx
 000014FB  66| 8B C8			mov	cx,ax
					pushm	cx,dx
 000014FE  66| 51	     2		PUSH	cx			;SAVE THE REGISTER
 00001500  66| 52	     2		PUSH	dx			;SAVE THE REGISTER
					;
					;Find out where the end of the file is.
					;
 00001502  66| 33 C9			xor	cx,cx
 00001505  66| 8B D1			mov	dx,cx
 00001508  B0 02			mov	al,2
 0000150A  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001511  E8 00001B6C			call	SetFilePointer	;move to the end of the file.
 00001516  66| 8B C1			mov	ax,cx
 00001519  66| 8B DA			mov	bx,dx
					popm	cx,dx
 0000151C  66| 5A	     2		POP	dx				;POP THE REGISTER
 0000151E  66| 59	     2		POP	cx				;POP THE REGISTER
 00001520  66| 2B C1			sub	ax,cx
 00001523  66| 1B DA			sbb	bx,dx		;get remaining length.
					pushm	ax,bx
 00001526  66| 50	     2		PUSH	ax			;SAVE THE REGISTER
 00001528  66| 53	     2		PUSH	bx			;SAVE THE REGISTER
 0000152A  B0 00			mov	al,0
 0000152C  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001533  E8 00001B4A			call	SetFilePointer	;point to the 3P header again.
					popm	ax,bx
 00001538  66| 5B	     2		POP	bx				;POP THE REGISTER
 0000153A  66| 58	     2		POP	ax				;POP THE REGISTER
 0000153C  C1 E3 10			shl	ebx,16
 0000153F  66| 8B D8			mov	bx,ax
				
					@dprintf 1,<'NewCauseWay: at get memory',10>
 00001542  E8 FFFFEB1B	     1		call dprintf
 00001547  4E 65 77 43 61    1		db 'NewCauseWay: at get memory',10,0
	   75 73 65 57 61
	   79 3A 20 61 74
	   20 67 65 74 20
	   6D 65 6D 6F 72
	   79 0A 00
				
				;	push	ebx
				;	sys	GetMemNear		;get some memory for it.
				;	pop	ebx
 00001563  8B CB			mov	ecx,ebx
 00001565  E8 00001922			call	GetMemLinear32
				
 0000156A  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 00001573  0F 82 000000FD		jc	@@9
					;
					;Read real file into memory.
					;
 00001579  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
					pushm	esi,ebx
 00001582  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001583  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001584  8B CB			mov	ecx,ebx
 00001586  8B FE			mov	edi,esi
 00001588  1E				push	ds
 00001589  07				pop	es
 0000158A  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001591  E8 00001AFB			call	ReadFile
					popm	esi,ecx
 00001596  59		     2		POP	ecx				;POP THE REGISTER
 00001597  5E		     2		POP	esi				;POP THE REGISTER
 00001598  0F 82 000000D8		jc	@@9
 0000159E  3B C1			cmp	eax,ecx
 000015A0  0F 82 000000D0		jc	@@9
					;
					;Write real file to temp.
					;
					pushm	esi,ecx
 000015A6  56		     2		PUSH	esi			;SAVE THE REGISTER
 000015A7  51		     2		PUSH	ecx			;SAVE THE REGISTER
 000015A8  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 000015AF  E8 00001B17			call	WriteFile
					popm	esi,ecx
 000015B4  59		     2		POP	ecx				;POP THE REGISTER
 000015B5  5E		     2		POP	esi				;POP THE REGISTER
 000015B6  0F 82 000000BA		jc	@@9
 000015BC  3B C1			cmp	eax,ecx
 000015BE  0F 85 000000B2		jnz	@@9
				;	sys	RelMemNear		;release the memory.
 000015C4  E8 000018E0			call	RelMemLinear32
				
				
					;
					;Close the files.
					;
 000015C9  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 000015D0  E8 00001B30			call	CloseFile		;close the temp file.
 000015D5  66| C7 05			mov	TEMPHandle,0
	   00000B15 R
	   0000
 000015DE  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 000015E5  E8 00001B1B			call	CloseFile		;close the file again.
 000015EA  66| C7 05			mov	EXEHandle,0
	   00000B00 R
	   0000
 000015F3  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 000015FA  E8 00001B06			call	CloseFile
 000015FF  66| C7 05			mov	SHELLHandle,0
	   00000AFA R
	   0000
					;
				
					@dprintf 1,<"NewCauseWay: File %s",10>,offset EXEFileName
 00001608  68 00000100 R     2		push offset EXEFileName
 0000160D  E8 FFFFEA50	     1		call dprintf
 00001612  4E 65 77 43 61    1		db "NewCauseWay: File %s",10,0
	   75 73 65 57 61
	   79 3A 20 46 69
	   6C 65 20 25 73
	   0A 00
				
					;Delete origional .EXE
					;
 00001628  BA 00000100 R		mov	edx,offset EXEFileName	;get file name mask.
 0000162D  B4 41			mov	ah,41h
 0000162F  CD 21			int	21h
 00001631  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 0000163A  72 3A			jc	@@9
					;
				
					@dprintf 1,<'NewCauseWay: at rename',10>
 0000163C  E8 FFFFEA21	     1		call dprintf
 00001641  4E 65 77 43 61    1		db 'NewCauseWay: at rename',10,0
	   75 73 65 57 61
	   79 3A 20 61 74
	   20 72 65 6E 61
	   6D 65 0A 00
				
					;now rename it.
					;
 00001659  BA 00000B08 R		mov	edx,offset TempFileName
 0000165E  BF 00000100 R		mov	edi,offset EXEFileName		;get file name mask.
 00001663  B4 56			mov	ah,56h
 00001665  CD 21			int	21h
 00001667  72 0D			jc	@@9
					;
 00001669  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 00001672  66| 33 C0			xor	ax,ax
 00001675  C3				ret
					;
 00001676  66| B8 FFFF		@@9:	mov	ax,-1
 0000167A  66| 0B C0			or	ax,ax
 0000167D  C3				ret
 0000167E			NewCauseWay	endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000167E			SetSystemConfig proc near
				;
				;Set Flags entry in header.
				;
 0000167E  33 C0			xor	eax,eax
					;
 00001680  80 3D 000039C0 R		cmp	OptionTable+'D',0	;Dual mode?
	   00
 00001687  74 0C			jz	@@2
 00001689  0D 00010000			or	eax,65536		;enable dual mode.
				
				; don't set data bit under dual mode because it can confuse things
				;  why, I don't know, it just does
				;  MED 06/11/96
 0000168E  0D 00004000			or	eax,16384		;set 16 bit code segments.
				;	or	eax,1+16384		;16 bit code.
				
 00001693  EB 0E			jmp	@@0
					;
 00001695  80 3D 000039AF R	@@2:	cmp	OptionTable+'3',0
	   00
 0000169C  75 05			jnz	@@0
 0000169E  0D 00004001			or	eax,1+16384		;16 bit code.
 000016A3			@@0:	;
 000016A3  80 3D 000039C8 R		cmp	OptionTable+'L',0	;LDT ?
	   00
 000016AA  74 05			jz	@@1
 000016AC  0D 00000080			or	eax,128
 000016B1			@@1:	;
 000016B1  BE 00000B4E R		mov	esi,offset NewHeader
 000016B6  89 46 20			mov	[esi].NewHeaderStruc.NewFlags,eax
					;
					;Get auto stack size.
					;
 000016B9  66| C7 05			mov	ErrorNumber,27
	   00000004 R
	   001B
 000016C2  80 3D 000039CF R		cmp	OptionTable+'S',0
	   00
 000016C9  74 41			jz	@@NoAutoESP
 000016CB  8B 35 00003B48 R		mov	esi,d[OptionTable+128+('S'*4)]
 000016D1  0B F6			or	esi,esi
 000016D3  0F 84 FFFFEE4B		jz	System
 000016D9  33 D2			xor	edx,edx
 000016DB			@@ss0:
 000016DB  0F B6 06			movzx	eax,b[esi]
 000016DE  0A C0			or	al,al
 000016E0  74 22			jz	@@ss1
 000016E2  3C 30			cmp	al,'0'
 000016E4  0F 82 FFFFEE3A		jc	System
 000016EA  3C 3A			cmp	al,'9'+1
 000016EC  0F 83 FFFFEE32		jnc	System
 000016F2  2C 30			sub	al,'0'
 000016F4  50				push	eax
 000016F5  B8 0000000A			mov	eax,10
 000016FA  F7 E2			mul	edx
 000016FC  8B D0			mov	edx,eax
 000016FE  58				pop	eax
 000016FF  03 D0			add	edx,eax
 00001701  46				inc	esi
 00001702  EB D7			jmp	@@ss0
 00001704			@@ss1:
 00001704  BE 00000B4E R		mov	esi,offset NewHeader
 00001709  89 56 24			mov	[esi].NewHeaderStruc.NewAutoStack,edx
					;
 0000170C			@@NoAutoESP:
 0000170C  C3				ret
 0000170D			SetSystemConfig endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000170D			ExeAndMap2NewExe proc near
					@dprintf 1,<"ExeAndMap2NewExe entry",10>
 0000170D  E8 FFFFE950	     1		call dprintf
 00001712  45 78 65 41 6E    1		db "ExeAndMap2NewExe entry",10,0
	   64 4D 61 70 32
	   4E 65 77 45 78
	   65 20 65 6E 74
	   72 79 0A 00
					;
					;Setup hard wired flags, like 16/32 bit etc.
					;
 0000172A  8B CB			mov	ecx,ebx
 0000172C  E8 FFFFFF4D			call	SetSystemConfig
					;
 00001731  E8 00000E4F			call	ReadMapFile		;process map file details.
 00001736  75 10			jnz	@@9
					;
 00001738  E8 000006C8			call	ProcessFile		;do the nitty gritty.
 0000173D  75 09			jnz	@@9
					;
 0000173F  66| C7 05			mov	ErrorNumber,0	;clear error number.
	   00000004 R
	   0000
 00001748  C3			@@9:	ret
 00001749			ExeAndMap2NewExe endp
				
				
				;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00001749			NewExeInfo	proc	near
				;
				;Display details of file in CauseWay format format.
				;
 00001749  BA 00000ADE R		mov	edx,offset CarriageReturn
 0000174E  E8 00001AED			call	StringPrint
					;
 00001753  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 0000175A  E8 000019A6			call	CloseFile
 0000175F  BA 00000100 R		mov	edx,offset EXEFileName
 00001764  E8 000018B2			call	OpenFile		;Open the .EXE file.
 00001769  66| C7 05			mov	ErrorNumber,6	;default to not found.
	   00000004 R
	   0006
 00001772  0F 82 0000065E		jc	@@9
 00001778  66| A3			mov	EXEHandle,ax
	   00000B00 R
					;
 0000177E  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001787  66| 8B D8			mov	bx,ax
 0000178A  BA 00000B2B R		mov	edx,offset exehdr	;somewhere to put the info.
 0000178F  B9 0000001B			mov	ecx,sizeof MZHdr	;size of it.
 00001794  B4 3F			mov	ah,3fh
 00001796  CD 21			int	21h
 00001798  0F 82 00000638		jc	@@9
 0000179E  66| 83 F8 1B			cmp	ax,sizeof MZHdr		;did we read right amount?
 000017A2  0F 85 0000062E		jnz	@@9
					;
					;Check for normal MZ header first.
					;
 000017A8  66| C7 05			mov	ErrorNumber,7
	   00000004 R
	   0007
 000017B1  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Normal EXE?
	   00000B2B R
	   5A4D
 000017BA  74 10			jz	@@10
					;
					;Move back to EXE details.
					;
 000017BC  66| BA FFE5			mov	dx,-(1bh)
 000017C0  66| B9 FFFF			mov	cx,-1
 000017C4  66| B8 4201			mov	ax,4201h
 000017C8  CD 21			int	21h		;move back to start of the header.
 000017CA  EB 34			jmp	@@Look3P
 000017CC			@@10:	;
 000017CC  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 000017D2  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 000017DA  74 02			je	medexe7		; not rounded if no modulo
				
 000017DC  66| 48			dec	ax		;lose 1 cos its rounded up
				
 000017DE			medexe7:
 000017DE  66| 03 C0			add	ax,ax		;mult by 2
 000017E1  B6 00			mov	dh,0
 000017E3  8A D4			mov	dl,ah
 000017E5  8A E0			mov	ah,al
 000017E7  8A C6			mov	al,dh		;mult by 256=*512
 000017E9  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 000017F0  66| 83 D2 00			adc	dx,0		;add any carry to dx
 000017F4  66| 8B C8			mov	cx,ax
 000017F7  66| 87 CA			xchg	cx,dx		;swap round for DOS.
 000017FA  66| B8 4200			mov	ax,4200h		;set absolute position.
 000017FE  CD 21			int	21h
					;
 00001800			@@Look3P:
 00001800  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001809  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001810  BA 00000B4E R		mov	edx,offset NewHeader	;somewhere to put the info.
 00001815  66| B9 0040			mov	cx,size NewHeaderStruc	;size of it.
 00001819  B4 3F			mov	ah,3fh
 0000181B  CD 21			int	21h
 0000181D  0F 82 000005B3		jc	@@9
 00001823  66| C7 05			mov	ErrorNumber,7
	   00000004 R
	   0007
 0000182C  66| 83 F8 40			cmp	ax,size NewHeaderStruc	;did we read right amount?
 00001830  0F 85 000005A0		jnz	@@9
 00001836  66| 81 3D			cmp	w[NewHeader],'P3'	;ID ok?
	   00000B4E R
	   5033
 0000183F  0F 85 00000591		jnz	@@9
					;
 00001845  BE 00000B4E R		mov	esi,offset NewHeader	;somewhere to put the info.
 0000184A  BA 00003660 R		mov	edx,offset bit16text
 0000184F  F7 46 20			test	[esi].NewHeaderStruc.NewFlags,1
	   00000001
 00001856  75 13			jnz	@@its16
 00001858  BA 00003676 R		mov	edx,offset bit32text
 0000185D  F7 46 20			test	[esi].NewHeaderStruc.NewFlags,65536
	   00010000
 00001864  74 05			jz	@@its16
 00001866  BA 0000368C R		mov	edx,offset bitdualtext
 0000186B			@@its16:
 0000186B  B4 09			mov	ah,9
 0000186D  CD 21			int	21h
					;
 0000186F  BE 00000B4E R		mov	esi,offset NewHeader	;somewhere to put the info.
 00001874  BA 000036A5 R		mov	edx,offset SpeedLoadText
 00001879  F7 46 20			test	[esi].NewHeaderStruc.NewFlags,1 shl 30
	   40000000
 00001880  75 05			jnz	@@nospeed
 00001882  BA 00000AE1 R		mov	edx,offset CarriageReturn2
 00001887			@@NoSpeed:
 00001887  B4 09			mov	ah,9
 00001889  CD 21			int	21h
				
					;
 0000188B  BA 000036BD R		mov	edx,offset NewSizeT
 00001890  E8 000019AB			call	StringPrint
 00001895  BE 00000B4E R		mov	esi,offset NewHeader
 0000189A  8B 46 02			mov	eax,[esi].NewHeaderStruc.NewSize
 0000189D  B9 00000008			mov	ecx,8
 000018A2  BF 00000180 R		mov	edi,offset LineBuffer
 000018A7  E8 0000052B			call	Bin2Hex
 000018AC  C6 07 00			mov	b[edi],0
 000018AF  BA 00000180 R		mov	edx,offset LineBuffer
 000018B4  E8 00001987			call	StringPrint
 000018B9  BA 00000ADE R		mov	edx,offset CarriageReturn
 000018BE  E8 0000197D			call	StringPrint
					;
 000018C3  BA 000036CB R		mov	edx,offset NewLengthT
 000018C8  E8 00001973			call	StringPrint
 000018CD  BE 00000B4E R		mov	esi,offset NewHeader
 000018D2  8B 46 06			mov	eax,[esi].NewHeaderStruc.NewLength
 000018D5  B9 00000008			mov	ecx,8
 000018DA  BF 00000180 R		mov	edi,offset LineBuffer
 000018DF  E8 000004F3			call	Bin2Hex
 000018E4  C6 07 00			mov	b[edi],0
 000018E7  BA 00000180 R		mov	edx,offset LineBuffer
 000018EC  E8 0000194F			call	StringPrint
 000018F1  BA 00000ADE R		mov	edx,offset CarriageReturn
 000018F6  E8 00001945			call	StringPrint
					;
 000018FB  BA 000036D9 R		mov	edx,offset NewAllocT
 00001900  E8 0000193B			call	StringPrint
 00001905  BE 00000B4E R		mov	esi,offset NewHeader
 0000190A  8B 46 0A			mov	eax,[esi].NewHeaderStruc.NewAlloc
 0000190D  B9 00000008			mov	ecx,8
 00001912  BF 00000180 R		mov	edi,offset LineBuffer
 00001917  E8 000004BB			call	Bin2Hex
 0000191C  C6 07 00			mov	b[edi],0
 0000191F  BA 00000180 R		mov	edx,offset LineBuffer
 00001924  E8 00001917			call	StringPrint
 00001929  BA 00000ADE R		mov	edx,offset CarriageReturn
 0000192E  E8 0000190D			call	StringPrint
					;
 00001933  BA 000036E7 R		mov	edx,offset NewSegmentsT
 00001938  E8 00001903			call	StringPrint
 0000193D  BE 00000B4E R		mov	esi,offset NewHeader
 00001942  0F B7 46 0E			movzx	eax,[esi].NewHeaderStruc.NewSegments
 00001946  B9 00000008			mov	ecx,8
 0000194B  BF 00000180 R		mov	edi,offset LineBuffer
 00001950  E8 00000482			call	Bin2Hex
 00001955  C6 07 00			mov	b[edi],0
 00001958  BA 00000180 R		mov	edx,offset LineBuffer
 0000195D  E8 000018DE			call	StringPrint
 00001962  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001967  E8 000018D4			call	StringPrint
					;
 0000196C  BA 000036F5 R		mov	edx,offset NewRelocsT
 00001971  E8 000018CA			call	StringPrint
 00001976  BE 00000B4E R		mov	esi,offset NewHeader
 0000197B  8B 46 10			mov	eax,[esi].NewHeaderStruc.NewRelocs
 0000197E  B9 00000008			mov	ecx,8
 00001983  BF 00000180 R		mov	edi,offset LineBuffer
 00001988  E8 0000044A			call	Bin2Hex
 0000198D  C6 07 00			mov	b[edi],0
 00001990  BA 00000180 R		mov	edx,offset LineBuffer
 00001995  E8 000018A6			call	StringPrint
 0000199A  BA 00000ADE R		mov	edx,offset CarriageReturn
 0000199F  E8 0000189C			call	StringPrint
					;
 000019A4  BA 00003703 R		mov	edx,offset NewEntryEIPT
 000019A9  E8 00001892			call	StringPrint
 000019AE  BE 00000B4E R		mov	esi,offset NewHeader
 000019B3  8B 46 14			mov	eax,[esi].NewHeaderStruc.NewEntryEIP
 000019B6  B9 00000008			mov	ecx,8
 000019BB  BF 00000180 R		mov	edi,offset LineBuffer
 000019C0  E8 00000412			call	Bin2Hex
 000019C5  C6 07 00			mov	b[edi],0
 000019C8  BA 00000180 R		mov	edx,offset LineBuffer
 000019CD  E8 0000186E			call	StringPrint
 000019D2  BA 00000ADE R		mov	edx,offset CarriageReturn
 000019D7  E8 00001864			call	StringPrint
					;
 000019DC  BA 00003711 R		mov	edx,offset NewEntryCSt
 000019E1  E8 0000185A			call	StringPrint
 000019E6  BE 00000B4E R		mov	esi,offset NewHeader
 000019EB  0F B7 46 18			movzx	eax,[esi].NewHeaderStruc.NewEntryCS
 000019EF  B9 00000008			mov	ecx,8
 000019F4  BF 00000180 R		mov	edi,offset LineBuffer
 000019F9  E8 000003D9			call	Bin2Hex
 000019FE  C6 07 00			mov	b[edi],0
 00001A01  BA 00000180 R		mov	edx,offset LineBuffer
 00001A06  E8 00001835			call	StringPrint
 00001A0B  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001A10  E8 0000182B			call	StringPrint
					;
 00001A15  BA 0000371F R		mov	edx,offset NewEntryESPt
 00001A1A  E8 00001821			call	StringPrint
 00001A1F  BE 00000B4E R		mov	esi,offset NewHeader
 00001A24  8B 46 1A			mov	eax,[esi].NewHeaderStruc.NewEntryESP
 00001A27  B9 00000008			mov	ecx,8
 00001A2C  BF 00000180 R		mov	edi,offset LineBuffer
 00001A31  E8 000003A1			call	Bin2Hex
 00001A36  C6 07 00			mov	b[edi],0
 00001A39  BA 00000180 R		mov	edx,offset LineBuffer
 00001A3E  E8 000017FD			call	StringPrint
 00001A43  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001A48  E8 000017F3			call	StringPrint
					;
 00001A4D  BA 0000372D R		mov	edx,offset NewEntrySSt
 00001A52  E8 000017E9			call	StringPrint
 00001A57  BE 00000B4E R		mov	esi,offset NewHeader
 00001A5C  0F B7 46 1E			movzx	eax,[esi].NewHeaderStruc.NewEntrySS
 00001A60  B9 00000008			mov	ecx,8
 00001A65  BF 00000180 R		mov	edi,offset LineBuffer
 00001A6A  E8 00000368			call	Bin2Hex
 00001A6F  C6 07 00			mov	b[edi],0
 00001A72  BA 00000180 R		mov	edx,offset LineBuffer
 00001A77  E8 000017C4			call	StringPrint
 00001A7C  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001A81  E8 000017BA			call	StringPrint
					;
 00001A86  BA 0000373B R		mov	edx,offset NewEntryAutoSS
 00001A8B  E8 000017B0			call	StringPrint
 00001A90  BE 00000B4E R		mov	esi,offset NewHeader
 00001A95  8B 46 24			mov	eax,[esi].NewHeaderStruc.NewAutoStack
 00001A98  B9 00000008			mov	ecx,8
 00001A9D  BF 00000180 R		mov	edi,offset LineBuffer
 00001AA2  E8 00000330			call	Bin2Hex
 00001AA7  C6 07 00			mov	b[edi],0
 00001AAA  BA 00000180 R		mov	edx,offset LineBuffer
 00001AAF  E8 0000178C			call	StringPrint
 00001AB4  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001AB9  E8 00001782			call	StringPrint
					;
					;See if segment/relocation details are required.
					;
 00001ABE  8B 35 00003B20 R		mov	esi,d[OptionTable+128+("I"*4)]
 00001AC4  0B F6			or	esi,esi
 00001AC6  0F 84 00000301		jz	@@8
					;
 00001ACC  BA 00003749 R		mov	edx,offset ReadingMainText
 00001AD1  E8 0000176A			call	StringPrint
					;
					;Get segment definition table memory.
					;
 00001AD6  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 00001ADF  BE 00000B4E R		mov	esi,offset NewHeader
				
				;	movzx	ebx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
				;	shl	ebx,3		;8 bytes per entry.
				;	sys	GetMemNear
 00001AE4  0F B7 4E 0E			movzx	ecx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
 00001AE8  C1 E1 03			shl	ecx,3		;8 bytes per entry.
 00001AEB  E8 0000139C			call	GetMemLinear32
 00001AF0  0F 82 000002E0		jc	@@9
 00001AF6  89 35 00000B17 R		mov	SegmentList,esi
					;
					;Read segment definitions.
					;
 00001AFC  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001B05  BE 00000B4E R		mov	esi,offset NewHeader
 00001B0A  0F B7 4E 0E			movzx	ecx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
 00001B0E  C1 E1 03			shl	ecx,3		;8 bytes per entry.
 00001B11  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001B18  8B 3D 00000B17 R		mov	edi,SegmentList
 00001B1E  51				push	ecx
 00001B1F  E8 0000156D			call	ReadFile
 00001B24  59				pop	ecx
 00001B25  0F 82 000002AB		jc	@@9
 00001B2B  3B C1			cmp	eax,ecx
 00001B2D  0F 85 000002A3		jnz	@@9
					;
					;Get relocation table memory.
					;
 00001B33  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 00001B3C  BE 00000B4E R		mov	esi,offset NewHeader
				
				;	mov	ebx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations
				;	shl	ebx,2		;4 bytes per entry.
				;	sys	GetMemNear
 00001B41  8B 4E 10			mov	ecx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations
 00001B44  C1 E1 02			shl	ecx,2		;4 bytes per entry.
 00001B47  E8 00001340			call	GetMemLinear32
 00001B4C  0F 82 00000284		jc	@@9
 00001B52  89 35 00000B27 R		mov	RelocSegment,esi
					;
					;Read relocations.
					;
 00001B58  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001B61  BE 00000B4E R		mov	esi,offset NewHeader
 00001B66  8B 4E 10			mov	ecx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations.
 00001B69  C1 E1 02			shl	ecx,2		;4 bytes per entry.
 00001B6C  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001B73  8B 3D 00000B27 R		mov	edi,RelocSegment
 00001B79  51				push	ecx
 00001B7A  E8 00001512			call	ReadFile
 00001B7F  59				pop	ecx
 00001B80  0F 82 00000250		jc	@@9
 00001B86  3B C1			cmp	eax,ecx
 00001B88  0F 85 00000248		jnz	@@9
					;
					;Get image memory.
					;
 00001B8E  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 00001B97  BE 00000B4E R		mov	esi,offset NewHeader
				
				;	mov	ebx,[esi].NewHeaderStruc.NewAlloc	;get memory size required.
				;	sys	GetMemNear
 00001B9C  8B 4E 0A			mov	ecx,[esi].NewHeaderStruc.NewAlloc	;get memory size required.
 00001B9F  E8 000012E8			call	GetMemLinear32
 00001BA4  0F 82 0000022C		jc	@@9
 00001BAA  89 35 00000B23 R		mov	EXESegment,esi
					;
 00001BB0  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001BB9  BE 00000B4E R		mov	esi,offset NewHeader
				if 0
				endif    
 00001BBE			@@NotComp:
 00001BBE  8B 3D 00000B23 R		mov	edi,EXESegment
 00001BC4  8B 4E 06			mov	ecx,[esi].NewHeaderStruc.NewLength	;get image length.
 00001BC7  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001BCE  51				push	ecx
 00001BCF  E8 000014BD			call	ReadFile		;read the file.
 00001BD4  59				pop	ecx
 00001BD5  0F 82 000001FB		jc	@@9		;problems problems.
 00001BDB  3B C1			cmp	eax,ecx		;did we get right amount?
 00001BDD  0F 85 000001F3		jnz	@@9
					;
 00001BE3			@@ImageLoaded:
 00001BE3  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001BEA  E8 00001516			call	CloseFile
 00001BEF  66| C7 05			mov	EXEHandle,0
	   00000B00 R
	   0000
					;
					;Check if seg details needed.
					;
 00001BF8  8B 35 00003B20 R		mov	esi,d[OptionTable+128+("I"*4)]
 00001BFE			@@5:
 00001BFE  AC				lodsb
 00001BFF  0A C0			or	al,al
 00001C01  0F 84 000000B3		jz	@@6
 00001C07  E8 00001275			call	UpperChar
 00001C0C  3C 53			cmp	al,"S"
 00001C0E  75 EE			jnz	@@5
					;
					;Display header.
					;
 00001C10  BA 0000377B R		mov	edx,offset SegmentStuff
 00001C15  E8 00001626			call	StringPrint
					;
					;Display details.
					;
 00001C1A  BE 00000B4E R		mov	esi,offset NewHeader
 00001C1F  0F B7 4E 0E			movzx	ecx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
 00001C23  8B 35 00000B17 R		mov	esi,SegmentList
 00001C29  33 C0			xor	eax,eax
 00001C2B			@@0:
 00001C2B  50				push	eax
					pushm	ecx,esi
 00001C2C  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001C2D  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001C2E  BF 00000180 R		mov	edi,offset LineBuffer
 00001C33  B9 00000004			mov	ecx,4
 00001C38  E8 0000019A			call	Bin2Hex
 00001C3D  C6 07 20			mov	b[edi],' '
 00001C40  47				inc	edi
 00001C41  8B 06			mov	eax,0[esi]
 00001C43  B9 00000008			mov	ecx,8
 00001C48  E8 0000018A			call	Bin2Hex
 00001C4D  C6 07 20			mov	b[edi],' '
 00001C50  47				inc	edi
					popm	ecx,esi
 00001C51  5E		     2		POP	esi				;POP THE REGISTER
 00001C52  59		     2		POP	ecx				;POP THE REGISTER
					pushm	ecx,esi
 00001C53  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001C54  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001C55  8B 46 04			mov	eax,4[esi]
 00001C58  25 000FFFFF			and	eax,0fffffh		;mask to 20 bits.
 00001C5D  F7 46 04			test	d[esi+4],1 shl 20	;G bit set?
	   00100000
 00001C64  74 08			jz	@@1
 00001C66  C1 E0 0C			shl	eax,12
 00001C69  0D 00000FFF			or	eax,4095
 00001C6E			@@1:
 00001C6E  B9 00000008			mov	ecx,8
 00001C73  E8 0000015F			call	Bin2Hex
 00001C78  C6 07 20			mov	b[edi],' '
 00001C7B  C6 47 01 00			mov	b[edi+1],0
 00001C7F  BA 00000180 R		mov	edx,offset LineBuffer
 00001C84  E8 000015B7			call	StringPrint
					popm	ecx,esi
 00001C89  5E		     2		POP	esi				;POP THE REGISTER
 00001C8A  59		     2		POP	ecx				;POP THE REGISTER
					pushm	ecx,esi
 00001C8B  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001C8C  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001C8D  8B 46 04			mov	eax,4[esi]
 00001C90  C1 E8 15			shr	eax,21		;move type into useful place.
 00001C93  83 E0 0F			and	eax,0fh		;isolate type.
 00001C96  8B 14 85			mov	edx,[SegClassList][eax*4]
	   00000E28 R
 00001C9D  E8 0000159E			call	StringPrint
 00001CA2  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001CA7  E8 00001594			call	StringPrint
					;
					popm	ecx,esi
 00001CAC  5E		     2		POP	esi				;POP THE REGISTER
 00001CAD  59		     2		POP	ecx				;POP THE REGISTER
 00001CAE  58				pop	eax
 00001CAF  40				inc	eax
 00001CB0  83 C6 08			add	esi,8
 00001CB3  49				dec	ecx
 00001CB4  0F 85 FFFFFF71		jnz	@@0
					;
					;See if relocation details are needed.
					;
 00001CBA			@@6:
 00001CBA  8B 35 00003B20 R		mov	esi,d[OptionTable+128+("I"*4)]
 00001CC0			@@7:
 00001CC0  AC				lodsb
 00001CC1  0A C0			or	al,al
 00001CC3  0F 84 00000104		jz	@@8
 00001CC9  E8 000011B3			call	UpperChar
 00001CCE  3C 52			cmp	al,"R"
 00001CD0  75 EE			jnz	@@7
					;
					;Display header.
					;
 00001CD2  BA 000037F8 R		mov	edx,offset RelocStuff
 00001CD7  E8 00001564			call	StringPrint
					;
					;Display details.
					;
 00001CDC  BE 00000B4E R		mov	esi,offset NewHeader
 00001CE1  8B 4E 10			mov	ecx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations.
 00001CE4  8B 35 00000B27 R		mov	esi,RelocSegment
 00001CEA  33 C0			xor	eax,eax
 00001CEC			@@2:
 00001CEC  50				push	eax
					pushm	ecx,esi
 00001CED  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001CEE  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001CEF  BF 00000180 R		mov	edi,offset LineBuffer
 00001CF4  B9 00000004			mov	ecx,4
 00001CF9  E8 000000D9			call	Bin2Hex
 00001CFE  C6 07 20			mov	b[edi],' '
 00001D01  47				inc	edi
 00001D02  8B 06			mov	eax,[esi]
 00001D04  C1 E8 1C			shr	eax,28
 00001D07  04 30			add	al,"0"
 00001D09  88 07			mov	b[edi],al
 00001D0B  47				inc	edi
 00001D0C  C6 07 20			mov	b[edi]," "
 00001D0F  47				inc	edi
 00001D10  8B 06			mov	eax,[esi]
 00001D12  25 0FFFFFFF			and	eax,0FFFFFFFh
 00001D17  B9 00000008			mov	ecx,8
 00001D1C  E8 000000B6			call	Bin2Hex
 00001D21  C6 07 20			mov	b[edi],' '
 00001D24  47				inc	edi
 00001D25  C6 07 20			mov	b[edi],' '
 00001D28  47				inc	edi
 00001D29  C6 07 20			mov	b[edi],' '
 00001D2C  47				inc	edi
					popm	ecx,esi
 00001D2D  5E		     2		POP	esi				;POP THE REGISTER
 00001D2E  59		     2		POP	ecx				;POP THE REGISTER
					pushm	ecx,esi
 00001D2F  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001D30  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001D31  8B 36			mov	esi,[esi]
 00001D33  8B C6			mov	eax,esi
 00001D35  C1 E8 1C			shr	eax,28
 00001D38  81 E6 0FFFFFFF		and	esi,0FFFFFFFh
 00001D3E  BB 00000B4E R		mov	ebx,offset NewHeader
 00001D43  3B 73 06			cmp	esi,[ebx].NewHeaderStruc.NewLength	;check against image size.
 00001D46  72 09			jc	@@3
 00001D48			@@RelInv:
 00001D48  BE 00003865 R		mov	esi,offset invalidtext
 00001D4D  A5				movsd
 00001D4E  A5				movsd
 00001D4F  EB 57			jmp	@@4
					;
 00001D51			@@3:
 00001D51  03 35 00000B23 R		add	esi,EXESegment
 00001D57  0B C0			or	eax,eax
 00001D59  74 21			jz	@@Seg16
 00001D5B  48				dec	eax
 00001D5C  74 02			jz	@@Offset32
 00001D5E  EB E8			jmp	@@RelInv
					;
 00001D60			@@Offset32:
 00001D60  8B 06			mov	eax,[esi]
 00001D62  B9 00000008			mov	ecx,8
 00001D67  E8 0000006B			call	Bin2Hex
 00001D6C  C7 07 20202020		mov	d[edi],"    "
 00001D72  83 C7 04			add	edi,4
 00001D75  3B 43 06			cmp	eax,[ebx].NewHeaderStruc.NewLength	;check against image size.
 00001D78  73 CE			jnc	@@RelInv
 00001D7A  EB 2C			jmp	@@4
					;
 00001D7C			@@Seg16:
 00001D7C  0F B7 06			movzx	eax,w[esi]
 00001D7F  66| 50			push	ax
 00001D81  B9 00000008			mov	ecx,8
 00001D86  E8 0000004C			call	Bin2Hex
 00001D8B  C7 07 20202020		mov	d[edi],"    "
 00001D91  83 C7 04			add	edi,4
 00001D94  66| 58			pop	ax
 00001D96  BB 00000B4E R		mov	ebx,offset NewHeader
 00001D9B  66| 3B 43 0E			cmp	ax,[ebx].NewHeaderStruc.NewSegments
 00001D9F  72 07			jc	@@4
 00001DA1  BE 00003865 R		mov	esi,offset invalidtext
 00001DA6  A5				movsd
 00001DA7  A5				movsd
					;
 00001DA8			@@4:
 00001DA8  C6 07 00			mov	b[edi],0
 00001DAB  BA 00000180 R		mov	edx,offset LineBuffer
 00001DB0  E8 0000148B			call	StringPrint
 00001DB5  BA 00000ADE R		mov	edx,offset CarriageReturn
 00001DBA  E8 00001481			call	StringPrint
					;
					popm	ecx,esi
 00001DBF  5E		     2		POP	esi				;POP THE REGISTER
 00001DC0  59		     2		POP	ecx				;POP THE REGISTER
 00001DC1  58				pop	eax
 00001DC2  40				inc	eax
 00001DC3  83 C6 04			add	esi,4
 00001DC6  49				dec	ecx
 00001DC7  0F 85 FFFFFF1F		jnz	@@2
					;
 00001DCD			@@8:
 00001DCD  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 00001DD6			@@9:
 00001DD6  C3				ret
 00001DD7			NewExeInfo	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=-=
 00001DD7			Bin2Hex	proc	near
				;
				;Convert number into ASCII Hex version.
				;
				;On Entry:-
				;
				;EAX	- Number to convert.
				;ECX	- Digits to do.
				;EDI	- Buffer to put string in.
				;
					pushm	edi,ecx
 00001DD7  57		     2		PUSH	edi			;SAVE THE REGISTER
 00001DD8  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00001DD9  BB 00001DF5 R		mov	ebx,offset HexTable
 00001DDE  03 F9			add	edi,ecx
 00001DE0  4F				dec	edi
 00001DE1  8B D0			mov	edx,eax
 00001DE3  8A C2		@@0:	mov	al,dl
 00001DE5  C1 EA 04			shr	edx,4
 00001DE8  24 0F			and	al,15
 00001DEA  D7				xlat
 00001DEB  88 07			mov	[edi],al
 00001DED  4F				dec	edi
 00001DEE  E2 F3			loop	@@0
					popm	edi,ecx
 00001DF0  59		     2		POP	ecx				;POP THE REGISTER
 00001DF1  5F		     2		POP	edi				;POP THE REGISTER
 00001DF2  03 F9			add	edi,ecx
 00001DF4  C3				ret
 00001DF5 30 31 32 33 34	HexTable	db '0123456789ABCDEF'
	   35 36 37 38 39
	   41 42 43 44 45
	   46
 00001E05			Bin2Hex	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
 00001E05			ProcessFile	proc	near
				;
				;Generate new style relocation table and write new .EXE file.
				;
					@dprintf 1,<"ProcessFile start",10>
 00001E05  E8 FFFFE258	     1		call dprintf
 00001E0A  50 72 6F 63 65    1		db "ProcessFile start",10,0
	   73 73 46 69 6C
	   65 20 73 74 61
	   72 74 0A 00
 00001E1D  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00001E24  E8 000012DC			call	CloseFile
 00001E29  BA 00000100 R		mov	edx,offset EXEFileName
 00001E2E  E8 000011E8			call	OpenFile		;Open the .EXE file.
 00001E33  66| C7 05			mov	ErrorNumber,6	;default to not found.
	   00000004 R
	   0006
 00001E3C  0F 82 00000715		jc	@@9
 00001E42  66| A3			mov	EXEHandle,ax
	   00000B00 R
					;
					;Create temp file.
					;
 00001E48  BA 00000B08 R		mov	edx,offset TempFileName	;get DOS to give us a temp file.
 00001E4D  E8 000011FC			call	CreateFile
 00001E52  66| C7 05			mov	ErrorNumber,19	;default to can't create output.
	   00000004 R
	   0013
 00001E5B  0F 82 000006F6		jc	@@9		;oops.
 00001E61  66| A3			mov	TempHandle,ax
	   00000B15 R
					;
					;Copy 386SHELL to temp file.
					;
 00001E67  80 3D 000039BE R		cmp	OptionTable+'B',0
	   00
 00001E6E  0F 84 000001D8		jz	@@NoBind
					;
 00001E74  BA 00000080 R		mov	edx,offset SHELLFileName	;get extender stub CWSTUB.EXE
 00001E79  E8 0000119D			call	OpenFile
 00001E7E  66| C7 05			mov	ErrorNumber,9	;no stub file.
	   00000004 R
	   0009
 00001E87  0F 82 000006CA		jc	@@9
 00001E8D  66| A3			mov	SHELLHandle,ax
	   00000AFA R
					;
 00001E93  BA 00000A62 R		mov	edx,offset ProcessStubText
 00001E98  E8 000013A3			call	StringPrint
					;
 00001E9D  BA 00000B2B R		mov	edx,offset exehdr
 00001EA2  B9 0000001B			mov	ecx,sizeof MZHdr
 00001EA7  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 00001EAE  B4 3F			mov	ah,3fh
 00001EB0  CD 21			int	21h		;read the .EXE header.
 00001EB2  66| C7 05			mov	ErrorNumber,8	;default to IO error.
	   00000004 R
	   0008
 00001EBB  0F 82 00000696		jc	@@9
 00001EC1  66| C7 05			mov	ErrorNumber,9	;stub file error.
	   00000004 R
	   0009
 00001ECA  66| 83 F8 1B			cmp	ax,sizeof MZHdr
 00001ECE  0F 85 00000683		jnz	@@9
 00001ED4  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Correct ID?
	   00000B2B R
	   5A4D
 00001EDD  0F 85 00000674		jnz	@@9
					@dprintf 1,<"ProcessFile - stub file exists and has correct header",10>
 00001EE3  E8 FFFFE17A	     1		call dprintf
 00001EE8  50 72 6F 63 65    1		db "ProcessFile - stub file exists and has correct header",10,0
	   73 73 46 69 6C
	   65 20 2D 20 73
	   74 75 62 20 66
	   69 6C 65 20 65
	   78 69 73 74 73
	   20 61 6E 64 20
	   68 61 73 20 63
	   6F 72 72 65 63
	   74 20 68 65 61
	   64 65 72 0A 00
					;
 00001F1F  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 00001F25  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 00001F2D  74 02			je	medexe8		; not rounded if no modulo
				
 00001F2F  66| 48			dec	ax		;lose 1 cos its rounded up
				
 00001F31			medexe8:
 00001F31  66| 03 C0			add	ax,ax		;mult by 2
 00001F34  B6 00			mov	dh,0
 00001F36  8A D4			mov	dl,ah
 00001F38  8A E0			mov	ah,al
 00001F3A  8A C6			mov	al,dh		;mult by 256=*512
 00001F3C  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 00001F43  66| 83 D2 00			adc	dx,0		;add any carry to dx
 00001F47  66| 8B C8			mov	cx,ax
					pushm	cx,dx
 00001F4A  66| 51	     2		PUSH	cx			;SAVE THE REGISTER
 00001F4C  66| 52	     2		PUSH	dx			;SAVE THE REGISTER
 00001F4E  66| BA FFE5			mov	dx,-1bh
 00001F52  66| B9 FFFF			mov	cx,-1
 00001F56  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 00001F5D  66| B8 4201			mov	ax,4201h
 00001F61  CD 21			int	21h		;move back to start of 386SHELL.
					popm	cx,dx
 00001F63  66| 5A	     2		POP	dx				;POP THE REGISTER
 00001F65  66| 59	     2		POP	cx				;POP THE REGISTER
					;
					;Get memory for shell.
					;
 00001F67  8B DA			mov	ebx,edx
 00001F69  C1 E3 10			shl	ebx,16
 00001F6C  66| 8B D9			mov	bx,cx
				
				;	push	ebx
				;	sys	GetMemNear		;get memory for shell.
				;	pop	ebx
 00001F6F  8B CB			mov	ecx,ebx
 00001F71  E8 00000F16			call	GetMemLinear32
 00001F76  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 00001F7F  0F 82 000005D2		jc	@@9
					@dprintf 1,<"ProcessFile - memory alloc ok",10>
 00001F85  E8 FFFFE0D8	     1		call dprintf
 00001F8A  50 72 6F 63 65    1		db "ProcessFile - memory alloc ok",10,0
	   73 73 46 69 6C
	   65 20 2D 20 6D
	   65 6D 6F 72 79
	   20 61 6C 6C 6F
	   63 20 6F 6B 0A
	   00
					;
					;Read shell into memory.
					;
					pushm	ebx,esi
 00001FA9  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001FAA  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001FAB  8B CB			mov	ecx,ebx
 00001FAD  8B FE			mov	edi,esi
 00001FAF  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 00001FB6  E8 000010D6			call	ReadFile
					popm	ebx,esi
 00001FBB  5E		     2		POP	esi				;POP THE REGISTER
 00001FBC  5B		     2		POP	ebx				;POP THE REGISTER
 00001FBD  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00001FC6  0F 82 0000058B		jc	@@9
 00001FCC  3B C3			cmp	eax,ebx		;did we read enough?
 00001FCE  0F 85 00000583		jnz	@@9
					@dprintf 1,<"ProcessFile - stub read ok",10>
 00001FD4  E8 FFFFE089	     1		call dprintf
 00001FD9  50 72 6F 63 65    1		db "ProcessFile - stub read ok",10,0
	   73 73 46 69 6C
	   65 20 2D 20 73
	   74 75 62 20 72
	   65 61 64 20 6F
	   6B 0A 00
					pushm	ebx,esi
 00001FF5  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001FF6  56		     2		PUSH	esi			;SAVE THE REGISTER
					;
					;Write shell to temp.
					;
					popm	ebx,esi
 00001FF7  5E		     2		POP	esi				;POP THE REGISTER
 00001FF8  5B		     2		POP	ebx				;POP THE REGISTER
					pushm	ebx,esi
 00001FF9  53		     2		PUSH	ebx			;SAVE THE REGISTER
 00001FFA  56		     2		PUSH	esi			;SAVE THE REGISTER
 00001FFB  8B CB			mov	ecx,ebx
 00001FFD  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 00002004  E8 000010C2			call	WriteFile
					popm	ebx,esi
 00002009  5E		     2		POP	esi				;POP THE REGISTER
 0000200A  5B		     2		POP	ebx				;POP THE REGISTER
 0000200B  0F 82 00000546		jc	@@9
 00002011  3B C3			cmp	eax,ebx		;did we write enough?
 00002013  0F 85 0000053E		jnz	@@9
				;	sys	RelMemNear		;release memory now.
 00002019  E8 00000E8B			call	RelMemLinear32
					@dprintf 1,<"ProcessFile - stub write to tmp file ok",10>
 0000201E  E8 FFFFE03F	     1		call dprintf
 00002023  50 72 6F 63 65    1		db "ProcessFile - stub write to tmp file ok",10,0
	   73 73 46 69 6C
	   65 20 2D 20 73
	   74 75 62 20 77
	   72 69 74 65 20
	   74 6F 20 74 6D
	   70 20 66 69 6C
	   65 20 6F 6B 0A
	   00
				
					;
 0000204C			@@NoBind:	;Process .EXE relocation table and produce new format header.
					;
 0000204C  BA 00000B2B R		mov	edx,offset exehdr
 00002051  B9 0000001B			mov	ecx,sizeof MZHdr
 00002056  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 0000205D  B4 3F			mov	ah,3fh
 0000205F  CD 21			int	21h		;read the .EXE header.
 00002061  66| C7 05			mov	ErrorNumber,8	;default to IO error.
	   00000004 R
	   0008
 0000206A  0F 82 000004E7		jc	@@9
 00002070  66| C7 05			mov	ErrorNumber,7	;bad header.
	   00000004 R
	   0007
 00002079  66| 83 F8 1B			cmp	ax,sizeof MZHdr
 0000207D  0F 85 000004D4		jnz	@@9
 00002083  66| 81 3D			cmp	exehdr.Signature,'ZM'	;Correct ID?
	   00000B2B R
	   5A4D
 0000208C  0F 85 000004C5		jnz	@@9
				
					@dprintf 1,<"ProcessFile - .exe read ok",10>
 00002092  E8 FFFFDFCB	     1		call dprintf
 00002097  50 72 6F 63 65    1		db "ProcessFile - .exe read ok",10,0
	   73 73 46 69 6C
	   65 20 2D 20 2E
	   65 78 65 20 72
	   65 61 64 20 6F
	   6B 0A 00
					;
					;Get header size in bytes.
					;
 000020B3  66| 8B 1D			mov	bx,exehdr.HeaderSize	;Work out header size.
	   00000B33 R
 000020BA  66| 33 C9			xor	cx,cx		;/
 000020BD  66| 03 DB			add	bx,bx		;/
 000020C0  66| 83 D1 00			adc	cx,0		;/
 000020C4  66| 03 DB			add	bx,bx		;/
 000020C7  66| 83 D1 00			adc	cx,0		;/
 000020CB  66| 03 DB			add	bx,bx		;/
 000020CE  66| 83 D1 00			adc	cx,0		;/
 000020D2  66| 03 DB			add	bx,bx		;/
 000020D5  66| 83 D1 00			adc	cx,0		;/
 000020D9  66| 89 1D			mov	w[ExeSize1],bx	;/
	   00000B46 R
 000020E0  66| 89 0D			mov	w[ExeSize1+2],cx	;/
	   00000B48 R
					;
					;Get exe image size in bytes.
					;
 000020E7  66| A1			mov	ax,exehdr._Length+2	;get length in 512 byte blocks
	   00000B2F R
 000020ED  66| 83 3D			cmp	exehdr._Length,0
	   00000B2D R 00
 000020F5  74 02			je	medexe9		; not rounded if no modulo
				
 000020F7  66| 48			dec	ax		;lose 1 cos its rounded up
				
 000020F9			medexe9:
 000020F9  66| 03 C0			add	ax,ax		;mult by 2
 000020FC  B6 00			mov	dh,0
 000020FE  8A D4			mov	dl,ah
 00002100  8A E0			mov	ah,al
 00002102  8A C6			mov	al,dh		;mult by 256=*512
 00002104  66| 03 05			add	ax,exehdr._Length	;add length mod 512
	   00000B2D R
 0000210B  66| 83 D2 00			adc	dx,0		;add any carry to dx
 0000210F  66| 2B C3			sub	ax,bx		;remove header total size.
 00002112  66| 1B D1			sbb	dx,cx		;/
 00002115  66| A3			mov	w[ExeSize2],ax	;/
	   00000B4A R
 0000211B  66| 89 15			mov	w[ExeSize2+2],dx	;/
	   00000B4C R
					;
 00002122  C1 E2 10			shl	edx,16
 00002125  66| 8B D0			mov	dx,ax
 00002128  BE 00000B4E R		mov	esi,offset NewHeader
 0000212D  89 56 06			mov	[esi].NewHeaderStruc.NewLength,edx	;store EXE image length in the header.
 00002130  A1 00000B1F R		mov	eax,SegmentTotal
 00002135  66| 89 46 0E			mov	[esi].NewHeaderStruc.NewSegments,ax
 00002139  0F B7 05			movzx	eax,exehdr.RelocNum
	   00000B31 R
 00002140  89 46 10			mov	[esi].NewHeaderStruc.NewRelocs,eax
					;
 00002143  0F B7 05			movzx	eax,exehdr.EntryIP
	   00000B3F R
 0000214A  89 46 14			mov	[esi].NewHeaderStruc.NewEntryEIP,eax	;setup entry offset.
					;
 0000214D  80 3D 000039D6 R		cmp	OptionTable+'Z',0
	   00
 00002154  74 09			jz	@@NormStack
 00002156  80 3D 000039CA R		cmp	OptionTable+'N',0
	   00
 0000215D  75 0A			jnz	@@GotStackNear
 0000215F			@@NormStack:
 0000215F  0F B7 05			movzx	eax,exehdr.EntrySP
	   00000B3B R
 00002166  89 46 1A			mov	[esi].NewHeaderStruc.NewEntryESP,eax	;setup ESP offset.
 00002169			@@GotStackNear: ;
 00002169  0F B7 05			movzx	eax,exehdr.EntryCS	;get entry CS.
	   00000B41 R
 00002170  8B 3D 00000B17 R		mov	edi,SegmentList	;make segment details addressable.
 00002176  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;get number of entries to check.
 0000217C  66| 33 D2			xor	dx,dx		;reset entry number.
 0000217F  80 3D 000039CA R		cmp	OptionTable+'N',0
	   00
 00002186  74 05			jz	@@4
 00002188  83 C7 10			add	edi,16
 0000218B  66| 42			inc	dx
 0000218D			@@4:
 0000218D  8B 1F			mov	ebx,[edi+0]		;get segment base.
 0000218F  C1 EB 04			shr	ebx,4		;convert to paragraph.
 00002192  3B C3			cmp	eax,ebx		;this the one we're after?
 00002194  74 10			jz	@@5
 00002196  83 C7 10			add	edi,16
 00002199  66| 42			inc	dx		;update entry counter.
 0000219B  E2 F0			loop	@@4
 0000219D  66| 33 D2			xor	dx,dx		;reset to zero.
 000021A0  8B 3D 00000B17 R		mov	edi,SegmentList	;/
 000021A6			@@5:
 000021A6  66| 89 56 18			mov	[esi].NewHeaderStruc.NewEntryCS,dx	;store segment entry number.
 000021AA  66| C7 05			mov	ErrorNumber,20
	   00000004 R
	   0014
 000021B3  66| 83 7F 08			cmp	w[edi+8],0
	   00
 000021B8  0F 85 00000399		jnz	@@9		;entry point is not in a code segment.
					;
 000021BE  80 3D 000039D6 R		cmp	OptionTable+'Z',0
	   00
 000021C5  74 09			jz	@@NormStack2
 000021C7  80 3D 000039CA R		cmp	OptionTable+'N',0
	   00
 000021CE  75 51			jnz	@@10
 000021D0			@@NormStack2:	;
 000021D0  0F B7 05			movzx	eax,exehdr.StackSeg	;get entry SS.
	   00000B39 R
 000021D7  8B 3D 00000B17 R		mov	edi,SegmentList	;make segment details addressable.
 000021DD  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;get number of entries to check.
 000021E3  66| 33 D2			xor	dx,dx		;reset entry number.
 000021E6			@@6:
 000021E6  66| 83 7F 08			cmp	w[edi+8],2		;stack segment?
	   02
 000021EB  75 09			jnz	@@6_0
 000021ED  8B 1F			mov	ebx,[edi+0]		;get segment base.
 000021EF  C1 EB 04			shr	ebx,4		;convert to paragraph.
 000021F2  3B C3			cmp	eax,ebx		;this the one we're after?
 000021F4  74 1F			jz	@@7
 000021F6			@@6_0:
 000021F6  83 C7 10			add	edi,16
 000021F9  66| 42			inc	dx		;update entry counter.
 000021FB  E2 E9			loop	@@6
					;
 000021FD  66| 83 3D			cmp	exehdr.EntrySP,0
	   00000B3B R 00
 00002205  74 14			jz	@@8
 00002207  66| C7 05			mov	ErrorNumber,25	;force an error.
	   00000004 R
	   0019
 00002210  E9 00000342			jmp	@@9
 00002215			@@7:
 00002215  66| 89 56 1E			mov	[esi].NewHeaderStruc.NewEntrySS,dx	;store segment entry number.
 00002219  EB 06			jmp	@@10
 0000221B			@@8:
 0000221B  66| C7 46 1E			mov	[esi].NewHeaderStruc.NewEntrySS,0
	   0000
					;
 00002221			@@10:	;Get some memory for the relocation table.
					;
 00002221  BA 00000A99 R		mov	edx,offset ProcessExeText	;let user know whats happening.
 00002226  E8 00001015			call	StringPrint
					;
				
				;	movzx	ebx,exehdr.RelocNum	;get number of relocation items.
				;	or	ebx,ebx
				;	jz	@@NoRelocMem
				;	shl	ebx,2
				;	sys	GetMemNear
 0000222B  0F B7 0D			movzx	ecx,exehdr.RelocNum	;get number of relocation items.
	   00000B31 R
 00002232  85 C9			test	ecx,ecx
 00002234  0F 84 00000084		jz	@@NoRelocMem
 0000223A  C1 E1 02			shl	ecx,2
 0000223D  E8 00000C4A			call	GetMemLinear32
 00002242  66| C7 05			mov	ErrorNumber,2	;not enough memory.
	   00000004 R
	   0002
 0000224B  0F 82 00000306		jc	@@9
 00002251  89 35 00000B27 R		mov	RelocSegment,esi	;stow the memory address.
					;
 00002257  66| 8B 15			mov	dx,exehdr.RelocFirst
	   00000B43 R
 0000225E  66| B9 0000			mov	cx,0
 00002262  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00002269  66| B8 4200			mov	ax,4200h
 0000226D  CD 21			int	21h		;move to relocation table.
					;
 0000226F  0F B7 0D			movzx	ecx,exehdr.RelocNum
	   00000B31 R
 00002276  C1 E1 02			shl	ecx,2
 00002279  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00002280  8B 3D 00000B27 R		mov	edi,RelocSegment
 00002286  E8 00000E06			call	ReadFile		;read the relocation table.
 0000228B  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00002294  0F 82 000002BD		jc	@@9
					;
					;Convert relocation table to linear offsets.
					;
 0000229A  0F B7 0D			movzx	ecx,exehdr.RelocNum	;number of entries.
	   00000B31 R
 000022A1  8B 35 00000B27 R		mov	esi,RelocSegment	;list of relocations.
 000022A7			@@1:
					pushm	ecx,esi
 000022A7  51		     2		PUSH	ecx			;SAVE THE REGISTER
 000022A8  56		     2		PUSH	esi			;SAVE THE REGISTER
 000022A9  0F B7 46 02			movzx	eax,w[esi+2]		;get segment offset.
 000022AD  C1 E0 04			shl	eax,4		;make it linear.
 000022B0  0F B7 1E			movzx	ebx,w[esi+0]		;get offset.
 000022B3  03 C3			add	eax,ebx		;add in offset.
 000022B5  89 06			mov	d[esi],eax		;store linear offset.
					popm	ecx,esi
 000022B7  5E		     2		POP	esi				;POP THE REGISTER
 000022B8  59		     2		POP	ecx				;POP THE REGISTER
 000022B9  83 C6 04			add	esi,4
 000022BC  E2 E9			loop	@@1
					;
 000022BE			@@NoRelocMem:	;Get some memory for the exe image.
					;
				
				;	mov	ebx,d[ExeSize2]	;get exe image size.
				;	sys	GetMemNear
 000022BE  8B 0D 00000B4A R		mov	ecx,d[ExeSize2]	;get exe image size.
 000022C4  E8 00000BC3			call	GetMemLinear32
 000022C9  66| C7 05			mov	ErrorNumber,2
	   00000004 R
	   0002
 000022D2  0F 82 0000027F		jc	@@9
 000022D8  89 35 00000B23 R		mov	EXESegment,esi
					;
 000022DE  66| 8B 15			mov	dx,w[ExeSize1]	;get image file offset.
	   00000B46 R
 000022E5  66| 8B 0D			mov	cx,w[ExeSize1+2]
	   00000B48 R
 000022EC  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 000022F3  66| B8 4200			mov	ax,4200h
 000022F7  CD 21			int	21h		;move to start of exe image.
 000022F9  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00002302  0F 82 0000024F		jc	@@9
 00002308  8B 3D 00000B23 R		mov	edi,EXESegment
 0000230E  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 00002315  8B 0D 00000B4A R		mov	ecx,d[ExeSize2]
 0000231B  E8 00000D71			call	ReadFile		;read exe image into memory.
					;
 00002320  BA 00000ABC R		mov	edx,offset GenerateExeText
 00002325  E8 00000F16			call	StringPrint
					;
 0000232A  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 00002331  66| B9 0000			mov	cx,0
 00002335  66| BA 0000			mov	dx,0
 00002339  66| B8 4201			mov	ax,4201h
 0000233D  CD 21			int	21h
 0000233F  C1 E2 10			shl	edx,16
 00002342  66| 8B D0			mov	dx,ax
 00002345  89 15 0000386D R		mov	Real3POffset,edx
					;
					;Write main header.
					;
 0000234B  BA 00000B4E R		mov	edx,offset NewHeader	;write the header to make space.
 00002350  66| 8B 1D			mov	bx,TempHandle
	   00000B15 R
 00002357  66| B9 0040			mov	cx,size NewHeaderStruc
 0000235B  B4 40			mov	ah,40h
 0000235D  CD 21			int	21h
					;
					;Write segment definitions.
					;
 0000235F  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;get number to do.
 00002365  8B 35 00000B17 R		mov	esi,SegmentList	;the segment definitions.
 0000236B			@@0:
					pushm	ecx,esi
 0000236B  51		     2		PUSH	ecx			;SAVE THE REGISTER
 0000236C  56		     2		PUSH	esi			;SAVE THE REGISTER
 0000236D  8B 06			mov	eax,[esi+0]		;get the base.
 0000236F  A3 00000180 R		mov	d[LineBuffer],eax
 00002374  8B 46 04			mov	eax,[esi+4]		;get the limit.
 00002377  3D 00100000			cmp	eax,100000h
 0000237C  72 12			jc	@@Small
 0000237E  83 F8 FF			cmp	eax,-1
 00002381  74 05			jz	@@NoRoundUp
 00002383  05 00000FFF			add	eax,4095
 00002388			@@NoRoundUp:
 00002388  C1 E8 0C			shr	eax,12		;lose bottom bits.
 0000238B  0D 00100000			or	eax,1 shl 20		;Set our version of the G bit.
 00002390			@@Small:
 00002390  0F B7 5E 08			movzx	ebx,w[esi+8]		;get segment type.
 00002394  83 E3 0F			and	ebx,15		;allows same variety as real selectors.
 00002397  C1 E3 15			shl	ebx,21		;put it somewhere useful.
 0000239A  0B C3			or	eax,ebx
 0000239C  A3 00000184 R		mov	d[LineBuffer+4],eax	;stow it in the table.
 000023A1  BA 00000180 R		mov	edx,offset LineBuffer
 000023A6  66| B9 0008			mov	cx,8
 000023AA  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 000023B1  B4 40			mov	ah,40h
 000023B3  CD 21			int	21h		;write this entry.
					popm	ecx,esi
 000023B5  5E		     2		POP	esi				;POP THE REGISTER
 000023B6  59		     2		POP	ecx				;POP THE REGISTER
 000023B7  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 000023C0  0F 82 00000191		jc	@@9
 000023C6  66| 83 F8 08			cmp	ax,8
 000023CA  0F 85 00000187		jnz	@@9
 000023D0  83 C6 10			add	esi,16
 000023D3  E2 96			loop	@@0
					;
					;Write relocation table.
					;
 000023D5  0F B7 0D			movzx	ecx,exehdr.RelocNum	;number of entries.
	   00000B31 R
 000023DC  C1 E1 02			shl	ecx,2
 000023DF  8B 35 00000B27 R		mov	esi,RelocSegment	;where they are.
 000023E5  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 000023EC  E8 00000CDA			call	WriteFile
					;
					;Update exe image with real segment numbers.
					;
 000023F1  0F B7 0D			movzx	ecx,exehdr.RelocNum	;number of entries.
	   00000B31 R
 000023F8  E3 5A			jecxz	@@NoReloc
 000023FA  8B 35 00000B27 R		mov	esi,RelocSegment	;the relocations.
 00002400			@@3:
					pushm	ecx,esi
 00002400  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00002401  56		     2		PUSH	esi			;SAVE THE REGISTER
 00002402  8B 36			mov	esi,[esi]		;get relocation offset.
 00002404  03 35 00000B23 R		add	esi,ExeSegment	;offset into exe image.
 0000240A  0F B7 06			movzx	eax,w[esi]		;get value that needs relocating.
					;
 0000240D  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;number of segments to scan.
 00002413  8B 3D 00000B17 R		mov	edi,SegmentList	;list of segment definitions.
 00002419  33 D2			xor	edx,edx		;reset segment number.
 0000241B			@@30:
 0000241B  80 3D 000039CA R		cmp	OptionTable+'N',0	;check for flat mode.
	   00
 00002422  74 07			jz	@@NotFlat
 00002424  BA 00000000			mov	edx,0		;force to data referance.
 00002429  EB 1F			jmp	@@31
					;
 0000242B			@@NotFlat:
 0000242B  8B 1F			mov	ebx,[edi+0]		;get current segments base.
 0000242D  C1 EB 04			shr	ebx,4		;round it down.
 00002430  3B C3			cmp	eax,ebx
 00002432  74 16			jz	@@31
 00002434  83 C7 10			add	edi,16		;next segment definition.
 00002437  42				inc	edx		;update segment number.
 00002438  E2 E1			loop	@@30
 0000243A  66| C7 05			mov	ErrorNumber,23
	   00000004 R
	   0017
					popm	ecx,esi
 00002443  5E		     2		POP	esi				;POP THE REGISTER
 00002444  59		     2		POP	ecx				;POP THE REGISTER
 00002445  E9 0000010D			jmp	@@9
					;
 0000244A			@@31:
 0000244A  66| 89 16			mov	[esi],dx		;store new segment value.
					popm	ecx,esi
 0000244D  5E		     2		POP	esi				;POP THE REGISTER
 0000244E  59		     2		POP	ecx				;POP THE REGISTER
 0000244F  83 C6 04			add	esi,4		;next relocation entry.
 00002452  E2 AC			loop	@@3
					;
 00002454			@@NoReloc:	;Write exe image.
					;
 00002454  8B 0D 00000B4A R		mov	ecx,d[ExeSize2]
 0000245A  8B 35 00000B23 R		mov	esi,ExeSegment
 00002460  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 00002467  E8 00000C5F			call	WriteFile
					;
					;Calculate file size.
					;
 0000246C  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 00002473  66| B9 0000			mov	cx,0
 00002477  66| BA 0000			mov	dx,0
 0000247B  66| B8 4201			mov	ax,4201h
 0000247F  CD 21			int	21h
 00002481  C1 E2 10			shl	edx,16
 00002484  66| 8B D0			mov	dx,ax
 00002487  2B 15 0000386D R		sub	edx,Real3POffset
 0000248D  BE 00000B4E R		mov	esi,offset NewHeader
 00002492  89 56 02			mov	[esi].NewHeaderStruc.NewSize,edx
					;
					;Now go back and write the real header.
					;
 00002495  8B 15 0000386D R		mov	edx,Real3POffset
 0000249B  66| 8B CA			mov	cx,dx
 0000249E  C1 EA 10			shr	edx,16
 000024A1  66| 87 CA			xchg	cx,dx
 000024A4  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 000024AB  66| B8 4200			mov	ax,4200h
 000024AF  CD 21			int	21h
 000024B1  BA 00000B4E R		mov	edx,offset NewHeader	;write the header to make space.
 000024B6  66| 8B 1D			mov	bx,TempHandle
	   00000B15 R
 000024BD  66| B9 0040			mov	cx,size NewHeaderStruc
 000024C1  B4 40			mov	ah,40h
 000024C3  CD 21			int	21h
					;
					;Close the files.
					;
 000024C5  66| 8B 1D			mov	bx,TEMPHandle
	   00000B15 R
 000024CC  E8 00000C34			call	CloseFile		;close the temp file.
 000024D1  66| C7 05			mov	TEMPHandle,0
	   00000B15 R
	   0000
 000024DA  66| 8B 1D			mov	bx,EXEHandle
	   00000B00 R
 000024E1  E8 00000C1F			call	CloseFile		;close the file again.
 000024E6  66| C7 05			mov	EXEHandle,0
	   00000B00 R
	   0000
 000024EF  66| 8B 1D			mov	bx,SHELLHandle
	   00000AFA R
 000024F6  E8 00000C0A			call	CloseFile
 000024FB  66| C7 05			mov	SHELLHandle,0
	   00000AFA R
	   0000
					;
					;Delete origional .EXE
					;
 00002504  BA 00000100 R		mov	edx,offset EXEFileName	;get file name mask.
 00002509  B4 41			mov	ah,41h
 0000250B  CD 21			int	21h
 0000250D  66| C7 05			mov	ErrorNumber,8
	   00000004 R
	   0008
 00002516  72 3F			jc	@@9
					;
					;now rename it.
					;
 00002518  BA 00000B08 R		mov	edx,offset TempFileName
 0000251D  BF 00000100 R		mov	edi,offset EXEFileName		;get file name mask.
 00002522  B4 56			mov	ah,56h
 00002524  CD 21			int	21h
 00002526  72 2F			jc	@@9
					;
 00002528  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 00002531  66| 33 C0			xor	ax,ax
					@dprintf 1,<"ProcessFile exit, ax=0 (ok)",10>
 00002534  E8 FFFFDB29	     1		call dprintf
 00002539  50 72 6F 63 65    1		db "ProcessFile exit, ax=0 (ok)",10,0
	   73 73 46 69 6C
	   65 20 65 78 69
	   74 2C 20 61 78
	   3D 30 20 28 6F
	   6B 29 0A 00
 00002556  C3				ret
					;
 00002557			@@9:
					@dprintf 1,<"ProcessFile exit, ax=-1 (error)",10>
 00002557  E8 FFFFDB06	     1		call dprintf
 0000255C  50 72 6F 63 65    1		db "ProcessFile exit, ax=-1 (error)",10,0
	   73 73 46 69 6C
	   65 20 65 78 69
	   74 2C 20 61 78
	   3D 2D 31 20 28
	   65 72 72 6F 72
	   29 0A 00
 0000257D  66| B8 FFFF			mov	ax,-1
 00002581  66| 0B C0			or	ax,ax
 00002584  C3				ret
 00002585			ProcessFile	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
 00002585			ReadMapFile	proc	near
				;
				;Convert the input files.
				;
					@dprintf 1,<"ReadMapFile enter",10>
 00002585  E8 FFFFDAD8	     1		call dprintf
 0000258A  52 65 61 64 4D    1		db "ReadMapFile enter",10,0
	   61 70 46 69 6C
	   65 20 65 6E 74
	   65 72 0A 00
					;
					;Get memory for segment list.
					;
 0000259D  66| C7 05			mov	ErrorNumber,2	;not enough memory.
	   00000004 R
	   0002
				
				;	mov	ebx,16*8192		;allow for maximum segments.
				;	sys	GetMemNear
 000025A6  B9 00020000			mov	ecx,16*8192
 000025AB  E8 000008DC			call	GetMemLinear32
 000025B0  0F 82 00000565		jc	@@9
 000025B6  89 35 00000B17 R		mov	SegmentList,esi
					;
					;Try and open the map file.
					;
 000025BC  66| C7 05			mov	ErrorNumber,10	;default to no map file.
	   00000004 R
	   000A
 000025C5  BA 00000140 R		mov	edx,offset MapFileName
 000025CA  E8 00000A4C			call	OpenFile		;try and open the map file.
 000025CF  0F 82 00000546		jc	@@9
 000025D5  66| A3			mov	MapHandle,ax		;store the handle.
	   00000B06 R
 000025DB  BA 00000A82 R		mov	edx,offset ProcessMapText
 000025E0  E8 00000C5B			call	StringPrint
				
 000025E5  E8 00000BEC			call	InitFileBuffer
				
					;
					;Look for segment list ID string.
					;
 000025EA			@@LookID:
 000025EA  BF 00000180 R		mov	edi,offset LineBuffer
 000025EF  66| 8B 1D			mov	bx,MapHandle
	   00000B06 R
 000025F6  E8 00000B6B			call	ReadLine		;read a line from the map file.
 000025FB  66| C7 05			mov	ErrorNumber,8	;default to general IO error.
	   00000004 R
	   0008
 00002604  0F 82 00000511		jc	@@9
 0000260A  66| C7 05			mov	ErrorNumber,11	;default to no segment header.
	   00000004 R
	   000B
 00002613  66| 0B C0			or	ax,ax		;anything to look at?
 00002616  0F 85 000004FF		jnz	@@9
 0000261C  66| C7 05			mov	ErrorNumber,18
	   00000004 R
	   0012
 00002625  66| 81 F9 0400		cmp	cx,1024
 0000262A  0F 83 000004CD		jnc	@@90
					;
					;See if right text on this line.
					;
 00002630  BE 00000C53 R		mov	esi,offset SegHeaderText
 00002635  BF 00000180 R		mov	edi,offset LineBuffer
					;
 0000263A			@@0:
 0000263A  80 3E 20			cmp	b[esi],' '		;need to skip white space.
 0000263D  74 05			jz	@@1
 0000263F  80 3E 09			cmp	b[esi],9
 00002642  75 03			jnz	@@2
 00002644			@@1:
 00002644  46				inc	esi
 00002645  EB F3			jmp	@@0
					;
 00002647			@@2:
 00002647  80 3F 20			cmp	b[edi],' '		;skip white space.
 0000264A  74 05			jz	@@3
 0000264C  80 3E 09			cmp	b[esi],9
 0000264F  75 03			jnz	@@4
 00002651			@@3:
 00002651  47				inc	edi
 00002652  EB F3			jmp	@@2
					;
 00002654			@@4:
 00002654  80 3E 00			cmp	b[esi],0		;end of the header string?
 00002657  74 21			jz	@@5
 00002659  80 3F 00			cmp	b[edi],0		;end of the line buffer?
 0000265C  74 8C			jz	@@LookID
					;
 0000265E  8A 06			mov	al,[esi]
 00002660  E8 0000081C			call	UpperChar		;case insensitive search.
 00002665  86 E0			xchg	ah,al
 00002667  8A 07			mov	al,[edi]
 00002669  E8 00000813			call	UpperChar
 0000266E  38 E0			cmp	al,ah
 00002670  0F 85 FFFFFF74		jnz	@@LookID		;next line if they don't match
 00002676  46				inc	esi
 00002677  47				inc	edi
 00002678  EB C0			jmp	@@0		;next char if they do.
					;
 0000267A			@@5:	;Find the next none blank line.
					;
 0000267A  66| 8B 1D			mov	bx,MapHandle
	   00000B06 R
 00002681  BF 00000180 R		mov	edi,offset LineBuffer
 00002686  E8 00000ADB			call	ReadLine		;read another line.
 0000268B  66| C7 05			mov	ErrorNumber,8	;default to general IO error.
	   00000004 R
	   0008
 00002694  0F 82 00000481		jc	@@9
 0000269A  66| 0B C0			or	ax,ax		;did we get anything?
 0000269D  0F 85 000002AB		jnz	@@DoSegs		;bloody strange! No segments to process.
 000026A3  66| 0B C9			or	cx,cx		;blank line?
 000026A6  74 D2			jz	@@5		;keep reading till something happens.
 000026A8  66| C7 05			mov	ErrorNumber,18
	   00000004 R
	   0012
 000026B1  66| 81 F9 0400		cmp	cx,1024
 000026B6  0F 83 00000441		jnc	@@90
					;
					;Looks like we can start fetching segment values at last.
					;
 000026BC  A1 00000B17 R		mov	eax,SegmentList	;get segment buffer address.
 000026C1  A3 00000B1B R		mov	SegCurrent,eax	;setup current pointer.
					;
 000026C6			@@LookSeg:
 000026C6  BE 00000180 R		mov	esi,offset LineBuffer	;source data.
 000026CB  BF 00000D21 R		mov	edi,offset SegLayout-1	;definition of data layout.
 000026D0  8B 1D 00000B1B R		mov	ebx,SegCurrent
 000026D6  C7 03 00000000		mov	d[ebx+0],0		;reset linear base.
 000026DC  C7 43 04			mov	d[ebx+4],0		;reset byte limit.
	   00000000
 000026E3  66| C7 43 08			mov	w[ebx+8],0		;reset type.
	   0000
					;
 000026E9			@@6:
 000026E9  80 3E 20			cmp	b[esi],' '		;skip leading white space.
 000026EC  74 05			jz	@@7
 000026EE  80 3E 09			cmp	b[esi],9
 000026F1  75 03			jnz	@@8
 000026F3			@@7:
 000026F3  46				inc	esi
 000026F4  EB F3			jmp	@@6
					;
 000026F6			@@8:
 000026F6  47				inc	edi		;move to next item on the list.
 000026F7  80 3F FF			cmp	b[edi],-1		;finished scan?
 000026FA  0F 84 000001CE		jz	@@NextSeg
 00002700  80 3F 00			cmp	b[edi],0		;ignoring this column?
 00002703  74 0F			jz	@@Ignore
 00002705  80 3F 01			cmp	b[edi],1		;start address?
 00002708  74 17			jz	@@Start
 0000270A  80 3F 02			cmp	b[edi],2		;length?
 0000270D  74 55			jz	@@Length
 0000270F  E9 0000008C			jmp	@@Class		;must be 3 (class) then.
					;
 00002714			@@Ignore:
 00002714  80 3E 20			cmp	b[esi],' '		;scan till more white space.
 00002717  74 D0			jz	@@6		;check next item in the list.
 00002719  80 3E 09			cmp	b[esi],9
 0000271C  74 CB			jz	@@6		;check next item in the list.
 0000271E  46				inc	esi
 0000271F  EB F3			jmp	@@Ignore
					;
 00002721			@@Start:
 00002721  33 D2			xor	edx,edx		;reset acumulated value.
 00002723			@@11:
 00002723  0F B6 06			movzx	eax,b[esi]		;fetch a digit.
 00002726  0A C0			or	al,al
 00002728  74 25			jz	@@10		;finished geting value so store it.
 0000272A  3C 20			cmp	al,' '
 0000272C  74 21			jz	@@10		;finished geting value so store it.
 0000272E  E8 0000040E			call	ASCII2Bin
 00002733  66| C7 05			mov	ErrorNumber,12	;default to bad definition.
	   00000004 R
	   000C
 0000273C  0F 82 000003BB		jc	@@90
 00002742  3C 48			cmp	al,'H'		;end of the number?
 00002744  74 08			jz	@@30
 00002746  C1 E2 04			shl	edx,4		;update acumulated value.
 00002749  03 D0			add	edx,eax		;/
 0000274B  46				inc	esi
 0000274C  EB D5			jmp	@@11		;keep reading till we run out.
 0000274E			@@30:
 0000274E  46				inc	esi		;skip 'H'
 0000274F			@@10:
 0000274F  8B 1D 00000B1B R		mov	ebx,SegCurrent
 00002755  8B C2			mov	eax,edx
 00002757  83 E2 F0			and	edx,0fffffff0h	;segment has to be paragraph aligned.
 0000275A  89 13			mov	[ebx+0],edx		;store start address.
 0000275C  83 E0 0F			and	eax,0fh
 0000275F  01 43 04			add	d[ebx+4],eax		;update limit base value.
 00002762  EB 85			jmp	@@6		;do next item along.
					;
 00002764			@@Length:
 00002764  33 D2			xor	edx,edx		;reset accumulated value.
 00002766			@@12:
 00002766  0F B6 06			movzx	eax,b[esi]		;fetch a digit.
 00002769  0A C0			or	al,al
 0000276B  74 25			jz	@@13		;finished getting value so store it.
 0000276D  3C 20			cmp	al,' '
 0000276F  74 21			jz	@@13		;finished getting value so store it.
 00002771  E8 000003CB			call	ASCII2Bin
 00002776  66| C7 05			mov	ErrorNumber,12	;default to bad definition.
	   00000004 R
	   000C
 0000277F  0F 82 00000378		jc	@@90
 00002785  3C 48			cmp	al,'H'		;end of the number?
 00002787  74 08			jz	@@31
 00002789  C1 E2 04			shl	edx,4		;update acumulated value.
 0000278C  03 D0			add	edx,eax		;/
 0000278E  46				inc	esi
 0000278F  EB D5			jmp	@@12		;keep reading till we run out.
 00002791			@@31:
 00002791  46				inc	esi		;skip 'H'
 00002792			@@13:
 00002792  8B 1D 00000B1B R		mov	ebx,SegCurrent
 00002798  01 53 04			add	d[ebx+4],edx		;store length.
 0000279B  E9 FFFFFF49			jmp	@@6		;do next item along.
					;
 000027A0			@@Class:	;Search class lists for this string.
					;
 000027A0  66| C7 05			mov	ErrorNumber,14	;default to un-known class.
	   00000004 R
	   000E
 000027A9  BD 00000E28 R		mov	ebp,offset SegClassList	;list of lists.
 000027AE  8B D6			mov	edx,esi		;store source position.
 000027B0			@@14:
 000027B0  3E: 83 7D 00			cmp	ds:d[ebp],-1		;end of the list?
	   FF
 000027B5  0F 84 00000342		jz	@@90
 000027BB  3E: 8B 5D 00			mov	ebx,ds:[ebp]		;get table pointer.
 000027BF  8B F2			mov	esi,edx
 000027C1  C7 05 00000580 R		mov	d[@@WildStart1],0
	   00000000
					;
 000027CB			@@15:
 000027CB  80 3B 2A			cmp	b[ebx],'*'		;match anything after this point?
 000027CE  75 21			jnz	@@25
 000027D0  89 1D 00000580 R		mov	d[@@WildStart1],ebx	;store sub-string start.
 000027D6  89 35 00000584 R		mov	d[@@WildStart2],esi
 000027DC  80 7B 01 20			cmp	b[ebx+1],' '		;last thing in string?
 000027E0  74 0F			jz	@@25
 000027E2  80 7B 01 00			cmp	b[ebx+1],0
 000027E6  74 09			jz	@@25
 000027E8  43				inc	ebx		;move to next char.
 000027E9  89 1D 00000580 R		mov	d[@@WildStart1],ebx	;store sub-string start.
 000027EF  EB DA			jmp	@@15
					;
 000027F1			@@25:
 000027F1  80 3B 20			cmp	b[ebx],' '		;end of sub string?
 000027F4  74 05			jz	@@26
 000027F6  80 3B 00			cmp	b[ebx],0
 000027F9  75 0A			jnz	@@27
 000027FB			@@26:
 000027FB  C7 05 00000580 R		mov	d[@@WildStart1],0
	   00000000
					;
 00002805			@@27:
 00002805  80 3E 20			cmp	b[esi],' '		;white space?
 00002808  74 0A			jz	@@19
 0000280A  80 3E 09			cmp	b[esi],9		;white space?
 0000280D  74 05			jz	@@19
 0000280F  80 3E 00			cmp	b[esi],0		;end of the line?
 00002812  75 11			jnz	@@20
					;
 00002814			@@19:
 00002814  80 3B 20			cmp	b[ebx],' '		;if list entry is finished then we have a match.
 00002817  74 6E			jz	@@21
 00002819  80 3B 00			cmp	b[ebx],0
 0000281C  74 69			jz	@@21
 0000281E  80 3B 2A			cmp	b[ebx],'*'
 00002821  74 64			jz	@@21
 00002823  EB 34			jmp	@@17		;try next class name.
					;
 00002825			@@20:
 00002825  8A 06			mov	al,[esi]
 00002827  E8 00000655			call	UpperChar		;no case sensitivity.
 0000282C  86 E0			xchg	ah,al
 0000282E  8A 03			mov	al,[ebx]
 00002830  E8 0000064C			call	UpperChar
 00002835  38 E0			cmp	al,ah		;any match?
 00002837  74 3F			jz	@@16
 00002839  83 3D 00000580 R		cmp	d[@@WildStart1],0	;fail it.
	   00
 00002840  74 17			jz	@@17
 00002842  FF 05 00000584 R		inc	d[@@WildStart2]	;move along in source string.
 00002848  8B 1D 00000580 R		mov	ebx,d[@@WildStart1]	;point to sub string again.
 0000284E  8B 35 00000584 R		mov	esi,d[@@WildStart2]
 00002854  E9 FFFFFF72			jmp	@@15		;look again.
					;
 00002859			@@17:
 00002859  80 3B 00			cmp	b[ebx],0		;end of this class list?
 0000285C  74 21			jz	@@18
 0000285E  80 3B 20			cmp	b[ebx],' '		;seperator?
 00002861  74 03			jz	@@22		;keep going till the end or a space.
 00002863  43				inc	ebx
 00002864  EB F3			jmp	@@17
 00002866			@@22:
 00002866  8B F2			mov	esi,edx
 00002868  43				inc	ebx		;skip the space.
 00002869  C7 05 00000580 R		mov	d[@@WildStart1],0
	   00000000
 00002873  E9 FFFFFF53			jmp	@@15		;try new name.
					;
 00002878			@@16:
 00002878  46				inc	esi
 00002879  43				inc	ebx
 0000287A  E9 FFFFFF4C			jmp	@@15		;keep comparing.
					;
 0000287F			@@18:
 0000287F  83 C5 04			add	ebp,4		;next class list entry.
 00002882  E9 FFFFFF29			jmp	@@14
					;
 00002887			@@21:
 00002887  81 ED 00000E28 R		sub	ebp,offset SegClassList	;get class *4
 0000288D  C1 ED 02			shr	ebp,2		;real class.
 00002890  53				push	ebx
 00002891  8B 1D 00000B1B R		mov	ebx,SegCurrent
 00002897  66| 89 6B 08			mov	w[ebx+8],bp		;store class.
 0000289B  5B				pop	ebx
 0000289C  66| 83 FD 04			cmp	bp,4		;flat?
 000028A0  0F 85 FFFFFE43		jnz	@@6
 000028A6  C6 05 000039CA R		mov	OptionTable+'N','+'	;signal flat mode.
	   2B
 000028AD  C6 05 000039C3 R		mov	OptionTable+'G',0
	   00
 000028B4  C6 05 000039AF R		mov	OptionTable+'3','+'
	   2B
 000028BB  56				push	esi
 000028BC  BE 00000B4E R		mov	esi,offset NewHeader
 000028C1  81 66 20			and	[esi].NewHeaderStruc.NewFlags,65535-(1+16384)	;32 bit code.
	   0000BFFE
 000028C8  5E				pop	esi
 000028C9  E9 FFFFFE1B			jmp	@@6
					;
 000028CE			@@NextSeg:
 000028CE  8B 1D 00000B1B R		mov	ebx,SegCurrent
 000028D4  66| 83 7B 08			cmp	w[ebx+8],2
	   02
 000028D9  75 08			jnz	@@NoRound
 000028DB  83 43 04 0F			add	d[ebx+4],15
 000028DF  83 63 04 F0			and	d[ebx+4],0fffffff0h
 000028E3			@@NoRound:	;
 000028E3  83 05 00000B1B R		add	SegCurrent,16	;next segment storage slot.
	   10
 000028EA  A1 00000B1B R		mov	eax,SegCurrent
 000028EF  2B 05 00000B17 R		sub	eax,SegmentList
 000028F5  C1 E8 04			shr	eax,4
 000028F8  3D 00002000			cmp	eax,8192		;check for to many segments.
 000028FD  66| C7 05			mov	ErrorNumber,17
	   00000004 R
	   0011
 00002906  0F 83 0000020F		jnc	@@9
					;
 0000290C  66| 8B 1D			mov	bx,MapHandle
	   00000B06 R
 00002913  BF 00000180 R		mov	edi,offset LineBuffer
 00002918  E8 00000849			call	ReadLine
 0000291D  66| C7 05			mov	ErrorNumber,8	;default to general IO error.
	   00000004 R
	   0008
 00002926  0F 82 000001EF		jc	@@9
 0000292C  66| 0B C0			or	ax,ax		;EOF?
 0000292F  75 1D			jnz	@@DoSegs
 00002931  66| C7 05			mov	ErrorNumber,18
	   00000004 R
	   0012
 0000293A  66| 81 F9 0400		cmp	cx,1024
 0000293F  0F 83 000001B8		jnc	@@90
 00002945  66| 0B C9			or	cx,cx		;Blank line?
 00002948  0F 85 FFFFFD78		jnz	@@LookSeg		;Fetch next segment value.
					;
 0000294E			@@DoSegs:	;We've got all the segments so its time to make use of them.
					;
 0000294E  80 3D 000039CA R		cmp	OptionTable+'N',0	;Flat mode?
	   00
 00002955  74 7B			jz	@@NoFlat
					;
 00002957  A1 00000B1B R		mov	eax,SegCurrent
 0000295C  2B 05 00000B17 R		sub	eax,SegmentList
 00002962  C1 E8 04			shr	eax,4		;/16
 00002965  83 F8 01			cmp	eax,1
 00002968  66| C7 05			mov	ErrorNumber,24	;only one segment allowed.
	   00000004 R
	   0018
 00002971  0F 85 000001A4		jnz	@@9
 00002977  8B 35 00000B17 R		mov	esi,SegmentList
 0000297D  8B 06			mov	eax,0[esi]		;get base.
 0000297F  8B 5E 04			mov	ebx,4[esi]		;get limit.
 00002982  C7 46 04			mov	d[esi+4],-1		;set limit.
	   FFFFFFFF
 00002989  83 C6 10			add	esi,16		;next entry.
 0000298C  89 06			mov	0[esi],eax		;set base.
 0000298E  89 5E 04			mov	d[esi+4],ebx		;set limit.
 00002991  66| C7 46 08			mov	w[esi+8],0		;set class to code.
	   0000
 00002997  83 C6 10			add	esi,16
 0000299A  89 35 00000B1B R		mov	SegCurrent,esi	;pretend normal now.
 000029A0  83 EE 10			sub	esi,16
					;
 000029A3  80 3D 000039D6 R		cmp	OptionTable+'Z',0
	   00
 000029AA  74 26			jz	@@NoFlat
					;
 000029AC  BF 00000B4E R		mov	edi,offset NewHeader
 000029B1  8B 47 24			mov	eax,[edi].NewHeaderStruc.NewAutoStack
 000029B4  0B C0			or	eax,eax
 000029B6  75 05			jnz	@@GotESPSize
 000029B8  B8 00000400			mov	eax,1024
 000029BD			@@GotESPSize:
 000029BD  03 46 04			add	eax,4[esi]
 000029C0  83 C0 03			add	eax,3
 000029C3  83 E0 FC			and	eax,0FFFFFFFCh
 000029C6  89 46 04			mov	4[esi],eax
 000029C9  89 47 1A			mov	[edi].NewHeaderStruc.NewEntryESP,eax
 000029CC  66| C7 47 1E			mov	[edi].NewHeaderStruc.NewEntrySS,0
	   0000
					;
 000029D2			@@NoFlat:
 000029D2  A1 00000B1B R		mov	eax,SegCurrent
 000029D7  2B 05 00000B17 R		sub	eax,SegmentList
 000029DD  C1 E8 04			shr	eax,4		;/16
 000029E0  A3 00000B1F R		mov	SegmentTotal,eax
 000029E5  0B C0			or	eax,eax		;any segments found?
 000029E7  66| C7 05			mov	ErrorNumber,13
	   00000004 R
	   000D
 000029F0  0F 84 00000125		jz	@@9
					;
 000029F6  66| 8B 1D			mov	bx,MapHandle
	   00000B06 R
 000029FD  E8 00000703			call	CloseFile		;close the file again.
 00002A02  66| C7 05			mov	MapHandle,0
	   00000B06 R
	   0000
					;
					;Work out where the very end of the program will be. This is the size of memory
					;we will need to allocate for it.
					;
 00002A0B  8B 1D 00000B17 R		mov	ebx,SegmentList	;make segment details addressable.
 00002A11  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;number of segments.
 00002A17  33 D2			xor	edx,edx		;reset comparison value.
 00002A19			@@23:
 00002A19  83 7B 04 FF			cmp	d[ebx+4],-1
 00002A1D  74 0B			jz	@@24
 00002A1F  8B 03			mov	eax,[ebx+0]		;get segment base.
 00002A21  03 43 04			add	eax,[ebx+4]		;add in length.
 00002A24  3B C2			cmp	eax,edx		;biggest yet?
 00002A26  72 02			jc	@@24
 00002A28  8B D0			mov	edx,eax		;store new limit.
 00002A2A			@@24:
 00002A2A  83 C3 10			add	ebx,16
 00002A2D  E2 EA			loop	@@23		;do all of them.
 00002A2F  BE 00000B4E R		mov	esi,offset NewHeader
 00002A34  89 56 0A			mov	[esi].NewHeaderStruc.NewAlloc,edx	;store it in the new header.
					;
					;Go through segments altering limits so that they extend to the
					;end of the program.
					;
 00002A37  80 3D 000039C3 R		cmp	OptionTable+'G',0	;group addressing?
	   00
 00002A3E  74 27			jz	@@NoGroup
 00002A40  BE 00000B4E R		mov	esi,offset NewHeader
 00002A45  8B 46 0A			mov	eax,[esi].NewHeaderStruc.NewAlloc	;get program limit.
 00002A48  8B 35 00000B17 R		mov	esi,SegmentList	;the segment details.
 00002A4E  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;number of segments to process.
 00002A54			@@G0:
 00002A54  66| 83 7E 08			cmp	w[esi+8],0		;code segment?
	   00
 00002A59  74 07			jz	@@G1		;leave code segs as they are.
 00002A5B  8B D8			mov	ebx,eax		;copy program limit.
 00002A5D  2B 1E			sub	ebx,0[esi]		;minus segment base.
 00002A5F  89 5E 04			mov	4[esi],ebx		;set new limit.
 00002A62			@@G1:
 00002A62  83 C6 10			add	esi,16		;next segment.
 00002A65  E2 ED			loop	@@G0		;do all of them.
					;
 00002A67			@@NoGroup:	;Now make sure no 2 segments have the same base value.
					;
 00002A67  80 3D 000039CA R		cmp	OptionTable+'N',0
	   00
 00002A6E  75 65			jnz	@@NoBaseChk
 00002A70  8B 35 00000B17 R		mov	esi,SegmentList	;make segment details addressable.
 00002A76  8B 0D 00000B1F R		mov	ecx,SegmentTotal	;number of segments.
 00002A7C			@@SameBase0:
					pushm	ecx,esi
 00002A7C  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00002A7D  56		     2		PUSH	esi			;SAVE THE REGISTER
 00002A7E  8B 06			mov	eax,[esi]		;get base.
 00002A80  8B EE			mov	ebp,esi
 00002A82  83 C6 10			add	esi,16
 00002A85  49				dec	ecx
 00002A86			@@SameBase1:
 00002A86  0B C9			or	ecx,ecx
 00002A88  74 0C			jz	@@SameBase2
 00002A8A  78 0A			js	@@SameBase2
 00002A8C  3B 06			cmp	eax,[esi]		;same base?
 00002A8E  74 14			jz	@@SameBase3
 00002A90			@@SameBase4:
 00002A90  83 C6 10			add	esi,16
 00002A93  49				dec	ecx
 00002A94  EB F0			jmp	@@SameBase1
 00002A96			@@SameBase2:
					popm	ecx,esi
 00002A96  5E		     2		POP	esi				;POP THE REGISTER
 00002A97  59		     2		POP	ecx				;POP THE REGISTER
 00002A98  83 C6 10			add	esi,16
 00002A9B  49				dec	ecx
 00002A9C  0B C9			or	ecx,ecx
 00002A9E  74 35			jz	@@NoBaseChk
 00002AA0  78 33			js	@@NoBaseChk
 00002AA2  EB D8			jmp	@@SameBase0
					;
 00002AA4			@@SameBase3:
					pushm	eax,ecx,esi,ebp
 00002AA4  50		     2		PUSH	eax			;SAVE THE REGISTER
 00002AA5  51		     2		PUSH	ecx			;SAVE THE REGISTER
 00002AA6  56		     2		PUSH	esi			;SAVE THE REGISTER
 00002AA7  55		     2		PUSH	ebp			;SAVE THE REGISTER
				
				if	0
				endif
				
 00002AA8  BA 000009F6 R		mov	edx,offset SegSamet
 00002AAD  E8 0000078E			call	StringPrint
 00002AB2  C6 05 000009F6 R		mov	SegSamet,0
	   00
				
					popm	eax,ecx,esi,ebp
 00002AB9  5D		     2		POP	ebp				;POP THE REGISTER
 00002ABA  5E		     2		POP	esi				;POP THE REGISTER
 00002ABB  59		     2		POP	ecx				;POP THE REGISTER
 00002ABC  58		     2		POP	eax				;POP THE REGISTER
					;
					;Upgrade first segment to largest length of the two.
					;
 00002ABD  50				push	eax
 00002ABE  3E: 8B 45 04			mov	eax,ds:[ebp+4]
 00002AC2  8B 56 04			mov	edx,[esi+4]
 00002AC5  3B C2			cmp	eax,edx
 00002AC7  73 02			jnc	@@SameBase5
 00002AC9  8B C2			mov	eax,edx
 00002ACB			@@SameBase5:
 00002ACB  3E: 89 45 04			mov	ds:[ebp+4],eax
 00002ACF  89 46 04			mov	[esi+4],eax
 00002AD2  58				pop	eax
 00002AD3  EB BB			jmp	@@SameBase4
 00002AD5			@@NoBaseChk:	;
					@dprintf 1,<"ReadMapFile exit, ok",10>
 00002AD5  E8 FFFFD588	     1		call dprintf
 00002ADA  52 65 61 64 4D    1		db "ReadMapFile exit, ok",10,0
	   61 70 46 69 6C
	   65 20 65 78 69
	   74 2C 20 6F 6B
	   0A 00
 00002AF0  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 00002AF9  66| 33 C0			xor	ax,ax
 00002AFC  C3				ret
					;
 00002AFD			@@90:
 00002AFD  BA 00000ADE R		mov	edx,offset CarriageReturn
 00002B02  E8 00000739			call	StringPrint
 00002B07  BA 00000180 R		mov	edx,offset LineBuffer
 00002B0C  E8 0000072F			call	StringPrint		;print the offending line.
 00002B11  BA 00000ADE R		mov	edx,offset CarriageReturn
 00002B16  E8 00000725			call	StringPrint
					;
 00002B1B			@@9:
					@dprintf 1,<"ReadMapFile exit, error",10>
 00002B1B  E8 FFFFD542	     1		call dprintf
 00002B20  52 65 61 64 4D    1		db "ReadMapFile exit, error",10,0
	   61 70 46 69 6C
	   65 20 65 78 69
	   74 2C 20 65 72
	   72 6F 72 0A 00
 00002B39  66| B8 FFFF			mov	ax,-1
 00002B3D  66| 0B C0			or	ax,ax
 00002B40  C3				ret
 00000580			_BSS segment
 00000580 00000000		@@WildStart1	dd ?
 00000584 00000000		@@WildStart2	dd ?
 00002B41			_BSS ends
 00002B41			ReadMapFile	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
 00002B41			ASCII2Bin	proc	near
				;
				;Convert hex digit in AL into binary value.
				;
 00002B41  E8 0000033B			call	UpperChar
 00002B46  3C 48			cmp	al,'H'
 00002B48  74 16			jz	@@8
 00002B4A  3C 30			cmp	al,'0'
 00002B4C  72 14			jc	@@9
 00002B4E  3C 41			cmp	al,'A'
 00002B50  72 08			jc	@@Dec
 00002B52  3C 47			cmp	al,'F'+1
 00002B54  73 0C			jnc	@@9
 00002B56  2C 37			sub	al,'A'-10
 00002B58  EB 06			jmp	@@8
 00002B5A			@@Dec:
 00002B5A  3C 3A			cmp	al,'9'+1
 00002B5C  73 04			jnc	@@9
 00002B5E  2C 30			sub	al,'0'
 00002B60			@@8:
 00002B60  F8				clc
 00002B61  C3				ret
					;
 00002B62  F9			@@9:	stc
 00002B63  C3				ret
 00002B64			ASCII2Bin	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
 00002B64			ReadConfig	proc	near
				;
				;Read configuration file.
				;
 00002B64  E8 0000066D			call	InitFileBuffer
				
 00002B69  BA 00000AE4 R		mov	edx,offset ConfigName
 00002B6E  80 3D 000039BF R		cmp	OptionTable+'C',0	;new config file name?
	   00
 00002B75  74 0A			jz	@@NoOveride
 00002B77  8B 15 00003B08 R		mov	edx,d[OptionTable+128+('C'*4)]
 00002B7D  0B D2			or	edx,edx
 00002B7F  74 14			jz	@@NotCurrent
 00002B81			@@NoOveride:
 00002B81  E8 00000495			call	OpenFile
 00002B86  73 71			jnc	@@ConfigOK
 00002B88  80 3D 000039BF R		cmp	OptionTable+'C',0	;new config file name?
	   00
 00002B8F  0F 85 0000013E		jnz	@@8		;don't look for default.
 00002B95			@@NotCurrent:	;
 00002B95  8B 1D 00000000 R		mov	ebx, psp
				if 0
				else
 00002B9B  66| 8B 5B 2C			mov bx,[ebx+2Ch]
 00002B9F  66| B8 0006			mov ax,6
 00002BA3  CD 31			int 31h
 00002BA5  66| 51			push cx
 00002BA7  66| 52			push dx
 00002BA9  5E				pop esi
				endif
 00002BAA  33 ED			xor	ebp,ebp
 00002BAC			@@c1:
 00002BAC  8A 06			mov	al,[esi]		;Get a byte.
 00002BAE  46				inc	esi		;/
 00002BAF  0A C0			or	al,al		;End of a string?
 00002BB1  75 F9			jnz	@@c1		;keep looking.
 00002BB3  8A 06			mov	al,[esi]		;Double zero?
 00002BB5  0A C0			or	al,al		;/
 00002BB7  75 F3			jnz	@@c1		;keep looking.
 00002BB9  83 C6 03			add	esi,3		;Skip last 0 and word count.
 00002BBC  BF 00000000 R		mov	edi,offset ConfigPath
 00002BC1			@@c2:
 00002BC1  A4				movsb
 00002BC2  80 7E FF 5C			cmp	b[esi-1],'\'
 00002BC6  75 02			jnz	@@c3
 00002BC8  8B EF			mov	ebp,edi
 00002BCA			@@c3:
 00002BCA  80 7E FF 00			cmp	b[esi-1],0		;got to the end yet?
 00002BCE  75 F1			jnz	@@c2
 00002BD0  0B ED			or	ebp,ebp
 00002BD2  75 02			jnz	@@c99
 00002BD4  8B EF			mov	ebp,edi
 00002BD6			@@c99:
 00002BD6  4D				dec	ebp
 00002BD7  8B FD			mov	edi,ebp
 00002BD9  C6 07 5C			mov	b[edi],'\'
 00002BDC  47				inc	edi
 00002BDD  BE 00000AE4 R		mov	esi,offset ConfigName
 00002BE2			@@c4:
 00002BE2  A4				movsb
 00002BE3  80 7E FF 00			cmp	b[esi-1],0
 00002BE7  75 F9			jnz	@@c4
					;
 00002BE9  BA 00000000 R		mov	edx,offset ConfigPath	;use new name.
 00002BEE  E8 00000428			call	OpenFile
 00002BF3  0F 82 000000DA		jc	@@8		;don't have to have a config.
					;
 00002BF9			@@ConfigOK:
 00002BF9  66| A3			mov	ConfigHandle,ax
	   00000AF8 R
					;
 00002BFF			@@Read:
 00002BFF  66| 8B 1D			mov	bx,ConfigHandle
	   00000AF8 R
 00002C06  BF 00000180 R		mov	edi,offset LineBuffer
 00002C0B  E8 00000556			call	ReadLine		;read a line.
 00002C10  66| C7 05			mov	ErrorNumber,8	;default to io error.
	   00000004 R
	   0008
 00002C19  0F 82 000000E9		jc	@@9
 00002C1F  66| 0B C0			or	ax,ax		;end of the file?
 00002C22  0F 85 00000094		jnz	@@7
 00002C28  66| C7 05			mov	ErrorNumber,18
	   00000004 R
	   0012
 00002C31  66| 81 F9 0400		cmp	cx,1024
 00002C36  0F 83 000000AE		jnc	@@90
					;
 00002C3C			@@Scan:	;Check this line for variables.
					;
 00002C3C  BA 00000180 R		mov	edx,offset LineBuffer
 00002C41  BD 00000B8E R		mov	ebp,offset VariableList
 00002C46  8B FA			mov	edi,edx
 00002C48  80 3F 3B			cmp	b[edi],';'
 00002C4B  74 B2			jz	@@Read		;comment so ignore it.
 00002C4D  80 3F 00			cmp	b[edi],0		;blank line?
 00002C50  74 AD			jz	@@Read
					;
 00002C52			@@0:
 00002C52  66| C7 05			mov	ErrorNumber,15
	   00000004 R
	   000F
 00002C5B  3E: 83 7D 00			cmp	ds:d[ebp],-1		;end of the list?
	   FF
 00002C60  0F 84 00000084		jz	@@90
 00002C66  3E: 8B 75 00			mov	esi,ds:[ebp]		;get text pointer.
 00002C6A  8B FA			mov	edi,edx		;source data.
					;
 00002C6C			@@1:
 00002C6C  80 3F 3D			cmp	b[edi],'='		;end of the string?
 00002C6F  75 05			jnz	@@3
 00002C71  80 3E 00			cmp	b[esi],0		;end of our version as well?
 00002C74  74 30			jz	@@4
					;
 00002C76			@@3:
 00002C76  66| C7 05			mov	ErrorNumber,15
	   00000004 R
	   000F
 00002C7F  80 3F 00			cmp	b[edi],0		;end of the line?
 00002C82  74 66			jz	@@90
					;
 00002C84  80 3E 00			cmp	b[esi],0		;end of the text?
 00002C87  74 14			jz	@@5
					;
 00002C89  8A 06			mov	al,[esi]
 00002C8B  E8 000001F1			call	UpperChar
 00002C90  86 E0			xchg	ah,al
 00002C92  8A 07			mov	al,[edi]
 00002C94  E8 000001E8			call	UpperChar
 00002C99  38 E0			cmp	al,ah		;match?
 00002C9B  74 05			jz	@@2
					;
 00002C9D			@@5:
 00002C9D  83 C5 10			add	ebp,16		;next variable.
 00002CA0  EB B0			jmp	@@0
					;
 00002CA2			@@2:
 00002CA2  46				inc	esi
 00002CA3  47				inc	edi
 00002CA4  EB C6			jmp	@@1
					;
 00002CA6			@@4:
 00002CA6  47				inc	edi
 00002CA7  3E: FF 55 04			call	ds:d[ebp+4]		;call the handler code.
 00002CAB  0F 84 FFFFFF4E		jz	@@Read
 00002CB1  66| C7 05			mov	ErrorNumber,16	;invalid setting.
	   00000004 R
	   0010
 00002CBA  EB 2E			jmp	@@90
					;
 00002CBC			@@7:
 00002CBC  66| 8B 1D			mov	bx,ConfigHandle	;close the file again.
	   00000AF8 R
 00002CC3  E8 0000043D			call	CloseFile
 00002CC8  66| C7 05			mov	ConfigHandle,0
	   00000AF8 R
	   0000
 00002CD1  EB 0A			jmp	@@10
					;
 00002CD3			@@8:
 00002CD3  BA 00000A32 R		mov	edx,offset InternalConfig
 00002CD8  E8 00000563			call	StringPrint
					;
 00002CDD			@@10:
 00002CDD  66| C7 05			mov	ErrorNumber,0
	   00000004 R
	   0000
 00002CE6  66| 33 C0			xor	ax,ax
 00002CE9  C3				ret
					;
 00002CEA			@@90:
 00002CEA  BA 00000ADE R		mov	edx,offset CarriageReturn
 00002CEF  E8 0000054C			call	StringPrint
 00002CF4  BA 00000180 R		mov	edx,offset LineBuffer
 00002CF9  E8 00000542			call	StringPrint
 00002CFE  BA 00000ADE R		mov	edx,offset CarriageReturn
 00002D03  E8 00000538			call	StringPrint
					;
 00002D08			@@9:
 00002D08  66| B8 FFFF			mov	ax,-1
 00002D0C  66| 0B C0			or	ax,ax
 00002D0F  C3				ret
 00002D10			ReadConfig	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=-=
 00002D10			WhiteSpaceString proc near
				;
				;Retrieve a string and convert multiple white space into single spaces. Last white space is line
				;terminator.
				;
					;
 00002D10  8B F7			mov	esi,edi
 00002D12  89 35 00000588 R		mov	d[@@Source],esi
 00002D18  3E: 8B 7D 08			mov	edi,ds:[ebp+8]	;get target address.
 00002D1C  80 7F FF FF			cmp	b[edi-1],-1		;first time?
 00002D20  C6 47 FF 00			mov	b[edi-1],0
 00002D24  74 09			jz	@@AtStart
 00002D26			@@30:
 00002D26  8A 07			mov	al,[edi]
 00002D28  0A C0			or	al,al
 00002D2A  74 03			jz	@@AtStart
 00002D2C  47				inc	edi
 00002D2D  EB F7			jmp	@@30
 00002D2F			@@AtStart:	;
 00002D2F  C6 07 20			mov	b[edi],' '
 00002D32  47				inc	edi
					;
 00002D33  32 E4			xor	ah,ah		;clear spacing flag.
 00002D35			@@0:
 00002D35  AC				lodsb
 00002D36  3C 5C			cmp	al,'\'		;line continuation?
 00002D38  75 3B			jnz	@@5
					;
					;Read a new line.
					;
					pushm	edi,ebp
 00002D3A  57		     2		PUSH	edi			;SAVE THE REGISTER
 00002D3B  55		     2		PUSH	ebp			;SAVE THE REGISTER
 00002D3C  66| 8B 1D			mov	bx,ConfigHandle
	   00000AF8 R
 00002D43  8B 3D 00000588 R		mov	edi,d[@@Source]
 00002D49  E8 00000418			call	ReadLine		;read a line.
					popm	edi,ebp
 00002D4E  5D		     2		POP	ebp				;POP THE REGISTER
 00002D4F  5F		     2		POP	edi				;POP THE REGISTER
 00002D50  72 5E			jc	@@9
 00002D52  66| 0B C0			or	ax,ax		;end of the file?
 00002D55  75 52			jnz	@@7
 00002D57  66| 81 F9 0400		cmp	cx,1024
 00002D5C  73 52			jnc	@@9
					;
 00002D5E  8B 35 00000588 R		mov	esi,d[@@Source]
 00002D64			@@6:
 00002D64  AC				lodsb
 00002D65  3C 20			cmp	al,' '
 00002D67  74 FB			jz	@@6
 00002D69  3C 09			cmp	al,9
 00002D6B  74 F7			jz	@@6
 00002D6D  4E				dec	esi
 00002D6E  B0 20			mov	al,' '
 00002D70  AA				stosb
 00002D71  32 E4			xor	ah,ah
 00002D73  EB C0			jmp	@@0		;start reading again.
					;
 00002D75			@@5:
 00002D75  AA				stosb
 00002D76  80 7E FF 00			cmp	b[esi-1],0		;end of the string?
 00002D7A  74 1F			jz	@@1
 00002D7C  80 7E FF 20			cmp	b[esi-1],' '		;need multiple space check?
 00002D80  74 0A			jz	@@2
 00002D82  80 7E FF 09			cmp	b[esi-1],9
 00002D86  74 04			jz	@@2
 00002D88  32 E4			xor	ah,ah		;clear spacing flag.
 00002D8A  EB A9			jmp	@@0
					;
 00002D8C			@@2:
 00002D8C  0A E4			or	ah,ah		;this part 2?
 00002D8E  75 08			jnz	@@3
 00002D90  C6 47 FF 20			mov	b[edi-1],' '		;make sure its a space.
 00002D94  B4 01			mov	ah,1		;signal spacing start.
 00002D96  EB 9D			jmp	@@0
					;
 00002D98			@@3:
 00002D98  4F				dec	edi		;move back to last one.
 00002D99  EB 9A			jmp	@@0
					;
 00002D9B			@@1:
 00002D9B  4F				dec	edi		;back to terminator.
 00002D9C  3E: 3B 7D 08			cmp	edi,ds:[ebp+8]	;back at the start yet?
 00002DA0  74 07			jz	@@4
 00002DA2  80 7F FF 20			cmp	b[edi-1],' '		;trailing space?
 00002DA6  75 01			jnz	@@4
 00002DA8  4F				dec	edi
 00002DA9			@@4:	;
 00002DA9			@@7:
 00002DA9  C6 07 00			mov	b[edi],0		;terminate the line.
					;
 00002DAC  66| 33 C0			xor	ax,ax
 00002DAF  C3				ret
					;
 00002DB0			@@9:
 00002DB0  66| B8 FFFF			mov	ax,-1
 00002DB4  66| 0B C0			or	ax,ax
 00002DB7  C3				ret
 00000588			_BSS segment
 00000588 00000000		@@Source	dd ?
 00002DB8			_BSS ends
 00002DB8			WhiteSpaceString endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
 00002DB8			SegFormatCode	proc near
				;
				;Convert input string to segment format table layout.
				;
 00002DB8  8B D7			mov	edx,edi		;get source address.
 00002DBA  3E: 8B 7D 08			mov	edi,ds:[ebp+8]	;get target address.
					;
 00002DBE			@@5:
 00002DBE  8B F2			mov	esi,edx
 00002DC0  80 3E 00			cmp	b[esi],0		;end of input?
 00002DC3  74 78			jz	@@6
					;
 00002DC5  BD 00000CF1 R		mov	ebp,offset SegFormatTexts	;list of strings to match against.
 00002DCA			@@0:
 00002DCA  66| C7 05			mov	ErrorNumber,16	;syntax error.
	   00000004 R
	   0010
 00002DD3  3E: 83 7D 00			cmp	ds:d[ebp],-1		;end of the list?
	   FF
 00002DD8  0F 84 00000080		jz	@@9		;not a valid statement then.
 00002DDE  3E: 8B 5D 00			mov	ebx,ds:[ebp]		;get variable text.
 00002DE2  8B F2			mov	esi,edx		;get source string.
 00002DE4			@@1:
 00002DE4  80 3E 00			cmp	b[esi],0		;line end?
 00002DE7  74 05			jz	@@7
 00002DE9  80 3E 20			cmp	b[esi],' '		;seperator?
 00002DEC  75 05			jnz	@@3
 00002DEE			@@7:
 00002DEE  80 3B 00			cmp	b[ebx],0		;end of variable text as well?
 00002DF1  74 27			jz	@@4		;looks like we've got a match.
 00002DF3			@@3:
 00002DF3  80 3E 20			cmp	b[esi],' '		;seperator?
 00002DF6  74 1D			jz	@@2		;next variable text.
 00002DF8  80 3B 00			cmp	b[ebx],0		;end of variable text?
 00002DFB  74 18			jz	@@2		;next variable text.
 00002DFD  8A 06			mov	al,[esi]
 00002DFF  E8 0000007D			call	UpperChar
 00002E04  86 E0			xchg	ah,al
 00002E06  8A 03			mov	al,[ebx]
 00002E08  E8 00000074			call	UpperChar
 00002E0D  38 E0			cmp	al,ah		;do they match?
 00002E0F  75 04			jnz	@@2
 00002E11  46				inc	esi
 00002E12  43				inc	ebx
 00002E13  EB CF			jmp	@@1		;keep looking till something happens.
					;
 00002E15			@@2:
 00002E15  83 C5 04			add	ebp,4		;next string.
 00002E18  EB B0			jmp	@@0
					;
 00002E1A			@@4:
 00002E1A  81 ED 00000CF1 R		sub	ebp,offset SegFormatTexts	;get index *4
 00002E20  C1 ED 02			shr	ebp,2		;get operation type.
 00002E23  8B C5			mov	eax,ebp
 00002E25  88 07			mov	b[edi],al		;put it in the destination.
 00002E27  47				inc	edi
 00002E28  81 C5 00000D1D R		add	ebp,offset SegFormatSlots	;point at slot table.
 00002E2E  3E: C6 45 00			mov	ds:b[ebp],1		;mark this operation type as present.
	   01
					;
 00002E33  8B D6			mov	edx,esi
 00002E35  80 3E 00			cmp	b[esi],0		;did we finish on 0?
 00002E38  74 84			jz	@@5		;catch it up there.
 00002E3A  42				inc	edx		;skip space seperator.
 00002E3B  EB 81			jmp	@@5		;scan the rest of the line.
					;
 00002E3D			@@6:
 00002E3D  C6 07 FF			mov	b[edi],-1		;terminate the list.
 00002E40  BE 00000D1E R		mov	esi,offset SegFormatSlots+1	;point at slot table. (ignore NULL entry)
 00002E45  B9 00000003			mov	ecx,3		;only 3 types at the moment.
 00002E4A  66| C7 05			mov	ErrorNumber,16	;default to syntax error.
	   00000004 R
	   0010
 00002E53			@@8:
 00002E53  AC				lodsb
 00002E54  0A C0			or	al,al		;this entry used?
 00002E56  74 06			jz	@@9		;ALL positions have to be defined.
 00002E58  E2 F9			loop	@@8		;do them all.
					;
 00002E5A  66| 33 C0			xor	ax,ax
 00002E5D  C3				ret
					;
 00002E5E			@@9:
 00002E5E  66| B8 FFFF			mov	ax,-1
 00002E62  66| 0B C0			or	ax,ax
 00002E65  C3				ret
 00002E66			SegFormatCode	endp
				
				
				
				;-------------------------------------------------------------------------------
 00002E66			Bord	proc	near
					pushm	ax,dx
 00002E66  66| 50	     2		PUSH	ax			;SAVE THE REGISTER
 00002E68  66| 52	     2		PUSH	dx			;SAVE THE REGISTER
 00002E6A  8A E0			mov	ah,al
 00002E6C  66| BA 03DA			mov	dx,3dah
 00002E70  EC				in	al,dx
 00002E71  B2 C0			mov	dl,0c0h
 00002E73  B0 11			mov	al,11h
 00002E75  EE				out	dx,al
 00002E76  8A C4			mov	al,ah
 00002E78  EE				out	dx,al
 00002E79  B0 20			mov	al,20h
 00002E7B  EE				out	dx,al
					popm	ax,dx
 00002E7C  66| 5A	     2		POP	dx				;POP THE REGISTER
 00002E7E  66| 58	     2		POP	ax				;POP THE REGISTER
 00002E80  C3				ret
 00002E81			Bord	endp
				
				
				;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
 00002E81			UpperChar	proc	near
				;
				;Convert a character into upper case.
				;
				;On Entry:-
				;AL - Character to convert.
				;
				;On Exit:-
				;AL - New character code.
				;
 00002E81  3C 61			cmp	al,61h		; 'a'
 00002E83  72 06			jb	@@0
 00002E85  3C 7A			cmp	al,7Ah		; 'z'
 00002E87  77 02			ja	@@0
 00002E89  24 5F			and	al,5Fh
 00002E8B  C3			@@0:	ret
 00002E8C			UpperChar	endp
				
				;--- get linear memory
				;--- in: size in ECX
				;--- out: linear address in ESI
				;--- must preserve ECX
				
 00002E8C			GetMemLinear32 PROC uses ecx bx di
 00002E91  51				push ecx
 00002E92  66| 59			pop cx
 00002E94  66| 5B			pop bx
 00002E96  66| B8 0501			mov ax, 501h
 00002E9A  CD 31			int 31h
 00002E9C  72 05			jc fail
 00002E9E  66| 53			push bx
 00002EA0  66| 51			push cx
 00002EA2  5E				pop esi
 00002EA3			fail:
					ret
 00002EA9			GetMemLinear32 ENDP
				
				;--- free linear memory block
				;--- in: address in ESI
				
 00002EA9			RelMemLinear32 PROC uses edi
 00002EAA  56				push esi
 00002EAB  66| 5F			pop di
 00002EAD  66| 5E			pop si
 00002EAF  66| B8 0502			mov ax, 502h
 00002EB3  CD 31			int 31h
					ret
 00002EB7			RelMemLinear32 ENDP
				
				;--- resize linear memory block
				;--- in: address in ESI, new size in ECX
				
 00002EB7			ResMemLinear32 PROC uses ecx edi ebx
 00002EBA  56				push esi
 00002EBB  66| 5F			pop di
 00002EBD  66| 5E			pop si
 00002EBF  51				push ecx
 00002EC0  66| 59			pop cx
 00002EC2  66| 5B			pop bx
 00002EC4  66| B8 0503			mov ax, 503h	; new size in BX:CX, handle (=address) in SI:DI
 00002EC8  CD 31			int 31h
 00002ECA  66| 56			push si
 00002ECC  66| 57			push di
 00002ECE  5E				pop esi
					ret
 00002ED3			ResMemLinear32 ENDP
				
					include command.inc
			      C 
 0000397B		      C _DATA segment
 0000397B 00		      C OptionCounter	db 0
 0000397C  00000080 [	      C OptionTable	db 128 dup (0)
	    00
	   ]
 000039FC  00000080 [	      C 	dd 128 dup (0)
	    00000000
	   ]
 00003BFC 00000000	      C OptionPointer	dd ?
 00003C00  00000100 [	      C OptionText	db 256 dup (0)
	    00
	   ]
 00002ED3		      C _DATA ends
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00002ED3		      C ReadCommand	proc	near
			      C ;
			      C ;Read the command line tail for parameters.
			      C ;
			      C ;supports / or - or + as switch/option settings. Options and names may be in
			      C ;any order, text can be tagged onto options, names must be in correct sequence
			      C ;for current program.
			      C ;
			      C ;Each character ( 33 to 127) has an entry in OptionTable & OptionTable+128.
			      C ;
			      C ;The first entry is a byte, and is 0 for OFF & none-zero for ON.
			      C ;The second entry is a pointer to any additional text specified, 0 means none.
			      C ;Entries 0-32 are reserved for text not preceded by - or + or /. These are
			      C ;intended to be file names, but neadn't be.
			      C ;All text entries are 0 terminated.
			      C ;
			      C ;To test flag:- cmp OptionTable+'?',0	;where ? is upper case character.
			      C ;To test text:- cmp w[offset OptionTable+128+('?'*2)],0
			      C ;To get text:-  mov bx,w[offset OptionTable+128+('?'*2)]
			      C ;
			      C ;To get first file name,  mov bx,w[offset OptionTable+128+0]
			      C ;       second            mov bx,w[offset OptionTable+128+2]
			      C ;
			      C ;The text gatherer will also accept : or = after the switch, eg,
			      C ;
			      C ;	Chop-Rob /aEJW1 test.pak
			      C ;	or
			      C ;	Chop-Rob /a:EJW1 test.pak
			      C ;	or
			      C ;	Chop-Rob /a=EJW1 test.pak
			      C ;
			      C ;Switches & file names may be in any position. Duplicate switch settings with
			      C ;text will store multiple text, but only the last will be addressable.
			      C ;
			      C 
 00002ED3  8B 1D 00000000 R   C 	mov ebx, psp
 00002ED9  BF 00003C00 R      C 	mov	edi,offset OptionText
 00002EDE  89 3D 00003BFC R   C 	mov	OptionPointer,edi
 00002EE4  8D B3 00000080     C 	lea	esi,[ebx+80h]		;/
 00002EEA  33 C9	      C 	xor	ecx,ecx
 00002EEC  8A 0E	      C 	mov	cl,[esi]	;get tail length
 00002EEE  80 F9 02	      C 	cmp	cl,2
 00002EF1  0F 82 00000113     C 	jc	@@9		;not long enough!
 00002EF7  8B FE	      C 	mov	edi,esi
 00002EF9  03 F9	      C 	add	edi,ecx
 00002EFB  C6 47 01 00	      C 	mov	b[edi+1],0	;terminate the tail.
 00002EFF  46		      C 	inc	esi		;skip length.
			      C 	;
 00002F00		      C @@0:
 00002F00  8A 06	      C 	mov	al,[esi]		;need to skip leading spaces.
 00002F02  46		      C 	inc	esi		;/
 00002F03  0A C0	      C 	or	al,al		;/
 00002F05  0F 84 000000FF     C 	jz	@@9		;/
 00002F0B  3C 20	      C 	cmp	al,' '		;/
 00002F0D  74 F1	      C 	jz	@@0		;/
 00002F0F  4E		      C 	dec	esi		;/
			      C 	;
 00002F10		      C @@1:
 00002F10  80 3E 2F	      C 	cmp	b[esi],'/'	;option switch?
 00002F13  74 74	      C 	jz	@@Option		;/
 00002F15  80 3E 2D	      C 	cmp	b[esi],'-'	;/
 00002F18  74 6F	      C 	jz	@@Option		;/
 00002F1A  80 3E 2B	      C 	cmp	b[esi],'+'	;/
 00002F1D  74 6A	      C 	jz	@@Option		;/
			      C 	;
 00002F1F		      C @@2:
 00002F1F  33 DB	      C 	xor	ebx,ebx		;/
 00002F21  8A 1D 0000397B R   C 	mov	bl,OptionCounter	;Get file entry number.
 00002F27  FE 05 0000397B R   C 	inc	OptionCounter	;/
 00002F2D  C1 E3 02	      C 	shl	ebx,2		;/
 00002F30  81 C3 000039FC R   C 	add	ebx,offset OptionTable+128 ;/
 00002F36  8B 3D 00003BFC R   C 	mov	edi,OptionPointer	;Current free space pointer.
 00002F3C  89 3B	      C 	mov	[ebx],edi		;update table entry.
			      C 	;
 00002F3E  32 C9	      C 	xor	cl,cl
 00002F40		      C @@3:
 00002F40  80 3E 00	      C 	cmp	b[esi],0		;end of name?
 00002F43  74 0F	      C 	jz	@@4		;/
 00002F45  80 3E 20	      C 	cmp	b[esi],' '	;/
 00002F48  74 0A	      C 	jz	@@4		;/
 00002F4A  8A 06	      C 	mov	al,[esi]		;Copy this character.
 00002F4C  88 07	      C 	mov	[edi],al		;/
 00002F4E  46		      C 	inc	esi		;/
 00002F4F  47		      C 	inc	edi		;/
 00002F50  B1 01	      C 	mov	cl,1		;flag SOMETHING found.
 00002F52  EB EC	      C 	jmp	@@3		;keep fetching them.
			      C 	;
 00002F54		      C @@4:
 00002F54  C6 07 00	      C 	mov	b[edi],0		;Terminate the name.
 00002F57  47		      C 	inc	edi		;/
 00002F58  89 3D 00003BFC R   C 	mov	OptionPointer,edi	;Update table pointer.
			      C 	;
 00002F5E  0A C9	      C 	or	cl,cl		;Make sure we found something.
 00002F60  75 9E	      C 	jnz	@@0		;Go look for more info.
 00002F62  FF 0D 00003BFC R   C 	dec	OptionPointer
 00002F68  FE 0D 0000397B R   C 	dec	OptionCounter	;move pointer/counter back.
 00002F6E  33 DB	      C 	xor	ebx,ebx
 00002F70  8A 1D 0000397B R   C 	mov	bl,OptionCounter	;Get file entry number.
 00002F76  C1 E3 02	      C 	shl	ebx,2		;/
 00002F79  81 C3 000039FC R   C 	add	ebx,offset OptionTable+128 ;/
 00002F7F  66| C7 03 0000     C 	mov	w[ebx],0		;reset table entry.
 00002F84  E9 FFFFFF77	      C 	jmp	@@0
			      C 	;
 00002F89		      C @@Option:
 00002F89  8A 26	      C 	mov	ah,[esi]		;Get switch character.
 00002F8B  46		      C 	inc	esi
 00002F8C		      C @@5:
 00002F8C  80 3E 00	      C 	cmp	b[esi],0		;check for end of line.
 00002F8F  74 79	      C 	jz	@@9		;/
 00002F91  80 3E 20	      C 	cmp	b[esi],' '	;skip spaces.
 00002F94  75 03	      C 	jnz	@@6		;/
 00002F96  46		      C 	inc	esi		;/
 00002F97  EB F3	      C 	jmp	@@5		;/
			      C 	;
 00002F99		      C @@6:
 00002F99  8A 06	      C 	mov	al,[esi]		;get the switched character.
 00002F9B  24 7F	      C 	and	al,127
 00002F9D  46		      C 	inc	esi
 00002F9E  3C 61	      C 	cmp	al,61h		; 'a'
 00002FA0  72 06	      C 	jb	@@12
 00002FA2  3C 7A	      C 	cmp	al,7Ah		; 'z'
 00002FA4  77 02	      C 	ja	@@12
 00002FA6  24 5F	      C 	and	al,5Fh		;convert to upper case.
 00002FA8		      C @@12:
 00002FA8  33 DB	      C 	xor	ebx,ebx
 00002FAA  8A D8	      C 	mov	bl,al
 00002FAC  81 C3 0000397C R   C 	add	ebx,offset OptionTable	;Index into the table.
 00002FB2  80 FC 2D	      C 	cmp	ah,'-'
 00002FB5  75 02	      C 	jnz	@@7
 00002FB7  32 E4	      C 	xor	ah,ah		;Convert '-' to zero.
 00002FB9		      C @@7:
 00002FB9  88 23	      C 	mov	[ebx],ah		;Set flag accordingly.
			      C 	;
 00002FBB  80 3E 20	      C 	cmp	b[esi],' '	;check for assosiated text.
 00002FBE  0F 84 FFFFFF3C     C 	jz	@@0
 00002FC4  80 3E 00	      C 	cmp	b[esi],0
 00002FC7  74 41	      C 	jz	@@9
 00002FC9  80 3E 3D	      C 	cmp	b[esi],'='
 00002FCC  74 05	      C 	jz	@@900
 00002FCE  80 3E 3A	      C 	cmp	b[esi],':'	;allow colon as seperator.
 00002FD1  75 01	      C 	jnz	@@8
 00002FD3		      C @@900:
 00002FD3  46		      C 	inc	esi		;skip colon.
			      C 	;
 00002FD4		      C @@8:
 00002FD4  33 DB	      C 	xor	ebx,ebx
 00002FD6  8A D8	      C 	mov	bl,al		;Get the option number again.
 00002FD8  C1 E3 02	      C 	shl	ebx,2		; &
 00002FDB  81 C3 000039FC R   C 	add	ebx,offset OptionTable+128 ;index into the table.
 00002FE1  8B 3D 00003BFC R   C 	mov	edi,OptionPointer	;current position in the table.
 00002FE7  89 3B	      C 	mov	[ebx],edi		;store pointer in the table.
			      C 	;
 00002FE9		      C @@10:
 00002FE9  80 3E 00	      C 	cmp	b[esi],0		;end of line?
 00002FEC  74 1C	      C 	jz	@@9
 00002FEE  80 3E 20	      C 	cmp	b[esi],' '	;end of text?
 00002FF1  74 08	      C 	jz	@@11
 00002FF3  8A 06	      C 	mov	al,[esi]
 00002FF5  88 07	      C 	mov	[edi],al
 00002FF7  46		      C 	inc	esi
 00002FF8  47		      C 	inc	edi
 00002FF9  EB EE	      C 	jmp	@@10
			      C 	;
 00002FFB		      C @@11:
 00002FFB  C6 07 00	      C 	mov	b[edi],0		;terminate string.
 00002FFE  47		      C 	inc	edi
 00002FFF  89 3D 00003BFC R   C 	mov	OptionPointer,edi	;store new text pointer.
 00003005  E9 FFFFFEF6	      C 	jmp	@@0		;scan some more text.
 0000300A		      C @@9:
 0000300A  A0 0000397B R      C 	mov	al,OptionCounter
 0000300F  32 E4	      C 	xor	ah,ah
 00003011  66| 0B C0	      C 	or	ax,ax		;set flags for file names.
 00003014  8B 1D 000039FC R   C 	mov	ebx,d[OptionTable+128]	;point to first file name.
 0000301A  C3		      C 	ret
			      C ;
 0000301B		      C ReadCommand	endp
			      C 
			      C 
					include files.inc
			      C 
 00003D00		      C _DATA segment
			      C 
 00003D00 00000000	      C FileBufferCount dd 0
 00003D04 00000000	      C FileBufferPosition dd 0
			      C 
 00003D08  0000003C [	      C OpenFilesList	dw 60 dup (-1)	;Enough for 60 files.
	    FFFF
	   ]
			      C 
 0000301B		      C _DATA ends
			      C 
 0000058C		      C _BSS segment 
 0000058C  00000800 [	      C FileBuffer	db 2048 dup (?)
	    00
	   ]
 0000301B		      C _BSS ends
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 0000301B		      C OpenFile	proc	near
			      C ;
			      C ;Open a file and if succesful, add its handle to the list.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;DS:EDX	- File name pointer as normal.
			      C ;
			      C ;On Exit:-
			      C ;
			      C ;If carry clear,
			      C ;AX	- Handle for file.
			      C ;
			      C ;else file not opened.
			      C ;
 0000301B  66| B8 3D02	      C 	mov	ax,3d02h		;Open with read & write access.
 0000301F  CD 21	      C 	int	21h
 00003021  72 1F	      C 	jc	@@9
			      C 	;
 00003023  53		      C 	push	ebx
 00003024  51		      C 	push	ecx
 00003025  BB 00003D08 R      C 	mov	ebx,offset OpenFilesList	;Point at the list.
 0000302A  B9 0000003C	      C 	mov	ecx,60
 0000302F  66| 83 3B FF	      C @@0:	cmp	w[ebx],-1		;free entry?
 00003033  74 07	      C 	jz	@@1
 00003035  83 C3 02	      C 	add	ebx,2		;next entry.
 00003038  E2 F5	      C 	loop	@@0
 0000303A  EB 07	      C 	jmp	@@8
 0000303C  66| 89 03	      C @@1:	mov	[ebx],ax		;store this handle.
 0000303F  59		      C 	pop	ecx
 00003040  5B		      C 	pop	ebx
 00003041  F8		      C 	clc			;restore sucess flag.
 00003042  C3		      C @@9:	ret
			      C 	;
 00003043  66| 8B D8	      C @@8:	mov	bx,ax
 00003046  B4 3E	      C 	mov	ah,3eh		;close again cos not enough table space.
 00003048  CD 21	      C 	int	21h
 0000304A  59		      C 	pop	ecx
 0000304B  5B		      C 	pop	ebx
 0000304C  F9		      C 	stc
 0000304D  C3		      C 	ret
 0000304E		      C OpenFile	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 0000304E		      C CreateFile	proc	near
			      C ;
			      C ;Create a file and if succesful, add its handle to the list.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;DS:EDX	- File name pointer as normal.
			      C ;
			      C ;On Exit:-
			      C ;
			      C ;If carry clear,
			      C ;AX	- Handle for file.
			      C ;
			      C ;else file not created.
			      C ;
 0000304E  B4 3C	      C 	mov	ah,3ch		;Create function.
 00003050  66| 33 C9	      C 	xor	cx,cx		;normal attributes.
 00003053  CD 21	      C 	int	21h
 00003055  72 1F	      C 	jc	@@9
			      C 	;
 00003057  53		      C 	push	ebx
 00003058  51		      C 	push	ecx
 00003059  BB 00003D08 R      C 	mov	ebx,offset OpenFilesList	;Point at the list.
 0000305E  B9 0000003C	      C 	mov	ecx,60
 00003063  66| 83 3B FF	      C @@0:	cmp	w[ebx],-1		;free entry?
 00003067  74 07	      C 	jz	@@1
 00003069  83 C3 02	      C 	add	ebx,2		;next entry.
 0000306C  E2 F5	      C 	loop	@@0
 0000306E  EB 07	      C 	jmp	@@8
 00003070  66| 89 03	      C @@1:	mov	[ebx],ax		;store this handle.
 00003073  59		      C 	pop	ecx
 00003074  5B		      C 	pop	ebx
 00003075  F8		      C 	clc			;restore sucess flag.
 00003076  C3		      C @@9:	ret
			      C 	;
 00003077  66| 8B D8	      C @@8:	mov	bx,ax
 0000307A  B4 3E	      C 	mov	ah,3eh		;close again cos not enough table space.
 0000307C  CD 21	      C 	int	21h
 0000307E  59		      C 	pop	ecx
 0000307F  5B		      C 	pop	ebx
 00003080  F9		      C 	stc
 00003081  C3		      C 	ret
 00003082		      C CreateFile	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003082		      C SetFilePointer	proc	near
			      C ;
			      C ;Set the file pointer position for a file.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;AL	- Method
			      C ;BX	- Handle
			      C ;DX:CX	- 32-bit position.
			      C ;
			      C ;Methods are:-
			      C ;
			      C ;0	- Absolute offset from start.
			      C ;1	- signed offset from current position.
			      C ;2	- signed offset from end of file.
			      C ;
 00003082  66| 87 D1	      C 	xchg	dx,cx		;DOS has them in a stupid order.
 00003085  66| 53	      C 	push	bx
 00003087  B4 42	      C 	mov	ah,42h		;set pointer function.
 00003089  CD 21	      C 	int	21h
 0000308B  66| 5B	      C 	pop	bx
 0000308D  66| 8B C8	      C 	mov	cx,ax		;fetch small result.
 00003090  C3		      C 	ret
 00003091		      C SetFilePointer	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003091		      C ReadFile	proc	near
			      C ;
			      C ;Read some data from a file.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;BX	- Handle
			      C ;ECX	- Length
			      C ;EDI	- Position.
			      C ;
 00003091  33 D2	      C 	xor	edx,edx
 00003093		      C @@0:
			      C 	pushm	bx,ecx,edx,edi
 00003093  66| 53	     2C 	PUSH	bx			;SAVE THE REGISTER
 00003095  51		     2C 	PUSH	ecx			;SAVE THE REGISTER
 00003096  52		     2C 	PUSH	edx			;SAVE THE REGISTER
 00003097  57		     2C 	PUSH	edi			;SAVE THE REGISTER
 00003098  81 F9 0000FFFF     C 	cmp	ecx,65535		;size of chunks to load.
 0000309E  72 05	      C 	jc	@@2
 000030A0  B9 0000FFFF	      C 	mov	ecx,65535		;as close to 64k as can get.
 000030A5  8B D7	      C @@2:	mov	edx,edi
 000030A7  B4 3F	      C 	mov	ah,3fh
 000030A9  CD 21	      C 	int	21h		;read from the file.
			      C 	popm	bx,ecx,edx,edi
 000030AB  5F		     2C 	POP	edi				;POP THE REGISTER
 000030AC  5A		     2C 	POP	edx				;POP THE REGISTER
 000030AD  59		     2C 	POP	ecx				;POP THE REGISTER
 000030AE  66| 5B	     2C 	POP	bx				;POP THE REGISTER
 000030B0  72 17	      C 	jc	@@9
 000030B2  0F B7 C0	      C 	movzx	eax,ax		;get length read.
 000030B5  03 D0	      C 	add	edx,eax		;update length read counter.
 000030B7  2B C8	      C 	sub	ecx,eax		;update length counter.
 000030B9  03 F8	      C 	add	edi,eax		;move memory pointer.
 000030BB  0B C9	      C 	or	ecx,ecx
 000030BD  74 06	      C 	jz	@@8		;read as much as was wanted.
 000030BF  0B C0	      C 	or	eax,eax		;did we read anything?
 000030C1  74 02	      C 	jz	@@8
 000030C3  EB CE	      C 	jmp	@@0
 000030C5  8B C2	      C @@8:	mov	eax,edx		;get accumulated length read.
 000030C7  F8		      C 	clc
 000030C8  C3		      C 	ret
			      C 	;
 000030C9  F9		      C @@9:	stc
 000030CA  C3		      C 	ret
 000030CB		      C ReadFile	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 000030CB		      C WriteFile	proc	near
			      C ;
			      C ;Write some data to a file.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;BX	- Handle
			      C ;ECX	- Length
			      C ;ESI	- Position.
			      C ;
 000030CB  33 D2	      C 	xor	edx,edx
 000030CD		      C @@0:
			      C 	pushm	bx,ecx,edx,esi
 000030CD  66| 53	     2C 	PUSH	bx			;SAVE THE REGISTER
 000030CF  51		     2C 	PUSH	ecx			;SAVE THE REGISTER
 000030D0  52		     2C 	PUSH	edx			;SAVE THE REGISTER
 000030D1  56		     2C 	PUSH	esi			;SAVE THE REGISTER
 000030D2  81 F9 0000FFFF     C 	cmp	ecx,65535		;size of chunks to load.
 000030D8  72 05	      C 	jc	@@2
 000030DA  B9 0000FFFF	      C 	mov	ecx,65535		;as close to 64k as can get.
 000030DF  8B D6	      C @@2:	mov	edx,esi
 000030E1  B4 40	      C 	mov	ah,40h
 000030E3  CD 21	      C 	int	21h		;read from the file.
			      C 	popm	bx,ecx,edx,esi
 000030E5  5E		     2C 	POP	esi				;POP THE REGISTER
 000030E6  5A		     2C 	POP	edx				;POP THE REGISTER
 000030E7  59		     2C 	POP	ecx				;POP THE REGISTER
 000030E8  66| 5B	     2C 	POP	bx				;POP THE REGISTER
 000030EA  72 17	      C 	jc	@@9
 000030EC  0F B7 C0	      C 	movzx	eax,ax		;get length read.
 000030EF  03 D0	      C 	add	edx,eax		;update length read counter.
 000030F1  2B C8	      C 	sub	ecx,eax		;update length counter.
 000030F3  03 F0	      C 	add	esi,eax		;move memory pointer.
 000030F5  0B C9	      C 	or	ecx,ecx
 000030F7  74 06	      C 	jz	@@8		;read as much as was wanted.
 000030F9  0B C0	      C 	or	eax,eax		;did we write anything?
 000030FB  74 06	      C 	jz	@@9
 000030FD  EB CE	      C 	jmp	@@0
 000030FF  8B C2	      C @@8:	mov	eax,edx		;get accumulated length read.
 00003101  F8		      C 	clc
 00003102  C3		      C 	ret
			      C 	;
 00003103  F9		      C @@9:	stc
 00003104  C3		      C 	ret
 00003105		      C WriteFile	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003105		      C CloseFile	proc	near
			      C ;
			      C ;Close a file and delete its handle from the list.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;BX	- Handle for file to close.
			      C ;
			      C 	pushm	ax,ebx,ecx
 00003105  66| 50	     2C 	PUSH	ax			;SAVE THE REGISTER
 00003107  53		     2C 	PUSH	ebx			;SAVE THE REGISTER
 00003108  51		     2C 	PUSH	ecx			;SAVE THE REGISTER
 00003109  66| 8B C3	      C 	mov	ax,bx
 0000310C  BB 00003D08 R      C 	mov	ebx,offset OpenFilesList	;Point at the list.
 00003111  B9 0000003C	      C 	mov	ecx,60
 00003116  66| 39 03	      C @@0:	cmp	[ebx],ax		;right entry?
 00003119  74 07	      C 	jz	@@1
 0000311B  83 C3 02	      C 	add	ebx,2		;next entry.
 0000311E  E2 F6	      C 	loop	@@0
 00003120  EB 0E	      C 	jmp	@@9
 00003122  66| C7 03 FFFF     C @@1:	mov	w[ebx],-1		;clear this handle.
			      C 	popm	ax,ebx,ecx
 00003127  59		     2C 	POP	ecx				;POP THE REGISTER
 00003128  5B		     2C 	POP	ebx				;POP THE REGISTER
 00003129  66| 58	     2C 	POP	ax				;POP THE REGISTER
 0000312B  B4 3E	      C 	mov	ah,3eh		;close file function.
 0000312D  CD 21	      C 	int	21h
 0000312F  C3		      C 	ret
 00003130		      C @@9:
			      C 	popm	ax,ebx,ecx
 00003130  59		     2C 	POP	ecx				;POP THE REGISTER
 00003131  5B		     2C 	POP	ebx				;POP THE REGISTER
 00003132  66| 58	     2C 	POP	ax				;POP THE REGISTER
 00003134  F9		      C 	stc
 00003135  C3		      C 	ret
 00003136		      C CloseFile	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003136		      C CloseAllFiles	proc	near
			      C ;
			      C ;Close all files in the list.
			      C ;
 00003136  66| 50	      C 	push	ax
 00003138  53		      C 	push	ebx
 00003139  51		      C 	push	ecx
 0000313A  BB 00003D08 R      C 	mov	ebx,offset OpenFilesList	;Point at the list.
 0000313F  B9 0000003C	      C 	mov	ecx,60		;size OpenFilesList /2
 00003144  66| 83 3B 00	      C @@0:	cmp	w[ebx],0		;used entry?
 00003148  75 0A	      C 	jnz	@@2
 0000314A  83 C3 02	      C @@1:	add	ebx,2		;next entry.
 0000314D  E2 F5	      C 	loop	@@0
 0000314F  59		      C 	pop	ecx
 00003150  5B		      C 	pop	ebx
 00003151  66| 58	      C 	pop	ax
 00003153  C3		      C 	ret
 00003154  53		      C @@2:	push	ebx
 00003155  51		      C 	push	ecx
 00003156  66| 8B 1B	      C 	mov	bx,[ebx]		;get this handle.
 00003159  B4 3E	      C 	mov	ah,3eh		;close file function.
 0000315B  CD 21	      C 	int	21h
 0000315D  59		      C 	pop	ecx
 0000315E  5B		      C 	pop	ebx
 0000315F  EB E9	      C 	jmp	@@1
 00003161		      C CloseAllFiles	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003161		      C DeleteFile	proc	near
			      C ;
			      C ;Delete a file.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;DS:EDX	- File name to delete.
			      C ;
 00003161  B4 41	      C 	mov	ah,41h
 00003163  CD 21	      C 	int	21h
 00003165  C3		      C 	ret
 00003166		      C DeleteFile	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003166		      C ReadLine	proc	near
			      C ;
			      C ;Read a line of text from input file specified.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;BX	- File handle.
			      C ;DS:EDI	- Buffer address.
			      C ;
			      C ;On Exit:-
			      C ;
			      C ;AX	- Status.
			      C ;	0 - Line is in the buffer.
			      C ;	1 - EOF.
			      C ;
			      C ;CX	- Line length.
			      C ;
 00003166  66| 33 C9	      C 	xor	cx,cx		;reset bytes so far count.
 00003169		      C @@0:
			      C ;	pushm	bx,cx,edi
			      C 
 00003169  E8 00000073	      C 	call	ReadBufferByte
			      C 
			      C ;	mov	edx,edi
			      C ;	mov	cx,1
			      C ;	mov	ah,3fh
			      C ;	int	21h		;read a byte.
			      C 
			      C ;	popm	bx,cx,edi
 0000316E  72 64	      C 	jc	@@9
 00003170  66| 0B C0	      C 	or	ax,ax		;read anything?
 00003173  74 51	      C 	jz	@@CheckEOF
 00003175  80 3F 0D	      C 	cmp	b[edi],13		;EOL?
 00003178  74 11	      C 	jz	@@CheckLF
 0000317A  80 3F 1A	      C 	cmp	b[edi],26
 0000317D  74 27	      C 	jz	@@SoftEOF		;move to the end of the file, then do an EOL.
 0000317F  47		      C 	inc	edi
 00003180  66| 41	      C 	inc	cx
 00003182  66| 81 F9 0400     C 	cmp	cx,1024		;line getting a bit long?
 00003187  73 1D	      C 	jnc	@@SoftEOF
 00003189  EB DE	      C 	jmp	@@0		;keep going.
			      C 	;
 0000318B  C6 07 00	      C @@CheckLF:	mov	b[edi],0		;terminate this line.
 0000318E  47		      C 	inc	edi
			      C ;	pushm	bx,cx,edi
			      C 
 0000318F  E8 0000004D	      C 	call	ReadBufferByte
			      C 
			      C ;	mov	edx,edi
			      C ;	mov	cx,1
			      C ;	mov	ah,3fh
			      C ;	int	21h		;read a byte.
			      C 
			      C ;	popm	bx,cx,edi
 00003194  66| 0B C0	      C 	or	ax,ax		;read anything?
 00003197  74 3B	      C 	jz	@@9		;no LF here is an error.
 00003199  80 3F 0A	      C 	cmp	b[edi],10		;/
 0000319C  75 36	      C 	jnz	@@9		;/
			      C 	;
 0000319E  C6 07 00	      C @@EOL:	mov	b[edi],0		;terminate the line.
 000031A1  66| 33 C0	      C 	xor	ax,ax
 000031A4  F8		      C 	clc
 000031A5  C3		      C 	ret
			      C 	;
 000031A6		      C @@SoftEOF:
			      C 	pushm	bx,cx,edi
 000031A6  66| 53	     2C 	PUSH	bx			;SAVE THE REGISTER
 000031A8  66| 51	     2C 	PUSH	cx			;SAVE THE REGISTER
 000031AA  57		     2C 	PUSH	edi			;SAVE THE REGISTER
 000031AB  66| 33 C9	      C 	xor	cx,cx
 000031AE  66| 8B D1	      C 	mov	dx,cx
 000031B1  66| B8 4202	      C 	mov	ax,4202h		;move to the end of the file.
 000031B5  CD 21	      C 	int	21h
			      C 	popm	bx,cx,edi		;fall through to treat like hard EOF.
 000031B7  5F		     2C 	POP	edi				;POP THE REGISTER
 000031B8  66| 59	     2C 	POP	cx				;POP THE REGISTER
 000031BA  66| 5B	     2C 	POP	bx				;POP THE REGISTER
 000031BC  C7 05 00003D00 R   C 	mov	FileBufferCount,0
	   00000000
			      C 	;
 000031C6  66| 0B C9	      C @@CheckEOF:	or	cx,cx		;read anything on this line yet?
 000031C9  75 D3	      C 	jnz	@@EOL		;do EOL this time.
			      C 	;
 000031CB  C6 07 00	      C @@EOF:	mov	b[edi],0		;terminate the line.
 000031CE  66| B8 0001	      C 	mov	ax,1
 000031D2  F8		      C 	clc
 000031D3  C3		      C 	ret
			      C 	;
 000031D4  F9		      C @@9:	stc
 000031D5  C3		      C 	ret
 000031D6		      C ReadLine	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 000031D6		      C InitFileBuffer	proc	near
 000031D6  C7 05 00003D00 R   C 	mov	FileBufferCount,0
	   00000000
 000031E0  C3		      C 	ret
 000031E1		      C InitFileBuffer	endp
			      C 
			      C 
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 000031E1		      C ReadBufferByte	proc	near
 000031E1  66| B8 0000	      C 	mov	ax,0
 000031E5  83 3D 00003D00 R   C 	cmp	FileBufferCount,0
	   00
 000031EC  75 2E	      C 	jnz	@@0
			      C 	;
			      C 	;Need to re-fill the buffer.
			      C 	;
			      C 	pushm	eax,ebx,ecx,edx,esi,edi,ebp
 000031EE  50		     2C 	PUSH	eax			;SAVE THE REGISTER
 000031EF  53		     2C 	PUSH	ebx			;SAVE THE REGISTER
 000031F0  51		     2C 	PUSH	ecx			;SAVE THE REGISTER
 000031F1  52		     2C 	PUSH	edx			;SAVE THE REGISTER
 000031F2  56		     2C 	PUSH	esi			;SAVE THE REGISTER
 000031F3  57		     2C 	PUSH	edi			;SAVE THE REGISTER
 000031F4  55		     2C 	PUSH	ebp			;SAVE THE REGISTER
 000031F5  BF 0000058C R      C 	mov	edi,offset FileBuffer
 000031FA  B9 00000400	      C 	mov	ecx,1024
 000031FF  E8 FFFFFE8D	      C 	call	ReadFile
 00003204  A3 00003D00 R      C 	mov	FileBufferCount,eax
 00003209  C7 05 00003D04 R   C 	mov	FileBufferPosition,offset FileBuffer
	   0000058C R
			      C 	popm	eax,ebx,ecx,edx,esi,edi,ebp
 00003213  5D		     2C 	POP	ebp				;POP THE REGISTER
 00003214  5F		     2C 	POP	edi				;POP THE REGISTER
 00003215  5E		     2C 	POP	esi				;POP THE REGISTER
 00003216  5A		     2C 	POP	edx				;POP THE REGISTER
 00003217  59		     2C 	POP	ecx				;POP THE REGISTER
 00003218  5B		     2C 	POP	ebx				;POP THE REGISTER
 00003219  58		     2C 	POP	eax				;POP THE REGISTER
 0000321A  72 23	      C 	jc	@@9
			      C 	;
 0000321C		      C @@0:
 0000321C  83 3D 00003D00 R   C 	cmp	FileBufferCount,0	;still zero?
	   00
 00003223  74 19	      C 	jz	@@8
 00003225  66| 40	      C 	inc	ax		;getting a byte then.
			      C 	pushm	esi,edi
 00003227  56		     2C 	PUSH	esi			;SAVE THE REGISTER
 00003228  57		     2C 	PUSH	edi			;SAVE THE REGISTER
 00003229  8B 35 00003D04 R   C 	mov	esi,FileBufferPosition
 0000322F  A4		      C 	movsb
 00003230  89 35 00003D04 R   C 	mov	FileBufferPosition,esi
 00003236  FF 0D 00003D00 R   C 	dec	FileBufferCount
			      C 	popm	esi,edi
 0000323C  5F		     2C 	POP	edi				;POP THE REGISTER
 0000323D  5E		     2C 	POP	esi				;POP THE REGISTER
			      C 	;
 0000323E		      C @@8:
 0000323E  F8		      C 	clc
 0000323F		      C @@9:
 0000323F  C3		      C 	ret
 00003240		      C ReadBufferByte	endp
			      C 
			      C 
					include print.inc
			      C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
 00003240		      C StringPrint	proc	near
			      C ;
			      C ;Print characters on the screen.
			      C ;
			      C ;On Entry:-
			      C ;
			      C ;DS:EDX	- String (0 terminated)
			      C ;
			      C ;ALL registers preserved.
			      C ;
			      C 	pushm	eax,ebx,ecx,edx,esi,edi,ebp
 00003240  50		     2C 	PUSH	eax			;SAVE THE REGISTER
 00003241  53		     2C 	PUSH	ebx			;SAVE THE REGISTER
 00003242  51		     2C 	PUSH	ecx			;SAVE THE REGISTER
 00003243  52		     2C 	PUSH	edx			;SAVE THE REGISTER
 00003244  56		     2C 	PUSH	esi			;SAVE THE REGISTER
 00003245  57		     2C 	PUSH	edi			;SAVE THE REGISTER
 00003246  55		     2C 	PUSH	ebp			;SAVE THE REGISTER
 00003247  8B F2	      C 	mov	esi,edx
 00003249		      C @@0:
 00003249  8A 06	      C 	mov	al,[esi]
 0000324B  46		      C 	inc	esi
 0000324C  0A C0	      C 	or	al,al
 0000324E  74 0A	      C 	jz	@@9
 00003250  56		      C 	push	esi
 00003251  8A D0	      C 	mov	dl,al
 00003253  B4 02	      C 	mov	ah,2
 00003255  CD 21	      C 	int	21h
 00003257  5E		      C 	pop	esi
 00003258  EB EF	      C 	jmp	@@0
 0000325A		      C @@9:
			      C 	popm	eax,ebx,ecx,edx,esi,edi,ebp
 0000325A  5D		     2C 	POP	ebp				;POP THE REGISTER
 0000325B  5F		     2C 	POP	edi				;POP THE REGISTER
 0000325C  5E		     2C 	POP	esi				;POP THE REGISTER
 0000325D  5A		     2C 	POP	edx				;POP THE REGISTER
 0000325E  59		     2C 	POP	ecx				;POP THE REGISTER
 0000325F  5B		     2C 	POP	ebx				;POP THE REGISTER
 00003260  58		     2C 	POP	eax				;POP THE REGISTER
 00003261  C3		      C 	ret
 00003262		      C StringPrint	endp
			      C 
			      C 
			      C 
			      C  
			      C 
				
				ifndef CWAPP
				endif
				
					end start
Microsoft (R) Macro Assembler Version 6.15.8803		    03/27/25 15:40:27
CWEM.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

@dprintf . . . . . . . . . . . .	Proc
Popm . . . . . . . . . . . . . .	Proc
Pushm  . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Desc . . . . . . . . . . . . . .	 00000008
  Limit  . . . . . . . . . . . .	 00000000	 Word
  Base_l . . . . . . . . . . . .	 00000002	 Word
  Base_m . . . . . . . . . . . .	 00000004	 Byte
  Access . . . . . . . . . . . .	 00000005	 Byte
  Gran . . . . . . . . . . . . .	 00000006	 Byte
  Base_H . . . . . . . . . . . .	 00000007	 Byte
GATE . . . . . . . . . . . . . .	 00000008
  OfsLow . . . . . . . . . . . .	 00000000	 Word
  sel  . . . . . . . . . . . . .	 00000002	 Word
  attr . . . . . . . . . . . . .	 00000004	 Word
  OfsHigh  . . . . . . . . . . .	 00000006	 Word
LE_Header  . . . . . . . . . . .	 000000C4
  LE_ID  . . . . . . . . . . . .	 00000000	 Word
  LE_ByteOrder . . . . . . . . .	 00000002	 Byte
  LE_WordOrder . . . . . . . . .	 00000003	 Byte
  LE_Format  . . . . . . . . . .	 00000004	 DWord
  LE_CPU . . . . . . . . . . . .	 00000008	 Word
  LE_OS  . . . . . . . . . . . .	 0000000A	 Word
  LE_Version . . . . . . . . . .	 0000000C	 DWord
  LE_Type  . . . . . . . . . . .	 00000010	 DWord
  LE_Pages . . . . . . . . . . .	 00000014	 DWord
  LE_EntryCS . . . . . . . . . .	 00000018	 DWord
  LE_EntryEIP  . . . . . . . . .	 0000001C	 DWord
  LE_EntrySS . . . . . . . . . .	 00000020	 DWord
  LE_EntryESP  . . . . . . . . .	 00000024	 DWord
  LE_PageSize  . . . . . . . . .	 00000028	 DWord
  LE_LastBytes . . . . . . . . .	 0000002C	 DWord
  LE_FixupSize . . . . . . . . .	 00000030	 DWord
  LE_FixupChk  . . . . . . . . .	 00000034	 DWord
  LE_LoaderSize  . . . . . . . .	 00000038	 DWord
  LE_LoaderChk . . . . . . . . .	 0000003C	 DWord
  LE_ObjOffset . . . . . . . . .	 00000040	 DWord
  LE_ObjNum  . . . . . . . . . .	 00000044	 DWord
  LE_PageMap . . . . . . . . . .	 00000048	 DWord
  LE_IterateMap  . . . . . . . .	 0000004C	 DWord
  LE_Resource  . . . . . . . . .	 00000050	 DWord
  LE_ResourceNum . . . . . . . .	 00000054	 DWord
  LE_ResidentNames . . . . . . .	 00000058	 DWord
  LE_EntryTable  . . . . . . . .	 0000005C	 DWord
  LE_Directives  . . . . . . . .	 00000060	 DWord
  LE_DirectivesNum . . . . . . .	 00000064	 DWord
  LE_Fixups  . . . . . . . . . .	 00000068	 DWord
  LE_FixupsRec . . . . . . . . .	 0000006C	 DWord
  LE_ImportModNames  . . . . . .	 00000070	 DWord
  LE_ImportModNum  . . . . . . .	 00000074	 DWord
  LE_ImportNames . . . . . . . .	 00000078	 DWord
  LE_PageChk . . . . . . . . . .	 0000007C	 DWord
  LE_Data  . . . . . . . . . . .	 00000080	 DWord
  LE_PreLoadNum  . . . . . . . .	 00000084	 DWord
  LE_NoneRes . . . . . . . . . .	 00000088	 DWord
  LE_NoneResSize . . . . . . . .	 0000008C	 DWord
  LE_NoneResChk  . . . . . . . .	 00000090	 DWord
  LE_AutoDS  . . . . . . . . . .	 00000094	 DWord
  LE_Debug . . . . . . . . . . .	 00000098	 DWord
  LE_DebugSize . . . . . . . . .	 0000009C	 DWord
  LE_PreLoadInstNum  . . . . . .	 000000A0	 DWord
  LE_DemandInstNum . . . . . . .	 000000A4	 DWord
  LE_HeapExtra . . . . . . . . .	 000000A8	 DWord
  LE_Reserved  . . . . . . . . .	 000000AC	 Byte
  LE_DeviceID  . . . . . . . . .	 000000C0	 Word
  LE_DDK . . . . . . . . . . . .	 000000C2	 Word
MZHdr  . . . . . . . . . . . . .	 0000001B
  Signature  . . . . . . . . . .	 00000000	 Word
  _Length  . . . . . . . . . . .	 00000002	 Word
  RelocNum . . . . . . . . . . .	 00000006	 Word
  HeaderSize . . . . . . . . . .	 00000008	 Word
  MinAlloc . . . . . . . . . . .	 0000000A	 Word
  MaxAlloc . . . . . . . . . . .	 0000000C	 Word
  StackSeg . . . . . . . . . . .	 0000000E	 Word
  EntrySP  . . . . . . . . . . .	 00000010	 Word
  CheckSum . . . . . . . . . . .	 00000012	 Word
  EntryIP  . . . . . . . . . . .	 00000014	 Word
  EntryCS  . . . . . . . . . . .	 00000016	 Word
  RelocFirst . . . . . . . . . .	 00000018	 Word
  OverlayNum . . . . . . . . . .	 0000001A	 Byte
NewHeaderStruc . . . . . . . . .	 00000040
  NewID  . . . . . . . . . . . .	 00000000	 Byte
  NewSize  . . . . . . . . . . .	 00000002	 DWord
  NewLength  . . . . . . . . . .	 00000006	 DWord
  NewAlloc . . . . . . . . . . .	 0000000A	 DWord
  NewSegments  . . . . . . . . .	 0000000E	 Word
  NewRelocs  . . . . . . . . . .	 00000010	 DWord
  NewEntryEIP  . . . . . . . . .	 00000014	 DWord
  NewEntryCS . . . . . . . . . .	 00000018	 Word
  NewEntryESP  . . . . . . . . .	 0000001A	 DWord
  NewEntrySS . . . . . . . . . .	 0000001E	 Word
  NewFlags . . . . . . . . . . .	 00000020	 DWord
  NewAutoStack . . . . . . . . .	 00000024	 DWord
  NewAutoDS  . . . . . . . . . .	 00000028	 Word
  NewExports . . . . . . . . . .	 0000002A	 DWord
  NewImports . . . . . . . . . .	 0000002E	 DWord
  NewImportModCnt  . . . . . . .	 00000032	 DWord
  NewReserved  . . . . . . . . .	 00000036	 Byte
PSP_Struc  . . . . . . . . . . .	 00000100
  PSP_INT20  . . . . . . . . . .	 00000000	 Word
  PSP_MemTop . . . . . . . . . .	 00000002	 Word
  PSP_Filler1  . . . . . . . . .	 00000004	 Byte
  PSP_CPM  . . . . . . . . . . .	 00000005	 Byte
  PSP_INT22  . . . . . . . . . .	 0000000A	 DWord
  PSP_INT23  . . . . . . . . . .	 0000000E	 DWord
  PSP_INT24  . . . . . . . . . .	 00000012	 DWord
  PSP_Parent . . . . . . . . . .	 00000016	 Word
  PSP_HandleList . . . . . . . .	 00000018	 Byte
  PSP_Environment  . . . . . . .	 0000002C	 Word
  PSP_INT21SSSP  . . . . . . . .	 0000002E	 DWord
  PSP_Handles  . . . . . . . . .	 00000032	 Word
  PSP_HandlePtr  . . . . . . . .	 00000034	 DWord
  PSP_Previous . . . . . . . . .	 00000038	 DWord
  PSP_Filler2  . . . . . . . . .	 0000003C	 DWord
  PSP_DOSVersion . . . . . . . .	 00000040	 Word
  PSP_NextPSP  . . . . . . . . .	 00000042	 Word
  PSP_Filler3  . . . . . . . . .	 00000044	 DWord
  PSP_WinOldAp . . . . . . . . .	 00000048	 Byte
  PSP_Filler4  . . . . . . . . .	 00000049	 Byte
  PSP_INT21  . . . . . . . . . .	 00000050	 Byte
  PSP_Filler5  . . . . . . . . .	 00000053	 Byte
  PSP_FCB1 . . . . . . . . . . .	 0000005C	 Byte
  PSP_FCB2 . . . . . . . . . . .	 0000006C	 Byte
  PSP_Filler6  . . . . . . . . .	 0000007C	 DWord
  PSP_CommandTail  . . . . . . .	 00000080	 Byte
ResHead  . . . . . . . . . . . .	 0000000C
  ResHead_Prev . . . . . . . . .	 00000000	 DWord
  ResHead_Next . . . . . . . . .	 00000004	 DWord
  ResHead_Handle . . . . . . . .	 00000008	 DWord
TSSFields  . . . . . . . . . . .	 00000068
  Back . . . . . . . . . . . . .	 00000000	 Word
  ESP0 . . . . . . . . . . . . .	 00000004	 DWord
  SS0  . . . . . . . . . . . . .	 00000008	 Word
  ESP1 . . . . . . . . . . . . .	 0000000C	 DWord
  SS1  . . . . . . . . . . . . .	 00000010	 Word
  ESP2 . . . . . . . . . . . . .	 00000014	 DWord
  SS2  . . . . . . . . . . . . .	 00000018	 Word
  tCR3 . . . . . . . . . . . . .	 0000001C	 DWord
  tEIP . . . . . . . . . . . . .	 00000020	 DWord
  tEFlags  . . . . . . . . . . .	 00000024	 DWord
  tEAX . . . . . . . . . . . . .	 00000028	 DWord
  tECX . . . . . . . . . . . . .	 0000002C	 DWord
  tEDX . . . . . . . . . . . . .	 00000030	 DWord
  tEBX . . . . . . . . . . . . .	 00000034	 DWord
  tESP . . . . . . . . . . . . .	 00000038	 DWord
  tEBP . . . . . . . . . . . . .	 0000003C	 DWord
  tESI . . . . . . . . . . . . .	 00000040	 DWord
  tEDI . . . . . . . . . . . . .	 00000044	 DWord
  tES  . . . . . . . . . . . . .	 00000048	 DWord
  tCS  . . . . . . . . . . . . .	 0000004C	 DWord
  tSS  . . . . . . . . . . . . .	 00000050	 DWord
  tDS  . . . . . . . . . . . . .	 00000054	 DWord
  tFS  . . . . . . . . . . . . .	 00000058	 DWord
  tGS  . . . . . . . . . . . . .	 0000005C	 DWord
  tLDT . . . . . . . . . . . . .	 00000060	 Word
  IOMap  . . . . . . . . . . . .	 00000066	 Word
_Seg_  . . . . . . . . . . . . .	 00000010
  Seg_BaseAddress  . . . . . . .	 00000000	 DWord
  Seg_Type . . . . . . . . . . .	 00000004	 DWord
  Seg_Length . . . . . . . . . .	 00000008	 DWord
  Seg_Memory . . . . . . . . . .	 0000000C	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 DWord	  Stack	  'STACK'	 
_BSS . . . . . . . . . . . . . .	32 Bit	 00000D8C DWord	  Public  'BSS'  
_DATA  . . . . . . . . . . . . .	32 Bit	 00003D80 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00003262 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ASCII2Bin  . . . . . . . . . . .	P Near	 00002B41 _TEXT	Length= 00000023 Public
  @@Dec  . . . . . . . . . . . .	L Near	 00002B5A _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00002B60 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00002B62 _TEXT	
AddRelocationEntry . . . . . . .	P Near	 00000F2F _TEXT	Length= 0000004D Public
  @@0  . . . . . . . . . . . . .	L Near	 00000F51 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00000F79 _TEXT	
  @@10 . . . . . . . . . . . . .	L Near	 00000F7A _TEXT	
Bin2Hex  . . . . . . . . . . . .	P Near	 00001DD7 _TEXT	Length= 0000002E Public
  @@0  . . . . . . . . . . . . .	L Near	 00001DE3 _TEXT	
Bord . . . . . . . . . . . . . .	P Near	 00002E66 _TEXT	Length= 0000001B Public
CloseAllFiles  . . . . . . . . .	P Near	 00003136 _TEXT	Length= 0000002B Public
  @@0  . . . . . . . . . . . . .	L Near	 00003144 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 0000314A _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00003154 _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00003105 _TEXT	Length= 00000031 Public
  @@0  . . . . . . . . . . . . .	L Near	 00003116 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00003122 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00003130 _TEXT	
Create3PFile . . . . . . . . . .	P Near	 00000F7C _TEXT	Length= 00000192 Public
  @@0  . . . . . . . . . . . . .	L Near	 00000FB7 _TEXT	
  @@0_0  . . . . . . . . . . . .	L Near	 00000FE5 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 0000107D _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 0000108F _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00001095 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 000010A7 _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 000010D6 _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 000010E5 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 000010EB _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 0000110C _TEXT	
Create3PHeader . . . . . . . . .	P Near	 00000B0B _TEXT	Length= 00000084 Public
  @@0  . . . . . . . . . . . . .	L Near	 00000B4A _TEXT	
CreateFile . . . . . . . . . . .	P Near	 0000304E _TEXT	Length= 00000034 Public
  @@0  . . . . . . . . . . . . .	L Near	 00003063 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00003070 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00003076 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00003077 _TEXT	
CreateRelocations  . . . . . . .	P Near	 00000B8F _TEXT	Length= 000003A0 Public
  @@0  . . . . . . . . . . . . .	L Near	 00000BE6 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00000C05 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00000C2A _TEXT	
  @@Seg16  . . . . . . . . . . .	L Near	 00000CA8 _TEXT	
  @@Neg0 . . . . . . . . . . . .	L Near	 00000D0B _TEXT	
  @@32BitOff . . . . . . . . . .	L Near	 00000D16 _TEXT	
  @@Big0 . . . . . . . . . . . .	L Near	 00000D57 _TEXT	
  @@Neg1 . . . . . . . . . . . .	L Near	 00000D8D _TEXT	
  @@Self32Off  . . . . . . . . .	L Near	 00000DA7 _TEXT	
  @@sfBig0 . . . . . . . . . . .	L Near	 00000DEF _TEXT	
  @@sfNeg1 . . . . . . . . . . .	L Near	 00000DF9 _TEXT	
  @@Seg1632BitOff  . . . . . . .	L Near	 00000E13 _TEXT	
  @@Big1 . . . . . . . . . . . .	L Near	 00000EAB _TEXT	
  @@Neg2 . . . . . . . . . . . .	L Near	 00000EDD _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00000EF0 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00000EFE _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00000F2B _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00000F2D _TEXT	
DeleteFile . . . . . . . . . . .	P Near	 00003161 _TEXT	Length= 00000005 Public
Entry  . . . . . . . . . . . . .	P Far	 000001CC _TEXT	Length= 00000358 Public
  @@NoGroupDel . . . . . . . . .	L Near	 00000267 _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 00000280 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00000289 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 0000029C _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 000002A3 _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 000002AD _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 000002B9 _TEXT	
  @@10a  . . . . . . . . . . . .	L Near	 000002D5 _TEXT	
  @@70 . . . . . . . . . . . . .	L Near	 000002ED _TEXT	
  noslash  . . . . . . . . . . .	L Near	 000002F5 _TEXT	
  nextchar . . . . . . . . . . .	L Near	 00000300 _TEXT	
  @@LEReset  . . . . . . . . . .	L Near	 000003CC _TEXT	
  @@DoEXE  . . . . . . . . . . .	L Near	 00000426 _TEXT	
  medexe2  . . . . . . . . . . .	L Near	 00000438 _TEXT	
  @@Reset  . . . . . . . . . . .	L Near	 00000496 _TEXT	
  @@Info . . . . . . . . . . . .	L Near	 000004B3 _TEXT	
  @@update . . . . . . . . . . .	L Near	 000004C3 _TEXT	
  @@fastload . . . . . . . . . .	L Near	 000004D3 _TEXT	
  @@DualMode . . . . . . . . . .	L Near	 000004E3 _TEXT	
  @@InfoDump . . . . . . . . . .	L Near	 000004E3 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 0000051E _TEXT	
ExeAndMap2NewExe . . . . . . . .	P Near	 0000170D _TEXT	Length= 0000003C Public
  @@9  . . . . . . . . . . . . .	L Near	 00001748 _TEXT	
FastLoad3P . . . . . . . . . . .	P Near	 00000588 _TEXT	Length= 0000030F Public
  @@SymbolCount  . . . . . . . .	DWord	 bp - 00000004
  @@iValue . . . . . . . . . . .	DWord	 bp - 00000008
  @@vValue . . . . . . . . . . .	DWord	 bp - 0000000C
  medexe3  . . . . . . . . . . .	L Near	 00000611 _TEXT	
  @@00 . . . . . . . . . . . . .	L Near	 00000703 _TEXT	
  @@sethloop . . . . . . . . . .	L Near	 00000731 _TEXT	
  @@sort2  . . . . . . . . . . .	L Near	 0000073A _TEXT	
  @@hloop  . . . . . . . . . . .	L Near	 0000073C _TEXT	
  @@iloop  . . . . . . . . . . .	L Near	 0000074A _TEXT	
  @@whileloop  . . . . . . . . .	L Near	 00000765 _TEXT	
  @@dochange . . . . . . . . . .	L Near	 00000794 _TEXT	
  @@whilefail  . . . . . . . . .	L Near	 000007BE _TEXT	
  @@nexth  . . . . . . . . . . .	L Near	 000007DB _TEXT	
  @@sortend  . . . . . . . . . .	L Near	 000007EC _TEXT	
  @@01 . . . . . . . . . . . . .	L Near	 000007F8 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 0000087F _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00000895 _TEXT	
FetchLEFile  . . . . . . . . . .	P Near	 0000110E _TEXT	Length= 000000E1 Public
  @@9  . . . . . . . . . . . . .	L Near	 000011ED _TEXT	
GetMemLinear32 . . . . . . . . .	P Near	 00002E8C _TEXT	Length= 0000001D Public
  fail . . . . . . . . . . . . .	L Near	 00002EA3 _TEXT	
InitFileBuffer . . . . . . . . .	P Near	 000031D6 _TEXT	Length= 0000000B Public
LECloseFile  . . . . . . . . . .	P Near	 00001250 _TEXT	Length= 00000007 Public
LECreateFile . . . . . . . . . .	P Near	 000011EF _TEXT	Length= 00000018 Public
  l0 . . . . . . . . . . . . . .	L Near	 00001201 _TEXT	
LEMalloc . . . . . . . . . . . .	P Near	 00001257 _TEXT	Length= 00000010 Public
  l0 . . . . . . . . . . . . . .	L Near	 00001262 _TEXT	
  l1 . . . . . . . . . . . . . .	L Near	 00001265 _TEXT	
LEOpenFile . . . . . . . . . . .	P Near	 000012B4 _TEXT	Length= 00000015 Public
  l0 . . . . . . . . . . . . . .	L Near	 000012C4 _TEXT	
LEPrintString  . . . . . . . . .	P Near	 000012C9 _TEXT	Length= 00000014 Public
  l0 . . . . . . . . . . . . . .	L Near	 000012CC _TEXT	
  l1 . . . . . . . . . . . . . .	L Near	 000012D9 _TEXT	
LEProcess  . . . . . . . . . . .	P Near	 00000897 _TEXT	Length= 0000002E Public
  @@9  . . . . . . . . . . . . .	L Near	 000008C4 _TEXT	
LEReMalloc . . . . . . . . . . .	P Near	 0000123E _TEXT	Length= 00000012 Public
  l0 . . . . . . . . . . . . . .	L Near	 0000124A _TEXT	
  l1 . . . . . . . . . . . . . .	L Near	 0000124D _TEXT	
LEReadFile . . . . . . . . . . .	P Near	 00001267 _TEXT	Length= 00000035 Public
  @@0  . . . . . . . . . . . . .	L Near	 0000126C _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 0000127D _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00001296 _TEXT	
LESetFilePointer . . . . . . . .	P Near	 0000129C _TEXT	Length= 00000018 Public
LEWriteFile  . . . . . . . . . .	P Near	 00001207 _TEXT	Length= 00000037 Public
  @@0  . . . . . . . . . . . . .	L Near	 0000120C _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 0000121D _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00001238 _TEXT	
NewCauseWay  . . . . . . . . . .	P Near	 000012DD _TEXT	Length= 000003A1 Public
  medexe5  . . . . . . . . . . .	L Near	 000013C0 _TEXT	
  medexe6  . . . . . . . . . . .	L Near	 000014E5 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00001676 _TEXT	
NewExeInfo . . . . . . . . . . .	P Near	 00001749 _TEXT	Length= 0000068E Public
  @@10 . . . . . . . . . . . . .	L Near	 000017CC _TEXT	
  medexe7  . . . . . . . . . . .	L Near	 000017DE _TEXT	
  @@Look3P . . . . . . . . . . .	L Near	 00001800 _TEXT	
  @@its16  . . . . . . . . . . .	L Near	 0000186B _TEXT	
  @@NoSpeed  . . . . . . . . . .	L Near	 00001887 _TEXT	
  @@NotComp  . . . . . . . . . .	L Near	 00001BBE _TEXT	
  @@ImageLoaded  . . . . . . . .	L Near	 00001BE3 _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 00001BFE _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 00001C2B _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00001C6E _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 00001CBA _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 00001CC0 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00001CEC _TEXT	
  @@RelInv . . . . . . . . . . .	L Near	 00001D48 _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00001D51 _TEXT	
  @@Offset32 . . . . . . . . . .	L Near	 00001D60 _TEXT	
  @@Seg16  . . . . . . . . . . .	L Near	 00001D7C _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00001DA8 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00001DCD _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00001DD6 _TEXT	
OpenFile . . . . . . . . . . . .	P Near	 0000301B _TEXT	Length= 00000033 Public
  @@0  . . . . . . . . . . . . .	L Near	 0000302F _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 0000303C _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00003042 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00003043 _TEXT	
PostMortem . . . . . . . . . . .	P Near	 00000587 _TEXT	Length= 00000001 Public
ProcessFile  . . . . . . . . . .	P Near	 00001E05 _TEXT	Length= 00000780 Public
  medexe8  . . . . . . . . . . .	L Near	 00001F31 _TEXT	
  @@NoBind . . . . . . . . . . .	L Near	 0000204C _TEXT	
  medexe9  . . . . . . . . . . .	L Near	 000020F9 _TEXT	
  @@NormStack  . . . . . . . . .	L Near	 0000215F _TEXT	
  @@GotStackNear . . . . . . . .	L Near	 00002169 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 0000218D _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 000021A6 _TEXT	
  @@NormStack2 . . . . . . . . .	L Near	 000021D0 _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 000021E6 _TEXT	
  @@6_0  . . . . . . . . . . . .	L Near	 000021F6 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 00002215 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 0000221B _TEXT	
  @@10 . . . . . . . . . . . . .	L Near	 00002221 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 000022A7 _TEXT	
  @@NoRelocMem . . . . . . . . .	L Near	 000022BE _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 0000236B _TEXT	
  @@NoRoundUp  . . . . . . . . .	L Near	 00002388 _TEXT	
  @@Small  . . . . . . . . . . .	L Near	 00002390 _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00002400 _TEXT	
  @@30 . . . . . . . . . . . . .	L Near	 0000241B _TEXT	
  @@NotFlat  . . . . . . . . . .	L Near	 0000242B _TEXT	
  @@31 . . . . . . . . . . . . .	L Near	 0000244A _TEXT	
  @@NoReloc  . . . . . . . . . .	L Near	 00002454 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00002557 _TEXT	
ReadBufferByte . . . . . . . . .	P Near	 000031E1 _TEXT	Length= 0000005F Public
  @@0  . . . . . . . . . . . . .	L Near	 0000321C _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 0000323E _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 0000323F _TEXT	
ReadCommand  . . . . . . . . . .	P Near	 00002ED3 _TEXT	Length= 00000148 Public
  @@0  . . . . . . . . . . . . .	L Near	 00002F00 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00002F10 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00002F1F _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00002F40 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00002F54 _TEXT	
  @@Option . . . . . . . . . . .	L Near	 00002F89 _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 00002F8C _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 00002F99 _TEXT	
  @@12 . . . . . . . . . . . . .	L Near	 00002FA8 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 00002FB9 _TEXT	
  @@900  . . . . . . . . . . . .	L Near	 00002FD3 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00002FD4 _TEXT	
  @@10 . . . . . . . . . . . . .	L Near	 00002FE9 _TEXT	
  @@11 . . . . . . . . . . . . .	L Near	 00002FFB _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 0000300A _TEXT	
ReadConfig . . . . . . . . . . .	P Near	 00002B64 _TEXT	Length= 000001AC Public
  @@NoOveride  . . . . . . . . .	L Near	 00002B81 _TEXT	
  @@NotCurrent . . . . . . . . .	L Near	 00002B95 _TEXT	
  @@c1 . . . . . . . . . . . . .	L Near	 00002BAC _TEXT	
  @@c2 . . . . . . . . . . . . .	L Near	 00002BC1 _TEXT	
  @@c3 . . . . . . . . . . . . .	L Near	 00002BCA _TEXT	
  @@c99  . . . . . . . . . . . .	L Near	 00002BD6 _TEXT	
  @@c4 . . . . . . . . . . . . .	L Near	 00002BE2 _TEXT	
  @@ConfigOK . . . . . . . . . .	L Near	 00002BF9 _TEXT	
  @@Read . . . . . . . . . . . .	L Near	 00002BFF _TEXT	
  @@Scan . . . . . . . . . . . .	L Near	 00002C3C _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 00002C52 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00002C6C _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00002C76 _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 00002C9D _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00002CA2 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00002CA6 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 00002CBC _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00002CD3 _TEXT	
  @@10 . . . . . . . . . . . . .	L Near	 00002CDD _TEXT	
  @@90 . . . . . . . . . . . . .	L Near	 00002CEA _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00002D08 _TEXT	
ReadFile . . . . . . . . . . . .	P Near	 00003091 _TEXT	Length= 0000003A Public
  @@0  . . . . . . . . . . . . .	L Near	 00003093 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 000030A5 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 000030C5 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 000030C9 _TEXT	
ReadLine . . . . . . . . . . . .	P Near	 00003166 _TEXT	Length= 00000070 Public
  @@0  . . . . . . . . . . . . .	L Near	 00003169 _TEXT	
  @@CheckLF  . . . . . . . . . .	L Near	 0000318B _TEXT	
  @@EOL  . . . . . . . . . . . .	L Near	 0000319E _TEXT	
  @@SoftEOF  . . . . . . . . . .	L Near	 000031A6 _TEXT	
  @@CheckEOF . . . . . . . . . .	L Near	 000031C6 _TEXT	
  @@EOF  . . . . . . . . . . . .	L Near	 000031CB _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 000031D4 _TEXT	
ReadMapFile  . . . . . . . . . .	P Near	 00002585 _TEXT	Length= 000005BC Public
  @@LookID . . . . . . . . . . .	L Near	 000025EA _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 0000263A _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00002644 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00002647 _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00002651 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00002654 _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 0000267A _TEXT	
  @@LookSeg  . . . . . . . . . .	L Near	 000026C6 _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 000026E9 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 000026F3 _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 000026F6 _TEXT	
  @@Ignore . . . . . . . . . . .	L Near	 00002714 _TEXT	
  @@Start  . . . . . . . . . . .	L Near	 00002721 _TEXT	
  @@11 . . . . . . . . . . . . .	L Near	 00002723 _TEXT	
  @@30 . . . . . . . . . . . . .	L Near	 0000274E _TEXT	
  @@10 . . . . . . . . . . . . .	L Near	 0000274F _TEXT	
  @@Length . . . . . . . . . . .	L Near	 00002764 _TEXT	
  @@12 . . . . . . . . . . . . .	L Near	 00002766 _TEXT	
  @@31 . . . . . . . . . . . . .	L Near	 00002791 _TEXT	
  @@13 . . . . . . . . . . . . .	L Near	 00002792 _TEXT	
  @@Class  . . . . . . . . . . .	L Near	 000027A0 _TEXT	
  @@14 . . . . . . . . . . . . .	L Near	 000027B0 _TEXT	
  @@15 . . . . . . . . . . . . .	L Near	 000027CB _TEXT	
  @@25 . . . . . . . . . . . . .	L Near	 000027F1 _TEXT	
  @@26 . . . . . . . . . . . . .	L Near	 000027FB _TEXT	
  @@27 . . . . . . . . . . . . .	L Near	 00002805 _TEXT	
  @@19 . . . . . . . . . . . . .	L Near	 00002814 _TEXT	
  @@20 . . . . . . . . . . . . .	L Near	 00002825 _TEXT	
  @@17 . . . . . . . . . . . . .	L Near	 00002859 _TEXT	
  @@22 . . . . . . . . . . . . .	L Near	 00002866 _TEXT	
  @@16 . . . . . . . . . . . . .	L Near	 00002878 _TEXT	
  @@18 . . . . . . . . . . . . .	L Near	 0000287F _TEXT	
  @@21 . . . . . . . . . . . . .	L Near	 00002887 _TEXT	
  @@NextSeg  . . . . . . . . . .	L Near	 000028CE _TEXT	
  @@NoRound  . . . . . . . . . .	L Near	 000028E3 _TEXT	
  @@DoSegs . . . . . . . . . . .	L Near	 0000294E _TEXT	
  @@GotESPSize . . . . . . . . .	L Near	 000029BD _TEXT	
  @@NoFlat . . . . . . . . . . .	L Near	 000029D2 _TEXT	
  @@23 . . . . . . . . . . . . .	L Near	 00002A19 _TEXT	
  @@24 . . . . . . . . . . . . .	L Near	 00002A2A _TEXT	
  @@G0 . . . . . . . . . . . . .	L Near	 00002A54 _TEXT	
  @@G1 . . . . . . . . . . . . .	L Near	 00002A62 _TEXT	
  @@NoGroup  . . . . . . . . . .	L Near	 00002A67 _TEXT	
  @@SameBase0  . . . . . . . . .	L Near	 00002A7C _TEXT	
  @@SameBase1  . . . . . . . . .	L Near	 00002A86 _TEXT	
  @@SameBase4  . . . . . . . . .	L Near	 00002A90 _TEXT	
  @@SameBase2  . . . . . . . . .	L Near	 00002A96 _TEXT	
  @@SameBase3  . . . . . . . . .	L Near	 00002AA4 _TEXT	
  @@SameBase5  . . . . . . . . .	L Near	 00002ACB _TEXT	
  @@NoBaseChk  . . . . . . . . .	L Near	 00002AD5 _TEXT	
  @@90 . . . . . . . . . . . . .	L Near	 00002AFD _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00002B1B _TEXT	
RelMemLinear32 . . . . . . . . .	P Near	 00002EA9 _TEXT	Length= 0000000E Public
ResMemLinear32 . . . . . . . . .	P Near	 00002EB7 _TEXT	Length= 0000001C Public
SegFormatCode  . . . . . . . . .	P Near	 00002DB8 _TEXT	Length= 000000AE Public
  @@5  . . . . . . . . . . . . .	L Near	 00002DBE _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 00002DCA _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00002DE4 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 00002DEE _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00002DF3 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00002E15 _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00002E1A _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 00002E3D _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 00002E53 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00002E5E _TEXT	
SetFilePointer . . . . . . . . .	P Near	 00003082 _TEXT	Length= 0000000F Public
SetSystemConfig  . . . . . . . .	P Near	 0000167E _TEXT	Length= 0000008F Public
  @@2  . . . . . . . . . . . . .	L Near	 00001695 _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 000016A3 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 000016B1 _TEXT	
  @@ss0  . . . . . . . . . . . .	L Near	 000016DB _TEXT	
  @@ss1  . . . . . . . . . . . .	L Near	 00001704 _TEXT	
  @@NoAutoESP  . . . . . . . . .	L Near	 0000170C _TEXT	
StringPrint  . . . . . . . . . .	P Near	 00003240 _TEXT	Length= 00000022 Public
  @@0  . . . . . . . . . . . . .	L Near	 00003249 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 0000325A _TEXT	
System . . . . . . . . . . . . .	P Near	 00000524 _TEXT	Length= 00000063 Public
  @@NoError  . . . . . . . . . .	L Near	 0000054D _TEXT	
  @@DoneError  . . . . . . . . .	L Near	 00000557 _TEXT	
  @@NoName . . . . . . . . . . .	L Near	 0000056B _TEXT	
UpperChar  . . . . . . . . . . .	P Near	 00002E81 _TEXT	Length= 0000000B Public
  @@0  . . . . . . . . . . . . .	L Near	 00002E8B _TEXT	
WhiteSpaceString . . . . . . . .	P Near	 00002D10 _TEXT	Length= 000000A8 Public
  @@30 . . . . . . . . . . . . .	L Near	 00002D26 _TEXT	
  @@AtStart  . . . . . . . . . .	L Near	 00002D2F _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 00002D35 _TEXT	
  @@6  . . . . . . . . . . . . .	L Near	 00002D64 _TEXT	
  @@5  . . . . . . . . . . . . .	L Near	 00002D75 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00002D8C _TEXT	
  @@3  . . . . . . . . . . . . .	L Near	 00002D98 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00002D9B _TEXT	
  @@4  . . . . . . . . . . . . .	L Near	 00002DA9 _TEXT	
  @@7  . . . . . . . . . . . . .	L Near	 00002DA9 _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00002DB0 _TEXT	
Write3PFile  . . . . . . . . . .	P Near	 000008C5 _TEXT	Length= 00000246 Public
  medexe4  . . . . . . . . . . .	L Near	 00000957 _TEXT	
  @@0  . . . . . . . . . . . . .	L Near	 00000A62 _TEXT	
  @@1  . . . . . . . . . . . . .	L Near	 00000AB3 _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 00000ABE _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00000B09 _TEXT	
WriteFile  . . . . . . . . . . .	P Near	 000030CB _TEXT	Length= 0000003A Public
  @@0  . . . . . . . . . . . . .	L Near	 000030CD _TEXT	
  @@2  . . . . . . . . . . . . .	L Near	 000030DF _TEXT	
  @@8  . . . . . . . . . . . . .	L Near	 000030FF _TEXT	
  @@9  . . . . . . . . . . . . .	L Near	 00003103 _TEXT	
dprintf  . . . . . . . . . . . .	P Near	 00000062 _TEXT	Length= 00000167 Public
  size_  . . . . . . . . . . . .	DWord	 bp - 00000004
  flag . . . . . . . . . . . . .	Byte	 bp - 00000005
  longarg  . . . . . . . . . . .	Byte	 bp - 00000006
  fill . . . . . . . . . . . . .	Byte	 bp - 00000007
  szTmp  . . . . . . . . . . . .	Byte	 bp - 00000013
  @@L335 . . . . . . . . . . . .	L Near	 0000006D _TEXT	
  nextchar . . . . . . . . . . .	L Near	 00000070 _TEXT	
  done . . . . . . . . . . . . .	L Near	 00000081 _TEXT	
  formatitem . . . . . . . . . .	L Near	 00000096 _TEXT	
  handle_c . . . . . . . . . . .	L Near	 00000113 _TEXT	
  @@L359 . . . . . . . . . . . .	L Near	 00000119 _TEXT	
  handle_x . . . . . . . . . . .	L Near	 0000011F _TEXT	
  handle_d . . . . . . . . . . .	L Near	 00000125 _TEXT	
  handle_i . . . . . . . . . . .	L Near	 00000125 _TEXT	
  handle_u . . . . . . . . . . .	L Near	 0000012B _TEXT	
  @@lprt262  . . . . . . . . . .	L Near	 0000012F _TEXT	
  handle_s . . . . . . . . . . .	L Near	 00000152 _TEXT	
  print_string . . . . . . . . .	L Near	 0000016D _TEXT	
  print_char . . . . . . . . . .	L Near	 000001B3 _TEXT	
ltob . . . . . . . . . . . . . .	P Near	 0000001C _TEXT	Length= 00000046 Public
  @@nextdigit  . . . . . . . . .	L Near	 0000003C _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@@Source . . . . . . . . . . . .	DWord	 00000588 _BSS	
@@WildStart1 . . . . . . . . . .	DWord	 00000580 _BSS	
@@WildStart2 . . . . . . . . . .	DWord	 00000584 _BSS	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
Bit16Text  . . . . . . . . . . .	Byte	 00003660 _DATA	
Bit32Text  . . . . . . . . . . .	Byte	 00003676 _DATA	
BitDualText  . . . . . . . . . .	Byte	 0000368C _DATA	
BuildHeaderText  . . . . . . . .	Byte	 000038CD _DATA	
BuildImageText . . . . . . . . .	Byte	 0000388E _DATA	
BuildRelocsText  . . . . . . . .	Byte	 000038B0 _DATA	
CWAPP  . . . . . . . . . . . . .	Text   	 
CWStubName . . . . . . . . . . .	Byte	 00000AED _DATA	
CarriageReturn2  . . . . . . . .	Byte	 00000AE1 _DATA	
CarriageReturn . . . . . . . . .	Byte	 00000ADE _DATA	
ClassText  . . . . . . . . . . .	Byte	 00000D17 _DATA	
CodeClassVAR . . . . . . . . . .	Byte	 00000C1E _DATA	
ConfigHandle . . . . . . . . . .	Word	 00000AF8 _DATA	
ConfigName . . . . . . . . . . .	Byte	 00000AE4 _DATA	
ConfigPath . . . . . . . . . . .	Byte	 00000000 _BSS	
ConstClassVAR  . . . . . . . . .	Byte	 00000C3D _DATA	
DBGOPT . . . . . . . . . . . . .	Number	 -00000001h   
DataClassVAR . . . . . . . . . .	Byte	 00000C28 _DATA	
Desc286Call  . . . . . . . . . .	Number	 00000004h   
Desc286Int . . . . . . . . . . .	Number	 00000006h   
Desc286Trap  . . . . . . . . . .	Number	 00000007h   
Desc286TssB  . . . . . . . . . .	Number	 00000003h   
Desc286Tss . . . . . . . . . . .	Number	 00000001h   
Desc32Bit  . . . . . . . . . . .	Number	 00000040h   
Desc386Call  . . . . . . . . . .	Number	 0000000Ch   
Desc386Int . . . . . . . . . . .	Number	 0000000Eh   
Desc386Trap  . . . . . . . . . .	Number	 0000000Fh   
Desc386TssB  . . . . . . . . . .	Number	 0000000Bh   
Desc386Tss . . . . . . . . . . .	Number	 00000009h   
DescAvailable  . . . . . . . . .	Number	 00000010h   
DescECCode . . . . . . . . . . .	Number	 0000000Ch   
DescECode  . . . . . . . . . . .	Number	 00000008h   
DescERCCode  . . . . . . . . . .	Number	 0000000Eh   
DescERCode . . . . . . . . . . .	Number	 0000000Ah   
DescLDT  . . . . . . . . . . . .	Number	 00000002h   
DescMemory . . . . . . . . . . .	Number	 00000010h   
DescPL0  . . . . . . . . . . . .	Number	 00000000h   
DescPL1  . . . . . . . . . . . .	Number	 00000020h   
DescPL2  . . . . . . . . . . . .	Number	 00000040h   
DescPL3  . . . . . . . . . . . .	Number	 00000060h   
DescPresent  . . . . . . . . . .	Number	 00000080h   
DescRDataDown  . . . . . . . . .	Number	 00000004h   
DescRData  . . . . . . . . . . .	Number	 00000000h   
DescRWDataDown . . . . . . . . .	Number	 00000006h   
DescRWData . . . . . . . . . . .	Number	 00000002h   
DescTssGate  . . . . . . . . . .	Number	 00000005h   
ERR_ALREADY3P  . . . . . . . . .	Number	 0000001Ah   
ERR_HDRFMT . . . . . . . . . . .	Number	 00000007h   
ERR_IO . . . . . . . . . . . . .	Number	 00000008h   
ERR_NOFILES  . . . . . . . . . .	Number	 00000005h   
ERR_OPENFIL  . . . . . . . . . .	Number	 00000006h   
EXEFileName  . . . . . . . . . .	Byte	 00000100 _BSS	
EXEHandle  . . . . . . . . . . .	Word	 00000B00 _DATA	
EXEextension . . . . . . . . . .	Byte	 00000AFC _DATA	
ErrorM10 . . . . . . . . . . . .	Byte	 000005AB _DATA	
ErrorM11 . . . . . . . . . . . .	Byte	 000005C7 _DATA	
ErrorM12 . . . . . . . . . . . .	Byte	 000005F1 _DATA	
ErrorM13 . . . . . . . . . . . .	Byte	 0000060B _DATA	
ErrorM14 . . . . . . . . . . . .	Byte	 0000062B _DATA	
ErrorM15 . . . . . . . . . . . .	Byte	 00000655 _DATA	
ErrorM16 . . . . . . . . . . . .	Byte	 00000684 _DATA	
ErrorM17 . . . . . . . . . . . .	Byte	 000006AA _DATA	
ErrorM18 . . . . . . . . . . . .	Byte	 000006CA _DATA	
ErrorM19 . . . . . . . . . . . .	Byte	 000006EA _DATA	
ErrorM20 . . . . . . . . . . . .	Byte	 0000070A _DATA	
ErrorM21 . . . . . . . . . . . .	Byte	 00000732 _DATA	
ErrorM22 . . . . . . . . . . . .	Byte	 00000746 _DATA	
ErrorM23 . . . . . . . . . . . .	Byte	 00000776 _DATA	
ErrorM24 . . . . . . . . . . . .	Byte	 00000792 _DATA	
ErrorM25 . . . . . . . . . . . .	Byte	 000007C4 _DATA	
ErrorM26 . . . . . . . . . . . .	Byte	 000007F8 _DATA	
ErrorM27 . . . . . . . . . . . .	Byte	 0000081A _DATA	
ErrorM32 . . . . . . . . . . . .	Byte	 00000836 _DATA	
ErrorM33 . . . . . . . . . . . .	Byte	 0000085A _DATA	
ErrorM34 . . . . . . . . . . . .	Byte	 00000875 _DATA	
ErrorM35 . . . . . . . . . . . .	Byte	 0000089A _DATA	
ErrorM36 . . . . . . . . . . . .	Byte	 000008B3 _DATA	
ErrorM37 . . . . . . . . . . . .	Byte	 000008DA _DATA	
ErrorM38 . . . . . . . . . . . .	Byte	 000008FA _DATA	
ErrorM39 . . . . . . . . . . . .	Byte	 00000926 _DATA	
ErrorM40 . . . . . . . . . . . .	Byte	 0000094E _DATA	
ErrorM41 . . . . . . . . . . . .	Byte	 00000970 _DATA	
ErrorM42 . . . . . . . . . . . .	Byte	 000009A9 _DATA	
ErrorM43 . . . . . . . . . . . .	Byte	 000009CF _DATA	
ErrorMessages  . . . . . . . . .	DWord	 00000006 _DATA	
ErrorNumber  . . . . . . . . . .	Word	 00000004 _DATA	
ErrorText  . . . . . . . . . . .	Byte	 000009EE _DATA	
Errorm0  . . . . . . . . . . . .	Byte	 000000B6 _DATA	
Errorm1  . . . . . . . . . . . .	Byte	 000000DE _DATA	
Errorm2  . . . . . . . . . . . .	Byte	 0000011B _DATA	
Errorm3  . . . . . . . . . . . .	Byte	 0000013E _DATA	
Errorm4  . . . . . . . . . . . .	Byte	 000004E1 _DATA	
Errorm5  . . . . . . . . . . . .	Byte	 00000502 _DATA	
Errorm6  . . . . . . . . . . . .	Byte	 0000051F _DATA	
Errorm7  . . . . . . . . . . . .	Byte	 0000053C _DATA	
Errorm8  . . . . . . . . . . . .	Byte	 00000557 _DATA	
Errorm9  . . . . . . . . . . . .	Byte	 0000057B _DATA	
ExeSegment . . . . . . . . . . .	DWord	 00000B23 _DATA	
ExeSize1 . . . . . . . . . . . .	Word	 00000B46 _DATA	
ExeSize2 . . . . . . . . . . . .	Word	 00000B4A _DATA	
FileBufferCount  . . . . . . . .	DWord	 00003D00 _DATA	
FileBufferPosition . . . . . . .	DWord	 00003D04 _DATA	
FileBuffer . . . . . . . . . . .	Byte	 0000058C _BSS	
GenerateExeText  . . . . . . . .	Byte	 00000ABC _DATA	
HexTable . . . . . . . . . . . .	Byte	 00001DF5 _TEXT	
HiThere  . . . . . . . . . . . .	Byte	 00000000 _TEXT	
InternalConfig . . . . . . . . .	Byte	 00000A32 _DATA	
InvalidText  . . . . . . . . . .	Byte	 00003865 _DATA	
KernalA000 . . . . . . . . . . .	Number	 0000A003h   
KernalB000 . . . . . . . . . . .	Number	 0000B003h   
KernalB800 . . . . . . . . . . .	Number	 0000B803h   
LEAddress  . . . . . . . . . . .	DWord	 000038FE _DATA	
LELength . . . . . . . . . . . .	DWord	 00003902 _DATA	
LEOffset . . . . . . . . . . . .	DWord	 00003906 _DATA	
LE_CPU_286 . . . . . . . . . . .	Number	 00000001h   
LE_CPU_386 . . . . . . . . . . .	Number	 00000002h   
LE_CPU_486 . . . . . . . . . . .	Number	 00000003h   
LE_CPU_586 . . . . . . . . . . .	Number	 00000004h   
LE_CPU_N11 . . . . . . . . . . .	Number	 00000021h   
LE_CPU_R2000 . . . . . . . . . .	Number	 00000040h   
LE_CPU_R4000 . . . . . . . . . .	Number	 00000042h   
LE_CPU_R6000 . . . . . . . . . .	Number	 00000041h   
LE_CPU_i860  . . . . . . . . . .	Number	 00000020h   
LE_OBJ_Flags_16Alias . . . . . .	Number	 00001000h   
LE_OBJ_Flags_Big . . . . . . . .	Number	 00002000h   
LE_OBJ_Flags_Conform . . . . . .	Number	 00004000h   
LE_OBJ_Flags_Discard . . . . . .	Number	 00000010h   
LE_OBJ_Flags_Exec  . . . . . . .	Number	 00000004h   
LE_OBJ_Flags_FillMsk . . . . . .	Number	 00000300h   
LE_OBJ_Flags_IOPriv  . . . . . .	Number	 00008000h   
LE_OBJ_Flags_Invalid . . . . . .	Number	 00000080h   
LE_OBJ_Flags_LongLoc . . . . . .	Number	 00000400h   
LE_OBJ_Flags_Normal  . . . . . .	Number	 00000000h   
LE_OBJ_Flags_PreLoad . . . . . .	Number	 00000040h   
LE_OBJ_Flags_Read  . . . . . . .	Number	 00000001h   
LE_OBJ_Flags_Res1  . . . . . . .	Number	 00000200h   
LE_OBJ_Flags_Res2  . . . . . . .	Number	 00000300h   
LE_OBJ_Flags_Res . . . . . . . .	Number	 00000008h   
LE_OBJ_Flags_Shared  . . . . . .	Number	 00000020h   
LE_OBJ_Flags_Write . . . . . . .	Number	 00000002h   
LE_OBJ_Flags_Zero  . . . . . . .	Number	 00000100h   
LE_OS_DOS4 . . . . . . . . . . .	Number	 00000003h   
LE_OS_OS2  . . . . . . . . . . .	Number	 00000001h   
LE_OS_Win386 . . . . . . . . . .	Number	 00000004h   
LE_OS_Windows  . . . . . . . . .	Number	 00000002h   
LE_Type_DLL  . . . . . . . . . .	Number	 00008000h   
LE_Type_ExtFixup . . . . . . . .	Number	 00000020h   
LE_Type_InitPer  . . . . . . . .	Number	 00000004h   
LE_Type_IntFixup . . . . . . . .	Number	 00000010h   
LE_Type_NoLoad . . . . . . . . .	Number	 00002000h   
LengthText . . . . . . . . . . .	Byte	 00000D10 _DATA	
LineBuffer . . . . . . . . . . .	Byte	 00000180 _BSS	
MAPFileName  . . . . . . . . . .	Byte	 00000140 _BSS	
MAPHandle  . . . . . . . . . . .	Word	 00000B06 _DATA	
MAPextension . . . . . . . . . .	Byte	 00000B02 _DATA	
MEM_END  . . . . . . . . . . . .	Number	 00000002h   
MEM_FILL . . . . . . . . . . . .	Number	 0000003Dh   
MEM_FREE . . . . . . . . . . . .	Number	 00000000h   
MEM_LOCK_MASK  . . . . . . . . .	Number	 0000000Fh   
MEM_LOCK_SHIFT . . . . . . . . .	Number	 00000002h   
MEM_LOCK . . . . . . . . . . . .	Number	 00000004h   
MEM_MASK . . . . . . . . . . . .	Number	 00000003h   
MEM_PHYS . . . . . . . . . . . .	Number	 00000020h   
MEM_START  . . . . . . . . . . .	Number	 00000001h   
NearClassVAR . . . . . . . . . .	Byte	 00000C48 _DATA	
NewAllocT  . . . . . . . . . . .	Byte	 000036D9 _DATA	
NewEntryAutoSS . . . . . . . . .	Byte	 0000373B _DATA	
NewEntryCSt  . . . . . . . . . .	Byte	 00003711 _DATA	
NewEntryEIPt . . . . . . . . . .	Byte	 00003703 _DATA	
NewEntryESPt . . . . . . . . . .	Byte	 0000371F _DATA	
NewEntrySSt  . . . . . . . . . .	Byte	 0000372D _DATA	
NewHeader  . . . . . . . . . . .	NewHeaderStruc  00000B4E _DATA	
NewLengthT . . . . . . . . . . .	Byte	 000036CB _DATA	
NewRelocsT . . . . . . . . . . .	Byte	 000036F5 _DATA	
NewSegmentsT . . . . . . . . . .	Byte	 000036E7 _DATA	
NewSizeT . . . . . . . . . . . .	Byte	 000036BD _DATA	
NullText . . . . . . . . . . . .	Byte	 00000D05 _DATA	
ObjectBase . . . . . . . . . . .	DWord	 0000390E _DATA	
ObjectCount  . . . . . . . . . .	DWord	 0000390A _DATA	
ObjectList . . . . . . . . . . .	DWord	 00003912 _DATA	
OpenFilesList  . . . . . . . . .	Word	 00003D08 _DATA	
OptionCounter  . . . . . . . . .	Byte	 0000397B _DATA	
OptionPointer  . . . . . . . . .	DWord	 00003BFC _DATA	
OptionTable  . . . . . . . . . .	Byte	 0000397C _DATA	
OptionText . . . . . . . . . . .	Byte	 00003C00 _DATA	
P3Offset . . . . . . . . . . . .	DWord	 00003976 _DATA	
PageCount  . . . . . . . . . . .	DWord	 0000391E _DATA	
ProcessExeText . . . . . . . . .	Byte	 00000A99 _DATA	
ProcessMapText . . . . . . . . .	Byte	 00000A82 _DATA	
ProcessStubText  . . . . . . . .	Byte	 00000A62 _DATA	
ReadingLEText  . . . . . . . . .	Byte	 00003871 _DATA	
ReadingMainText  . . . . . . . .	Byte	 00003749 _DATA	
Real3POffset . . . . . . . . . .	DWord	 0000386D _DATA	
RealHeader . . . . . . . . . . .	NewHeaderStruc  00003926 _DATA	
RelocMem . . . . . . . . . . . .	DWord	 0000396E _DATA	
RelocSegment . . . . . . . . . .	DWord	 00000B27 _DATA	
RelocStuff . . . . . . . . . . .	Byte	 000037F8 _DATA	
RelocationCount  . . . . . . . .	DWord	 0000396A _DATA	
RelocationList . . . . . . . . .	DWord	 00003916 _DATA	
ResCount . . . . . . . . . . . .	Number	 0000032Ch   
ResHeadSize  . . . . . . . . . .	Number	 00000010h   
ResNum . . . . . . . . . . . . .	Number	 00000330h   
ResSize  . . . . . . . . . . . .	Number	 00001000h   
Res_CALLBACK . . . . . . . . . .	Number	 00000006h   
Res_CHAIN  . . . . . . . . . . .	Number	 000000FFh   
Res_DOSMEM . . . . . . . . . . .	Number	 00000005h   
Res_LOCK . . . . . . . . . . . .	Number	 00000004h   
Res_MEM  . . . . . . . . . . . .	Number	 00000003h   
Res_NOTHING  . . . . . . . . . .	Number	 000000FEh   
Res_NULL . . . . . . . . . . . .	Number	 00000000h   
Res_PSP  . . . . . . . . . . . .	Number	 00000001h   
Res_SEL  . . . . . . . . . . . .	Number	 00000002h   
SHELLFileName  . . . . . . . . .	Byte	 00000080 _BSS	
SHELLHandle  . . . . . . . . . .	Word	 00000AFA _DATA	
SegClassCODE . . . . . . . . . .	Byte	 00000E41 _DATA	
SegClassCONST  . . . . . . . . .	Byte	 00002654 _DATA	
SegClassDATA . . . . . . . . . .	Byte	 00001647 _DATA	
SegClassList . . . . . . . . . .	DWord	 00000E28 _DATA	
SegClassNEAR . . . . . . . . . .	Byte	 00002E5B _DATA	
SegClassSTACK  . . . . . . . . .	Byte	 00001E4D _DATA	
SegCurrent . . . . . . . . . . .	DWord	 00000B1B _DATA	
SegFormatSlots . . . . . . . . .	Byte	 00000D1D _DATA	
SegFormatTexts . . . . . . . . .	DWord	 00000CF1 _DATA	
SegFormatVAR . . . . . . . . . .	Byte	 00000C10 _DATA	
SegHeaderText  . . . . . . . . .	Byte	 00000C53 _DATA	
SegHeaderVAR . . . . . . . . . .	Byte	 00000C02 _DATA	
SegLayout  . . . . . . . . . . .	Byte	 00000D22 _DATA	
SegSamet . . . . . . . . . . . .	Byte	 000009F6 _DATA	
SegmentBase  . . . . . . . . . .	DWord	 0000391A _DATA	
SegmentList  . . . . . . . . . .	DWord	 00000B17 _DATA	
SegmentStuff . . . . . . . . . .	Byte	 0000377B _DATA	
SegmentTotal . . . . . . . . . .	DWord	 00000B1F _DATA	
SpeedLoadText  . . . . . . . . .	Byte	 000036A5 _DATA	
StackClassVAR  . . . . . . . . .	Byte	 00000C32 _DATA	
StartText  . . . . . . . . . . .	Byte	 00000D0A _DATA	
StubMem  . . . . . . . . . . . .	DWord	 00003966 _DATA	
TempFileName . . . . . . . . . .	Byte	 00000B08 _DATA	
TempHandle . . . . . . . . . . .	Word	 00000B15 _DATA	
VariableList . . . . . . . . . .	DWord	 00000B8E _DATA	
Write3PText  . . . . . . . . . .	Byte	 000038EA _DATA	
_DEBUG . . . . . . . . . . . . .	Text   	 
b  . . . . . . . . . . . . . . .	Text   	 byte ptr
d  . . . . . . . . . . . . . . .	Text   	 dword ptr
exehdr . . . . . . . . . . . . .	MZHdr	 00000B2B _DATA	
fmt  . . . . . . . . . . . . . .	Text   	 
psp  . . . . . . . . . . . . . .	DWord	 00000000 _DATA	
start  . . . . . . . . . . . . .	L Near	 000001CC _TEXT	
w  . . . . . . . . . . . . . . .	Text   	 word ptr

	   0 Warnings
	   0 Errors
