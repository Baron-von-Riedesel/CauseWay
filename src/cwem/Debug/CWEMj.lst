JWasm v2.19, Feb  6 2025
cwem.asm

                                ;--- CW converts LE to P3
                                ;--- if image is P3 already, it displays current format with /i
                                ;--- or sets various parameters for CW dos extender.

                                ;--- this version has been adjusted and needs to find cwstub.exe!

                                	.386
                                	.model flat
                                	.dosseg		;WL32 needs .dosseg to ensure that stack is last
                                	.stack 4096

                                	include general.inc
                              C 
 = byte ptr                   C b	equ	byte ptr
 = word ptr                   C w	equ	word ptr
 = dword ptr                  C d	equ	dword ptr
                              C ;f	equ	fword ptr
                              C 
                              C Pushm	MACRO	R1,R2,R3,R4,R5,R6,R7,R8,R9,R10
 >                            C 	IRP	X,<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10>
 >                            C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                            C 	PUSH	X			;SAVE THE REGISTER
 >                            C 	ENDIF				;END IFNB
 >                            C 	ENDM				;END IRP
 >                            C ENDM
                              C 
                              C Popm	macro	R1,R2,R3,R4,R5,R6,R7,R8,R9,R10
 >                            C 	IRP	X,<R10,R9,R8,R7,R6,R5,R4,R3,R2,R1> ;REPEAT FOR EACH PARM
 >                            C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                            C 	POP	X				;POP THE REGISTER
 >                            C 	ENDIF					;END IFNB
 >                            C 	ENDM					;END IRP
 >                            C ENDM
                              C 
                                	include ..\strucs.inc
                              C ;------------------------------------------------------------------------------
                              C ;
                              C 
00000000                      C ResHead struc
00000000                      C ResHead_Prev    dd 0
00000004                      C ResHead_Next    dd 0
00000008                      C ResHead_Handle  dd 0
0000000C                      C ResHead ends
                              C 
 = 1000                       C ResSize     equ 4096    ;Size of resource block.
                              C ;ResHead    equ 16      ;Size of main header.
 = 10                         C ResHeadSize equ 16      ;Size of main header.
 = 330                        C ResNum      equ ((((4096-ResHeadSize)/5) shr 2) shl 2)  ;Number of entries.
 = 32C                        C ResCount    equ ResNum-4        ;count for free entry checking.
                              C 
                              C ;--- resource types
 = 0                          C Res_NULL        equ 0   ;MUST be zero.
 = 1                          C Res_PSP         equ 1   ;single entry.
 = 2                          C Res_SEL         equ 2   ;single entry.
 = 3                          C Res_MEM         equ 3   ;3 entries.
 = 4                          C Res_LOCK        equ 4   ;2 entries.
 = 5                          C Res_DOSMEM      equ 5   ;?
 = 6                          C Res_CALLBACK    equ 6   ;3 entries.
 = FE                         C Res_NOTHING     equ 254
 = FF                         C Res_CHAIN       equ 255 ;single entry.
                              C 
                              C ;--- fields for page details ( 4 MB region )
                              C ;--- an "allocated" memory region start with a MEM_START, the rest is MEM_END
 = 0                          C MEM_FREE    equ 0   ;Free page.
 = 1                          C MEM_START   equ 1   ;Used page, start of block.
 = 2                          C MEM_END     equ 2   ;Used page, end of block.
 = 3                          C MEM_MASK    equ 11b ;just bits 0 & 1
                              C ;
                              C ;--- bits 2-5 are lock count
 = 4                          C MEM_LOCK	equ	4	;Start of lock count.
 = F                          C MEM_LOCK_MASK	equ	15	;4 bit lock count.
 = 2                          C MEM_LOCK_SHIFT	equ	2
                              C ;
 = 20                         C MEM_PHYS	equ	32	;physical mapping - not used (and should be 64, since bit 5 is used by lock cnt)
                              C ;
 = 3D                         C MEM_FILL	equ	(MEM_LOCK_MASK shl MEM_LOCK_SHIFT)+MEM_START
                              C 
                              C ;
 = B003                       C KernalB000		equ	0b000h+3
 = B803                       C KernalB800		equ	0b800h+3
 = A003                       C KernalA000		equ	0a000h+3
                              C 
                              C ;
00000000                      C Desc		struc
00000000                      C Limit		dw 0		;+0 Offset of last byte.
00000002                      C Base_l		dw 0		;+2 Low 16 bits of 32-bit address.
00000004                      C Base_m		db 0		;+4 Bits 16-23 of base.
00000005                      C Access		db 0		;+5 Access priviledge level.
00000006                      C Gran		db 0		;+6 Granularity and limit.
00000007                      C Base_H		db 0		;+7 bits 24-31 of base.
00000008                      C Desc		ends
                              C 
 = 80                         C DescPresent		equ	1 shl 7	;Segment is present.
 = 40                         C Desc32Bit		equ	1 shl 6	;Segment is 32 bit (not 16!).
 = 10                         C DescAvailable	equ	1 shl 4	;Available for our use.
                              C ;
 = 0                          C DescPL0		equ	0 shl 5	;PL0
 = 20                         C DescPL1		equ	1 shl 5	;PL1
 = 40                         C DescPL2		equ	2 shl 5	;PL2
 = 60                         C DescPL3		equ	3 shl 5	;PL3
                              C ;
 = 10                         C DescMemory		equ	1 shl 4	;Segment is memory (not system gate etc.)
                              C ;
 = 0                          C DescRData		equ	0	;Read only data segment. (eg, ROM)
 = 2                          C DescRWData		equ	2	;Read/Write data.
 = 4                          C DescRDataDown	equ	4	;Read only expand down data segment.
 = 6                          C DescRWDataDown	equ	6	;Read/write expand down data segment.
 = 8                          C DescECode		equ	8	;Execute only code.
 = A                          C DescERCode		equ	10	;Execute/read code.
 = C                          C DescECCode		equ	12	;Execute only conforming code.
 = E                          C DescERCCode		equ	14	;Execute/read conforming code.
                              C ;
 = 1                          C Desc286Tss		equ	1	;Available 286 TSS.
 = 2                          C DescLDT		equ	2	;LDT.
 = 3                          C Desc286TssB		equ	3	;Busy 286 TSS.
 = 4                          C Desc286Call		equ	4	;286 call gate.
 = 5                          C DescTssGate		equ	5	;TSS gate.
 = 6                          C Desc286Int		equ	6	;286 interupt gate.
 = 7                          C Desc286Trap		equ	7	;286 trap gate.
 = 9                          C Desc386Tss		equ	9	;Available 386 TSS.
 = B                          C Desc386TssB		equ	11	;Busy 386 TSS.
 = C                          C Desc386Call		equ	12	;386 call gate.
 = E                          C Desc386Int		equ	14	;386 interupt gate.
 = F                          C Desc386Trap		equ	15	;386 trap gate.
                              C 
00000000                      C GATE struc
00000000                      C OfsLow	dw ?
00000002                      C sel		dw ?
00000004                      C attr	dw ?
00000006                      C OfsHigh	dw ?
00000008                      C GATE ends
                              C 
                              C ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
00000000                      C TSSFields	struc
                              C ;
                              C ;Task segment structure.
                              C ;
00000000                      C Back	dw ?,?  	;Back link to any previous TSS.
00000004                      C ESP0	dd ?		;SP for level 0 interupt.
00000008                      C SS0		dw ?,?
0000000C                      C ESP1	dd ?		;Level 1 interupt handlers stack.
00000010                      C SS1		dw ?,?
00000014                      C ESP2	dd ?		;Level 2 interupt handlers stack.
00000018                      C SS2		dw ?,?
0000001C                      C tCR3	dd ?		;CR3 value.
00000020                      C tEIP	dd ?		;Instruction pointer.
00000024                      C tEFlags	dd ?		;EFlags.
00000028                      C tEAX	dd ?		;AX for init.
0000002C                      C tECX	dd ?		;CX for init.
00000030                      C tEDX	dd ?		;DX for init.
00000034                      C tEBX	dd ?
00000038                      C tESP	dd ?
0000003C                      C tEBP	dd ?
00000040                      C tESI	dd ?
00000044                      C tEDI	dd ?
00000048                      C tES		dd ?
0000004C                      C tCS		dd ?
00000050                      C tSS		dd ?
00000054                      C tDS		dd ?
00000058                      C tFS		dd ?
0000005C                      C tGS		dd ?
00000060                      C tLDT	dw ?
00000062                      C 		dw ?		;reserved.
00000064                      C 		dw ?		;reserved.
00000066                      C IOMap	dw ?		;displacement to I/O map.
                              C ;
                              C ifdef tPL2StackSize
                              C endif
                              C ifdef tPL1StackSize
                              C endif
                              C ifdef tPL0StackSize
                              C endif
                              C ;tPL0Stack	dw ?
00000068                      C TSSFields	ends
                              C 
00000000                      C NewHeaderStruc	struc
00000000                      C NewID		db '3P'	;+0 identifier.
00000002                      C NewSize		dd ?		;+2 byte size of 3P section of file.
00000006                      C NewLength		dd ?		;+6  byte size of exe image data.
0000000A                      C NewAlloc		dd ?		;+10 byte size of program.
0000000E                      C NewSegments		dw ?		;+14 number of segment definitions.
00000010                      C NewRelocs		dd ?		;+16 number of relocation table entries.
00000014                      C NewEntryEIP		dd ?		;+20 entry offset.
00000018                      C NewEntryCS		dw ?		;+24 segment list entry number for entry CS.
0000001A                      C NewEntryESP		dd ?		;+26 ESP offset.
0000001E                      C NewEntrySS		dw ?		;+30 segment list entry number for SS.
00000020                      C NewFlags		dd ?		;+32 Control flags.
00000024                      C NewAutoStack		dd ?		;+36 Auto stack size.
00000028                      C NewAutoDS		dw ?		;+40 Auto DS segment number +1
0000002A                      C NewExports		dd ?		;+42 Length of EXPORT section.
0000002E                      C NewImports		dd ?		;+46 Length of IMPORT section.
00000032                      C NewImportModCnt	dd ?		;+50 Number of IMPORT modules.
                              C ;NewReserved		db 64-NewReserved dup (?)
00000036                      C NewReserved		db 64-$ dup (?)
00000040                      C NewHeaderStruc	ends
                              C ;
                              C ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                              C 
                              C ifndef CW3
 = 1                          C LE_OBJ_Flags_Read       equ 1   ;Readable.
 = 2                          C LE_OBJ_Flags_Write      equ 2   ;Writeable.
 = 4                          C LE_OBJ_Flags_Exec       equ 4   ;Executable.
 = 8                          C LE_OBJ_Flags_Res        equ 8   ;Resource.
 = 10                         C LE_OBJ_Flags_Discard    equ 16  ;Discardable.
 = 20                         C LE_OBJ_Flags_Shared     equ 32  ;Shared.
 = 40                         C LE_OBJ_Flags_PreLoad    equ 64  ;Preload.
 = 80                         C LE_OBJ_Flags_Invalid    equ 128 ;Invalid.
 = 300                        C LE_OBJ_Flags_FillMsk    equ 256+512     ;Mask for fill type bits.
 = 0                          C LE_OBJ_Flags_Normal     equ 0   ;Normal fill type.
 = 100                        C LE_OBJ_Flags_Zero       equ 256 ;Zero filled.
 = 200                        C LE_OBJ_Flags_Res1       equ 512 ;resident.
 = 300                        C LE_OBJ_Flags_Res2       equ 256+512     ;resident/contiguous.
 = 400                        C LE_OBJ_Flags_LongLoc    equ 1024        ;long lockable.
 = 1000                       C LE_OBJ_Flags_16Alias    equ 4096        ;16:16_ALIAS
 = 2000                       C LE_OBJ_Flags_Big        equ 8192        ;"BIG" (Huge: 32-bit)
 = 4000                       C LE_OBJ_Flags_Conform    equ 16384       ;Conforming.
 = 8000                       C LE_OBJ_Flags_IOPriv     equ 32768       ;"OBJECT_I/O_PRIVILEGE_LEVEL
                              C endif
                              C 
                              C ;
                              C ;LE header format.
                              C ;
00000000                      C LE_Header               struc
00000000                      C LE_ID           dw ?    ;"LE" text identifier.
00000002                      C LE_ByteOrder            db ?    ;byte order, 0=little-endian, none-zero=big.
00000003                      C LE_WordOrder            db ?    ;word order.
00000004                      C LE_Format               dd ?    ;format level.
                              C ;
00000008                      C LE_CPU          dw ?    ;CPU type.
 = 1                          C LE_CPU_286              equ 1
 = 2                          C LE_CPU_386              equ 2
 = 3                          C LE_CPU_486              equ 3
 = 4                          C LE_CPU_586              equ 4
 = 20                         C LE_CPU_i860             equ 20h
 = 21                         C LE_CPU_N11              equ 21h
 = 40                         C LE_CPU_R2000            equ 40h
 = 41                         C LE_CPU_R6000            equ 41h
 = 42                         C LE_CPU_R4000            equ 42h
                              C ;
0000000A                      C LE_OS           dw ?    ;Target operating system.
 = 1                          C LE_OS_OS2               equ 1
 = 2                          C LE_OS_Windows           equ 2
 = 3                          C LE_OS_DOS4              equ 3
 = 4                          C LE_OS_Win386            equ 4
                              C ;
0000000C                      C LE_Version              dd ?    ;Module version.
                              C ;
00000010                      C LE_Type         dd ?    ;Module type.
 = 4                          C LE_Type_InitPer equ 1 shl 2     ;initialise per process.
 = 10                         C LE_Type_IntFixup        equ 1 shl 4     ;no internal fixups.
 = 20                         C LE_Type_ExtFixup        equ 1 shl 5     ;no external fixups.
 = 2000                       C LE_Type_NoLoad          equ 1 shl 13    ;module not loadable.
 = 8000                       C LE_Type_DLL             equ 1 shl 15    ;DLL
                              C ;
00000014                      C LE_Pages                dd ?    ;number of memory pages.
00000018                      C LE_EntryCS              dd ?    ;Entry CS object.
0000001C                      C LE_EntryEIP             dd ?    ;Entry EIP.
00000020                      C LE_EntrySS              dd ?    ;Entry SS object.
00000024                      C LE_EntryESP             dd ?    ;Entry ESP.
00000028                      C LE_PageSize             dd ?    ;Page size.
0000002C                      C LE_LastBytes            dd ?    ;Bytes on last page.
00000030                      C LE_FixupSize            dd ?    ;fixup section size.
00000034                      C LE_FixupChk             dd ?    ;fixup section check sum.
00000038                      C LE_LoaderSize           dd ?    ;loader section size.
0000003C                      C LE_LoaderChk            dd ?    ;loader section check sum.
00000040                      C LE_ObjOffset            dd ?    ;offset of object table.
00000044                      C LE_ObjNum               dd ?    ;object table entries
00000048                      C LE_PageMap              dd ?    ;object page map table offset.
0000004C                      C LE_IterateMap           dd ?    ;object iterate data map offset.
00000050                      C LE_Resource             dd ?    ;resource table offset
00000054                      C LE_ResourceNum          dd ?    ;resource table entries.
00000058                      C LE_ResidentNames        dd ?    ;resident names table offset.
0000005C                      C LE_EntryTable           dd ?    ;entry table offset.
00000060                      C LE_Directives           dd ?    ;module directives table offset.
00000064                      C LE_DirectivesNum        dd ?    ;module directives entries.
00000068                      C LE_Fixups               dd ?    ;fixup page table offset.
0000006C                      C LE_FixupsRec            dd ?    ;fixup record table offset.
00000070                      C LE_ImportModNames       dd ?    ;imported module name table offset.
00000074                      C LE_ImportModNum dd ?    ;imported modules count.
00000078                      C LE_ImportNames          dd ?    ;imported procedures name table offset.
0000007C                      C LE_PageChk              dd ?    ;per-page checksum table offset.
00000080                      C LE_Data         dd ?    ;data pages offset.
00000084                      C LE_PreLoadNum           dd ?    ;pre-load page count.
00000088                      C LE_NoneRes              dd ?    ;non-resident names table offset.
0000008C                      C LE_NoneResSize          dd ?    ;non-resident names table length.
00000090                      C LE_NoneResChk           dd ?    ;non-resident names checksum.
00000094                      C LE_AutoDS               dd ?    ;automatic data object.
00000098                      C LE_Debug                dd ?    ;debug information offset.
0000009C                      C LE_DebugSize            dd ?    ;debug information size.
000000A0                      C LE_PreLoadInstNum       dd ?    ;pre-load instance pages number.
000000A4                      C LE_DemandInstNum        dd ?    ;demand instance pages number.
000000A8                      C LE_HeapExtra            dd ?    ;extra heap alloction.
000000AC                      C LE_Reserved             db 20 dup (?) ;reserved.
000000C0                      C LE_DeviceID             dw ?    ;device ID (Windows VxD only).
000000C2                      C LE_DDK          dw ?    ;DDK version number.
000000C4                      C LE_Header               ends
                              C 
                              C 
00000000                      C PSP_Struc		struc
                              C ;
                              C ;First the standard DOS PSP structure. Won't use any of existing entries for
                              C ;extended info incase currently un-used entries get used at a later data.
                              C ;
00000000                      C  PSP_INT20		dw ?		;INT 20 instruction for CP/M CALL 0 program
                              C 				;termination the CDh 20h here is often used as a
                              C 				;signature for a valid PSP
00000002                      C  PSP_MemTop		dw ?		;segment of first byte beyond memory allocated to
                              C 				;program. N/A
00000004                      C  PSP_Filler1		db ?		;unused filler
                              C 
00000005                      C  PSP_CPM		db ?		;CP/M CALL 5 service request (FAR JMP to 000C0h)
                              C 				;BUG: (DOS 2+) PSPs created by INT 21/AH=4Bh
                              C 				;point at 000BEh
00000006                      C 		dw ?		;CP/M compatibility--size of first segment for
                              C 				;.COM files
00000008                      C 		dw ?		;remainder of FAR JMP at 05h
0000000A                      C  PSP_INT22		dd ?		;stored INT 22 termination address
0000000E                      C  PSP_INT23		dd ?		;stored INT 23 control-Break handler address
00000012                      C  PSP_INT24		dd ?		;DOS 1.1+ stored INT 24 critical error handler
                              C 				;address
00000016                      C  PSP_Parent		dw ?		;segment of parent PSP
00000018                      C  PSP_HandleList	db 20 dup (?) ;DOS 2+ Job File Table, one byte per file
                              C 				;handle, FFh = closed
0000002C                      C  PSP_Environment	dw ?		;segment of environment for process
0000002E                      C  PSP_INT21SSSP	dd ?		;N/A
00000032                      C  PSP_Handles		dw ?		;DOS 3+ number of entries in JFT (default 20)
00000034                      C  PSP_HandlePtr	dd ?		;DOS 3+ pointer to JFT (default PSP:0018h)
00000038                      C  PSP_Previous	dd ?		;DOS 3+ pointer to previous PSP (default
                              C 				;FFFFFFFFh in 3.x) used by SHARE in DOS 3.3.
0000003C                      C  PSP_Filler2		dd ?		;unused by DOS versions <= 6.00
                              C 				;reportedly used by Novell NetWare shell 3.x
00000040                      C  PSP_DOSVersion	dw ?		;DOS 5+ version to return on INT 21/AH=30h
00000042                      C  PSP_NextPSP		dw ?		;(MSWin3) selector of next PSP (PDB) in linked
                              C 				;list Windows keeps a linked list of Windows
                              C 				;programs only
00000044                      C  PSP_Filler3		dd ?		;unused by DOS versions <= 6.00
00000048                      C  PSP_WinOldAp	db ?		;(MSWindows3) bit 0 set if non-Windows
                              C 				;application (WINOLDAP)
00000049                      C  PSP_Filler4		db 7 dup (?) ;unused by DOS versions <= 6.00
00000050                      C  PSP_INT21		db 3 dup (?) ;DOS 2+ service request (INT 21/RETF instructions)
00000053                      C  PSP_Filler5		db 9 dup (?) ;unused in DOS versions <= 6.00
0000005C                      C  PSP_FCB1		db 16 dup (?) ;first default FCB, filled in from first
                              C 				;commandline argument overwrites second FCB if
                              C 				;opened
0000006C                      C  PSP_FCB2		db 16 dup (?) ;second default FCB, filled in from second
                              C 				;commandline argument overwrites beginning of
                              C 				;commandline if opened
0000007C                      C  PSP_Filler6		dd ?		;unused
00000080                      C  PSP_CommandTail	db 128 dup (?) ;commandline / default DTA
                              C 				;command tail is BYTE for length of tail, N BYTEs
                              C 				;for the tail, followed by a BYTE containing 0Dh
00000100                      C PSP_Struc		ends
                              C 
                              C 
                              C 
                              C 

00000000                        _Seg_	struc
00000000                        Seg_BaseAddress dd ?
00000004                        Seg_Type	dd ?
00000008                        Seg_Length	dd ?
0000000C                        Seg_Memory	dd ?
00000010                        _Seg_	ends

                                if @Model ne 7
                                endif

00000000                        	.data

00000000 00000000               psp dd ?		; PSP linear address

 = 5                            ERR_NOFILES equ 5
 = 6                            ERR_OPENFIL equ 6
 = 7                            ERR_HDRFMT  equ 7
 = 8                            ERR_IO      equ 8
 = 1A                           ERR_ALREADY3P equ 26

00000004 0000                   ErrorNumber	dw 0
                                ;
00000006                        ErrorMessages label dword
00000006 B6000000DE0000001B     	dd Errorm0, Errorm1, Errorm2, Errorm3, Errorm4, Errorm5, Errorm6, Errorm7    ;0-7
00000026 570500007B050000AB     	dd Errorm8, ErrorM9, ErrorM10,ErrorM11,ErrorM12,ErrorM13,ErrorM14,ErrorM15   ;8-15
00000046 84060000AA060000CA     	dd ErrorM16,ErrorM17,ErrorM18,ErrorM19,ErrorM20,ErrorM21,ErrorM22,ErrorM23   ;16-23
00000066 92070000C4070000F8     	dd ErrorM24,ErrorM25,ErrorM26,ErrorM27,ErrorM0, ErrorM0                      ;24-29
0000007E B6000000B600000036     	dd ErrorM0, ErrorM0, ErrorM32,ErrorM33,ErrorM34,ErrorM35,ErrorM36,ErrorM37   ;30-37
0000009E FA080000260900004E     	dd ErrorM38,ErrorM39,ErrorM40,ErrorM41,ErrorM42,ErrorM43                     ;38-43
                                ;
000000B6 4F7065726174696F6E     Errorm0	db 'Operation completed successfully...',13,10,13,10,'$'
000000DE 556E61626C6520746F     Errorm1	db 'Unable to resize memory block, this should never happen...',10,13,'$'
0000011B 496E73756666696369     Errorm2	db 'Insufficient memory available...',13,10,'$'
0000013E 2053796E7461782069     Errorm3	db ' Syntax is:- CWEM Options FileName Options',13,10
0000016A 0D0A                   	db 13,10
0000016C 2020204F7074696F6E     	db '   Options:-',13,10
0000017A 0D0A                   	db 13,10
0000017C 2020203320202D2045     	db '   3  - Enable 32 bit code segments/interupts.',13,10
000001AC 20202B6220202D2042     	db '  +b  - Bind stub loader.',13,10
000001C7 2020206320202D2043     	db '   c  - Config file name, eg, /c[:]example.cfg',13,10
000001F7 2020206420202D2045     	db '   d  - Enable dual mode operation.',13,10
0000021C 2020206620202D2053     	db '   f  - Sort fixups to enable fast-load.',13,10
00000246 20202B6720202D2045     	db '  +g  - Enable GROUP type segments (data limits set to end of program).',13,10
0000028F 2020206920202D2044     	db '   i  - Display 3P header information. use i, is, ir or irs.',13,10
000002CD 202020202020202065     	db "        eg, /isr to see everything (s/r order not important).",13,10
0000030C 2020206C20202D2045     	db '   l  - Enable LDT usage.',13,10
00000327 2020206E20202D2045     	db '   n  - Enable NEAR mode (code/data in same segment).',13,10
0000035E 2020207320202D2053     	db '   s  - Set auto-stack size, eg, /s2048.',13,10
00000388 2020207520202D2055     	db '   u  - Update copy of CauseWay in a CauseWay file.',13,10
000003BD 20202B7A20202D2041     	db '  +z  - Append auto-stack segment to NEAR segment in NEAR model.',13,10
000003FF 0D0A                   	db 13,10
00000401 20546865206F707469     	db ' The options above that have a + before them are ON by default.',13,10
00000442 205377697463686573     	db ' Switches are ON with + or /, OFF with -.',13,10
0000046D 2054686520636F6D6D     	db ' The command line can be in any order.',13,10
00000495 204966206E6F206578     	db ' If no extension is specified then .EXE is used (.MAP for map files).',13,10
000004DC 0D0A0D0A24             	db 13,10,13,10,'$'
000004E1 4E6F206F7065726174     Errorm4	db 'No operation type specified...',13,10,'$'
00000502 4E6F2066696C657320     Errorm5	db 'No files found to alter...',13,10,'$'
0000051F 556E61626C6520746F     Errorm6	db 'Unable to open EXE file...',13,10,'$'
0000053C 496E636F7272656374     Errorm7	db 'Incorrect header type...',13,10,'$'
00000557 492F4F206572726F72     Errorm8	db 'I/O error while accessing file...',13,10,'$'
0000057B 436F756C64206E6F74     Errorm9	db 'Could not find CauseWay stub file CWSTUB.EXE.',13,10,'$'
000005AB 436F756C64206E6F74     ErrorM10	db 'Could not find .MAP file.',13,10,'$'
000005C7 436F756C64206E6F74     ErrorM11	db 'Could not identify segment list header.',13,10,'$'
000005F1 426164207365676D65     ErrorM12	db 'Bad segment definition.',13,10,'$'
0000060B 4E6F207365676D656E     ErrorM13	db 'No segment definitions found.',13,10,'$'
0000062B 5365676D656E742064     ErrorM14	db 'Segment does not have recognized class.',13,10,'$'
00000655 556E7265636F676E69     ErrorM15	db 'Unrecognized variable in configuration file.',13,10,'$'
00000684 53796E746178206572     ErrorM16	db 'Syntax error in configuration file.',13,10,'$'
000006AA 546F206D616E792073     ErrorM17	db 'To many segment declarations.',13,10,'$'
000006CA 4D6178696D756D206C     ErrorM18	db 'Maximum line length exceeded.',13,10,'$'
000006EA 556E61626C6520746F     ErrorM19	db 'Unable to create output file.',13,10,'$'
0000070A 456E74727920706F69     ErrorM20	db 'Entry point is not in a code segment.',13,10,'$'
00000732 4E6F20737461636B20     ErrorM21	db 'No stack defined.',13,10,'$'
00000746 537461636B2063616E     ErrorM22	db 'Stack cannot be in a code segment / No stack.',13,10,'$'
00000776 496E76616C69642072     ErrorM23	db 'Invalid relocation entry.',13,10,'$'
00000792 4F6E6C792031207365     ErrorM24	db 'Only 1 segment definition allowed in NEAR mode.',13,10,'$'
000007C4 436F756C64206E6F74     ErrorM25	db 'Could not identify stack segment in segment list.',13,10,'$'
000007F8 20697320616C726561     ErrorM26	db ' is already in CauseWay format.',13,10,'$'
0000081A 496E76616C69642061     ErrorM27	db 'Invalid auto-stack value.',13,10,'$'
                                ;
00000836 436F756C64206E6F74     ErrorM32	db "Could not open specified LE file.",13,10,0
0000085A 4572726F7220726561     ErrorM33	db "Error reading LE offset.",13,10,0
00000875 4E6F7420656E6F7567     ErrorM34	db "Not enough memory to load LE file.",13,10,0
0000089A 4572726F7220726561     ErrorM35	db "Error reading LE file.",13,10,0
000008B3 4E6F7420656E6F7567     ErrorM36	db "Not enough memory to build 3P image.",13,10,0
000008DA 436F756C64206E6F74     ErrorM37	db "Could not create output file.",13,10,0
000008FA 4572726F72206F6363     ErrorM38	db "Error occured while writeing output file.",13,10,0
00000926 4D756C7469706C6520     ErrorM39	db "Multiple fixup records not supported.",13,10,0
0000094E 4F6E6C7920696E7465     ErrorM40	db "Only internal fixups supported.",13,10,0
00000970 496E76616C69642066     ErrorM41	db "Invalid fixup type, only Seg16 and Offset32 supported.",13,10,0
000009A9 4572726F7220726561     ErrorM42	db "Error reading extender stub loader.",13,10,0
000009CF 556E6B6E6F776E2066     ErrorM43	db "Unknown fixup flag settings.",13,10,0
                                ;
000009EE 4552524F523A2000       ErrorText	db 'ERROR: ',0
                                	if	0
                                	endif
000009F6 5741524E494E473A20     SegSamet	db 'WARNING: Segments found with same paragraph base address.',13,10,0
                                ;
00000A32 5573696E6720696E74     InternalConfig	db 'Using internal segment configuration details.',13,10,0
00000A62 4C696E6B696E672043     ProcessStubText db 'Linking CauseWay stub loader.',13,10,0
00000A82 50726F63657373696E     ProcessMapText	db 'Processing map file.',13,10,0
00000A99 50726F63657373696E     ProcessExeText	db 'Processing EXE relocation table.',13,10,0
00000ABC 47656E65726174696E     GenerateExeText db 'Generating new executable file.',13,10,0
00000ADE 0D0A00                 CarriageReturn	db 13,10,0
00000AE1 0D0A24                 CarriageReturn2 db 13,10,"$"
                                ;
00000AE4 6377656D2E63666700     ConfigName	db 'cwem.cfg',0
00000AED 4357535455422E4558     CWStubName	db "CWSTUB.EXE",0
00000AF8 0000                   ConfigHandle	dw 0
00000AFA 0000                   SHELLHandle	dw 0
00000AFC 45584500               EXEextension	db 'EXE',0
00000B00 0000                   EXEHandle	dw 0                  ; file handle of .EXE to patch
00000B02 4D415000               MAPextension	db 'MAP',0
00000B06 0000                   MAPHandle	dw 0                  ; file handle of .MAP file
00000B08 636B616E657464792E     TempFileName	db 'ckanetdy.ckq',0
00000B15 0000                   TempHandle	dw 0
                                ;
00000B17 00000000               SegmentList	dd 0
00000B1B 00000000               SegCurrent	dd ?
00000B1F 00000000               SegmentTotal	dd ?
00000B23 00000000               ExeSegment	dd ?
                                ;
00000000                        	.data?

00000000 000000000000000000     ConfigPath	db 128 dup (?)
00000080 000000000000000000     SHELLFileName	db 128 dup (?)    ; name of CW.EXE binary, gotten from environment
00000100 000000000000000000     EXEFileName	db 64 dup (?)
00000140 000000000000000000     MAPFileName	db 64 dup (?)
00000180 000000000000000000     LineBuffer	db 1024 dup (?)

00000B27                        	.data
                                ;
00000B27 00000000               RelocSegment	dd ?
                                ;
00000000                        MZHdr struct
00000000                        Signature	dw ?	;00 Identifier text 'MZ', '3P'.
00000002                        _Length		dw ?	;02 Length of file MOD 512
00000004                        			dw ?	;04 Length of file in 512 byte blocks.
00000006                        RelocNum	dw ?	;06 Number of relocation items.
00000008                        HeaderSize	dw ?	;08 Length of header in 16 byte paragraphs.
0000000A                        MinAlloc	dw ?	;0A Minimum number of para's needed above program.
0000000C                        MaxAlloc	dw ?	;0C Maximum number of para's needed above program.
0000000E                        StackSeg	dw ?	;0E Segment displacement of stack module.
00000010                        EntrySP		dw ?	;10 value for SP at entry.
00000012                        CheckSum	dw ?	;12 Check sum...
00000014                        EntryIP	dw ?	;14 Contents of IP at entry.
00000016                        EntryCS	dw ?	;16 Segment displacement of CS at entry.
00000018                        RelocFirst	dw ?	;18 First relocation item offset.
0000001A                        OverlayNum	db ?	;1A Overlay number.
0000001B                        MZHdr ends

00000B2B 000000000000000000     exehdr MZHdr <>
                                ;
00000B46 00000000               ExeSize1	dw ?,?	;Header size
00000B4A 00000000               ExeSize2	dw ?,?	;Real file size.
                                ;
00000B4E 000000000000000000     NewHeader	NewHeaderStruc <>	;make space for a header.
                                ;
                                ;List of variables for the config file.
                                ;
00000B8E 020C0000FE2C000053     VariableList	dd SegHeaderVAR,WhiteSpaceString,SegHeaderText,0
00000B9E 100C0000A62D000022     	dd SegFormatVAR,SegFormatCode,SegLayout,0
00000BAE 1E0C0000FE2C000041     	dd CodeClassVAR,WhiteSpaceString,SegClassCODE,0
00000BBE 280C0000FE2C000047     	dd DataClassVAR,WhiteSpaceString,SegClassDATA,0
00000BCE 320C0000FE2C00004D     	dd StackClassVAR,WhiteSpaceString,SegClassSTACK,0
00000BDE 3D0C0000FE2C000054     	dd ConstClassVAR,WhiteSpaceString,SegClassCONST,0
00000BEE 480C0000FE2C00005B     	dd NearClassVAR,WhiteSpaceString,SegClassNEAR,0
00000BFE FFFFFFFF               	dd -1
                                ;
00000C02 5365676D656E744865     SegHeaderVAR	db 'SegmentHeader',0
00000C10 5365676D656E74466F     SegFormatVAR	db 'SegmentFormat',0
00000C1E 436F6465436C617373     CodeClassVAR	db 'CodeClass',0
00000C28 44617461436C617373     DataClassVAR	db 'DataClass',0
00000C32 537461636B436C6173     StackClassVAR	db 'StackClass',0
00000C3D 436F6E7374436C6173     ConstClassVAR	db 'ConstClass',0
00000C48 4E656172436C617373     NearClassVAR	db 'NearClass',0
                                ;
                                ;
                                ;The text looked for to identify start of segment list. Any amount of white space can
                                ;be replaced with a single space here. search is NOT case sensitive.
                                ;
00000C52 FF                     	db -1
00000C53 207374617274207374     SegHeaderText	db ' start stop length name class',0
00000C71 000000000000000000     	db 128 dup (0)
                                ;
00000CF1 050D00000A0D000010     SegFormatTexts	dd NullText,StartText,LengthText,ClassText,-1
00000D05 6E756C6C00             NullText	db 'null',0
00000D0A 737461727400           StartText	db 'start',0
00000D10 6C656E67746800         LengthText	db 'length',0
00000D17 636C61737300           ClassText	db 'class',0
00000D1D 0000000000             SegFormatSlots	db 0,0,0,0,0
                                ;
                                ;Layout of each line.
                                ;
                                ;0	- Ignore.
                                ;1	- Start.
                                ;2	- Length.
                                ;3	- Class.
                                ;
00000D22 0100020003FF           SegLayout	db 1,0,2,0,3,-1
00000D28 FFFFFFFFFFFFFFFFFF     	db 256 dup (-1)

                                ;
                                ;List of different class's recognised.
                                ;
00000E28 410E0000471600004D     SegClassList	dd SegClassCODE,SegClassDATA,SegClassSTACK,SegClassCONST,SegClassNEAR,-1


                                ;
                                ;list of code segment classes seperated by a space.
                                ;
00000E40 FF                     	db -1
00000E41 636F646500             SegClassCODE	db 'code',0
00000E46                        	db 2048 dup (0)

                                ;
                                ;List of data segment classes seperated by a space.
                                ;
00001646 FF                     	db -1
00001647 6461746100             SegClassDATA	db 'data',0
0000164C                        	db 2048 dup (0)

                                ;
                                ;List of stack segment classes seperated by a space.
                                ;
00001E4C FF                     	db -1
00001E4D 737461636B00           SegClassSTACK	db 'stack',0
00001E53                        	db 2048 dup (0)

                                ;
                                ;List of const segment classes seperated by a space.
                                ;
00002653 FF                     	db -1
00002654 636F6E737400           SegClassCONST	db 'const',0
0000265A                        	db 2048 dup (0)

                                ;
                                ;List of flat segment classes seperated by space.
                                ;
00002E5A FF                     	db -1
00002E5B 4E45415200             SegClassNEAR	db 'NEAR',0
00002E60                        	db 2048 dup (0)

                                ;
00003660 313620626974206170     Bit16Text	db '16 bit application.',13,10,'$'
00003676 333220626974206170     Bit32Text	db '32 bit application.',13,10,'$'
0000368C 4475616C206D6F6465     BitDualText	db 'Dual mode application.',13,10,'$'
000036A5 53706565642D4C6F61     SpeedLoadText	db "Speed-Load enabled.",13,10,13,10,"$"
                                ;
000036BD 202020203350207369     NewSizeT	db '    3P size: ',0	;byte size of 3P file.
000036CB 20496D616765207369     NewLengthT	db ' Image size: ',0	;byte size of exe image data.
000036D9 4D656D6F7279207369     NewAllocT	db 'Memory size: ',0	;byte size of program.
000036E7 2020205365676D656E     NewSegmentsT	db '   Segments: ',0	;number of segment definitions.
000036F5 52656C6F636174696F     NewRelocsT	db 'Relocations: ',0	;number of relocation table entries.
00003703 2020456E7472792045     NewEntryEIPt	db '  Entry EIP: ',0	;entry offset.
00003711 202020456E74727920     NewEntryCSt	db '   Entry CS: ',0	;segment list entry number for entry CS.
0000371F 2020456E7472792045     NewEntryESPt	db '  Entry ESP: ',0	;ESP offset.
0000372D 202020456E74727920     NewEntrySSt	db '   Entry SS: ',0	;segment list entry number for SS.
0000373B 204175746F2D537461     NewEntryAutoSS	db ' Auto-Stack: ',0	;Auto stack size.
                                ;
00003749 0D0A52656164696E67     ReadingMainText db 13,10,"Reading segments, relocations and image data.",13,10,0
                                ;
0000377B 0D0A205365676D656E     SegmentStuff	db 13,10," Segment definition details"
00003798 0D0A3D3D3D3D3D3D3D     	db 13,10,"============================",13,10
000037B8 0D0A204E6F2E202020     	db 13,10,' No.   Base     Limit  Class'
000037D6 0D0A2D2D2D2D2D2D2D     	db 13,10,'-----------------------------',13,10,0
                                ;
000037F8 0D0A2052656C6F6361     RelocStuff	db 13,10," Relocation entry details"
00003813 0D0A3D3D3D3D3D3D3D     	db 13,10,"==========================",13,10
00003831 0D0A204E6F2E20204F     	db 13,10,' No.  Offset   Segment'
00003849 0D0A2D2D2D2D2D2D2D     	db 13,10,'-----------------------',13,10,0
                                ;
00003865 494E56414C494420       InvalidText	db "INVALID "
                                ;
0000386D 00000000               Real3POffset	dd ?
                                ;
00003871 52656164696E672073     ReadingLEText	db "Reading specified LE file.",13,10,0
0000388E 4275696C64696E6720     BuildImageText	db "Building EXE and segment image.",13,10,0
000038B0 4275696C64696E6720     BuildRelocsText db "Building relocation table.",13,10,0
000038CD 4275696C64696E6720     BuildHeaderText db "Building 3P format header.",13,10,0
000038EA 5772697465696E6720     Write3PText	db "Writeing 3P file.",13,10,0
                                ;
000038FE 00000000               LEAddress	dd 0
00003902 00000000               LELength	dd 0
00003906 00000000               LEOffset	dd 0
                                ;
0000390A 00000000               ObjectCount	dd 0
0000390E 00000000               ObjectBase	dd 0
00003912 00000000               ObjectList	dd 0
                                ;
00003916 00000000               RelocationList	dd 0
                                ;
0000391A 00000000               SegmentBase	dd 0
                                ;
0000391E 0000000000000000       PageCount	dd 0,0
                                ;
00003926 000000000000000000     RealHeader	NewHeaderStruc <>
                                ;
00003966 00000000               StubMem	dd 0
0000396A 00000000               RelocationCount dd 0
                                ;
                                if @Model ne 7
                                endif
                                ;
0000396E 0000000000000000       RelocMem	dd 0,0
00003976 00000000               P3Offset	dd 0

0000397A FF                     	db -1			;just to make sure end of segment is initialised.

00000000                        	.code

00000000 436175736557617920     HiThere	 db 'CauseWay EXE maker v2.02.',13,10,'$'

                                ifdef _DEBUG
                                        include dprintf.inc
                              C 
                              C ;--- simple 32-bit printf() implementation;
                              C ;--- used by debug displays only.
                              C ;--- assume ds:nothing, ss:nothing
                              C 
                              C ;--- ltob(long n[eax], char *outb[ebx], int base[cx]);
                              C ;--- convert long to string;
                              C ;--- outb is assumed to be stack-located.
                              C 
                              C @dprintf macro cond,fmt,a1,a2,a3,a4,a5
 >                            C if DBGOPT and cond
 >                            C   for x,<a5,a4,a3,a2,a1>
 >                            C    ifnb <x>
 >                            C 	push x
 >                            C    endif
 >                            C   endm
 >                            C 	call dprintf
 >                            C 	db fmt,0
 >                            C endif
 >                            C endm
                              C 
0000001C                      C ltob PROC uses edi
                              C 
0000001D 0FB7F9               C 	movzx edi, cx
00000020 B500                 C 	mov ch,0
00000022 6683FFF6             C 	cmp di,-10
00000026 750C                 C 	jne @F
00000028 66BF0A00             C 	mov di,10
0000002C 23C0                 C 	and eax,eax
0000002E 7904                 C 	jns @F
00000030 F7D8                 C 	neg eax
00000032 B52D                 C 	mov ch,'-'
00000034                      C @@:
00000034 83C30A               C 	add ebx,10
00000037 36C60300             C 	mov BYTE PTR ss:[ebx],0
0000003B 4B                   C 	dec ebx
0000003C                      C @@nextdigit:
0000003C 33D2                 C 	xor edx, edx
0000003E F7F7                 C 	div edi
00000040 80C230               C 	add dl,'0'
00000043 80FA39               C 	cmp dl,'9'
00000046 7603                 C 	jbe @F
00000048 80C227               C 	add dl,7+20h
0000004B                      C @@:
0000004B 368813               C 	mov ss:[ebx],dl
0000004E 664B                 C 	dec bx
00000050 23C0                 C 	and eax, eax
00000052 75E8                 C 	jne @@nextdigit
00000054 80FD00               C 	cmp ch,0
00000057 7404                 C 	je @F
00000059 36882B               C 	mov ss:[ebx],ch
0000005C 4B                   C 	dec ebx
0000005D                      C @@:
0000005D 43                   C 	inc ebx
0000005E 8BC3                 C 	mov eax,ebx
                              C 	ret
                              C 
00000062                      C ltob ENDP
                              C 
00000062                      C dprintf PROC
                              C 
                              C local size_:dword
                              C local flag:byte
                              C local longarg:byte
                              C local fill:byte
                              C local szTmp[12]:byte
                              C 
 = [ebp+4]                    C fmt equ <[ebp+4]>
                              C 
00000068 60                   C 	pushad
00000069 9C                   C 	pushfd
0000006A 8D7D08               C 	lea edi,[ebp+4+4]
0000006D                      C @@L335:
0000006D 8B7504               C 	mov esi,[ebp+4]
00000070                      C nextchar:
00000070 2EAC                 C 	lodsb cs:[esi]
00000072 0AC0                 C 	or al,al
00000074 740B                 C 	je done
00000076 3C25                 C 	cmp al,'%'
00000078 741C                 C 	je formatitem
0000007A E834010000           C 	call print_char
0000007F EBEF                 C 	jmp nextchar
00000081                      C done:
00000081 83EF04               C 	sub edi,4
00000084 368937               C 	mov ss:[edi],esi ;store new EIP
00000087 8B4500               C 	mov eax,[ebp]    ;get old value of EBP
0000008A 9D                   C 	popfd
0000008B 8BEC                 C 	mov ebp,esp
0000008D 894508               C 	mov [ebp+2*4],eax;now EBP will be restored by popad
00000090 897D20               C 	mov [ebp+8*4],edi;finally store new SP
00000093 61                   C 	popad
00000094 5C                   C 	pop esp
00000095 C3                   C 	retn
                              C 
00000096                      C formatitem:
00000096 68 0000006Do         C 	push @@L335
0000009B 33D2                 C 	xor edx,edx
0000009D 8855FA               C 	mov [longarg],dl
000000A0 B301                 C 	mov bl,1
000000A2 B120                 C 	mov cl,' '
000000A4 2E803E2D             C 	cmp BYTE PTR cs:[esi],'-'
000000A8 7502                 C 	jne @F
000000AA 4B                   C 	dec ebx
000000AB 46                   C 	inc esi
000000AC                      C @@:
000000AC 885DFB               C 	mov [flag],bl
000000AF 2E803E30             C 	cmp BYTE PTR cs:[esi],'0'
000000B3 7503                 C 	jne @F
000000B5 B130                 C 	mov cl,'0'
000000B7 46                   C 	inc esi
000000B8                      C @@:
000000B8 884DF9               C 	mov [fill],cl
000000BB 8BDA                 C 	mov ebx,edx
                              C 
000000BD                      C 	.while byte ptr cs:[esi] >= '0' && byte ptr cs:[esi] <= '9'
000000BF 2EAC                 C 		lodsb cs:[esi]
000000C1 2C30                 C 		sub al,'0'
000000C3 0FB6C0               C 		movzx eax,al
000000C6 D1E3                 C 		shl ebx,1           ;ebx*2
000000C8 8D1C9B               C 		lea ebx,[ebx*4+ebx]	;ebx*10
000000CB 03D8                 C 		add ebx,eax
000000CD                      C 	.endw
                              C 
000000D9 895DFC               C 	mov [size_],ebx
000000DC 2E803E6C             C 	cmp BYTE PTR cs:[esi],'l'
000000E0 7505                 C 	jne @F
000000E2 C645FA01             C 	mov [longarg],1
000000E6 46                   C 	inc esi
000000E7                      C @@:
000000E7 2EAC                 C 	lodsb cs:[esi]
000000E9 897504               C 	mov [ebp+4],esi
000000EC 3C78                 C 	cmp al,'x'
000000EE 742F                 C 	je handle_x
000000F0 3C58                 C 	cmp al,'X'
000000F2 742B                 C 	je handle_x
000000F4 3C63                 C 	cmp al,'c'
000000F6 741B                 C 	je handle_c
000000F8 3C64                 C 	cmp al,'d'
000000FA 7429                 C 	je handle_d
000000FC 3C69                 C 	cmp al,'i'
000000FE 7425                 C 	je handle_i
00000100 3C73                 C 	cmp al,'s'
00000102 744E                 C 	je handle_s
00000104 3C75                 C 	cmp al,'u'
00000106 7423                 C 	je handle_u
00000108 3C00                 C 	cmp al,0
0000010A 750D                 C 	jnz @@L359
0000010C 6658                 C 	pop ax
0000010E E96EFFFFFF           C 	jmp done
00000113                      C handle_c:
00000113 368B07               C 	mov eax,ss:[edi]
00000116 83C704               C 	add edi,4
00000119                      C @@L359:
00000119 E895000000           C 	call print_char
0000011E C3                   C 	retn
                              C 
0000011F                      C handle_x:
0000011F 66B91000             C 	mov cx,16
00000123 EB0A                 C 	jmp @@lprt262
00000125                      C handle_d:
00000125                      C handle_i:
00000125 66B9F6FF             C 	mov cx,-10
00000129 EB04                 C 	jmp @@lprt262
0000012B                      C handle_u:
0000012B 66B90A00             C 	mov cx,10
0000012F                      C @@lprt262:
0000012F 368B07               C 	mov eax,ss:[edi]
00000132 83C704               C 	add edi,4
00000135 807DFA00             C 	cmp [longarg],0
00000139 7503                 C 	jne @F
0000013B 0FB7C0               C 	movzx eax,ax
0000013E                      C @@:
0000013E 8D5DED               C 	lea ebx,[szTmp]
00000141 E8D6FEFFFF           C 	call ltob
00000146 8BF0                 C 	mov esi,eax
00000148 1E                   C 	push ds
00000149 16                   C 	push ss
0000014A 1F                   C 	pop ds
0000014B E81D000000           C 	call print_string
00000150 1F                   C 	pop ds
00000151 C3                   C 	retn
                              C 
00000152                      C handle_s:
00000152 368B37               C 	mov esi,ss:[edi]
00000155 83C704               C 	add edi,4
00000158 807DFA00             C 	cmp [longarg],0
0000015C 740F                 C 	je print_string
0000015E 1E                   C 	push ds
0000015F 368E1F               C 	mov ds,ss:[edi]
00000162 6683C704             C 	add di,4
00000166 E802000000           C 	call print_string
0000016B 1F                   C 	pop ds
0000016C C3                   C 	retn
                              C 
0000016D                      C print_string:	;display string at ds:si
0000016D 8BC6                 C 	mov eax,esi
0000016F 8B5DFC               C 	mov ebx,size_
00000172                      C 	.while byte ptr [esi]
00000174 46                   C 		inc esi
00000175                      C 	.endw
0000017A 2BF0                 C 	sub esi,eax
0000017C 96                   C 	xchg eax,esi
0000017D 2BD8                 C 	sub ebx,eax
0000017F                      C 	.if flag == 1
00000185                      C 		.while sdword ptr ebx > 0
00000187 8A45F9               C 			mov al,[fill]
0000018A E824000000           C 			call print_char
0000018F 4B                   C 			dec ebx
00000190                      C 		.endw
00000195                      C 	.endif
                              C 
00000195                      C 	.while byte ptr [esi]
00000197 AC                   C 		lodsb
00000198 E816000000           C 		call print_char
0000019D                      C 	.endw
                              C 
000001A2                      C 	.while sdword ptr ebx > 0
000001A4 8A45F9               C 		mov al,[fill]
000001A7 E807000000           C 		call print_char
000001AC 4B                   C 		dec ebx
000001AD                      C 	.endw
000001B2 C3                   C 	retn
000001B3                      C print_char:
000001B3 3C0A                 C 	cmp al,10
000001B5 7509                 C 	jnz @F
000001B7 B00D                 C 	mov al,13
000001B9 E802000000           C 	call @F
000001BE B00A                 C 	mov al,10
000001C0                      C @@:
000001C0 53                   C 	push ebx
000001C1 33DB                 C 	xor ebx,ebx
000001C3 B40E                 C 	mov ah,0Eh
000001C5 CD10                 C 	int 10h
000001C7 5B                   C 	pop ebx
000001C8 C3                   C 	retn
                              C 
 =                            C fmt equ <>
                              C 
000001C9                      C dprintf ENDP
                              C 
000001C9 8D4000               C 	align 4
                                 ifndef DBGOPT
 = FFFFFFFF                     DBGOPT = -1
                                 endif
                                endif

                                ifndef CWAPP
                                 if @Model ne 7
                                 else
000001CC                        start:
                                 endif
                                endif
000001CC                        Entry	proc	far

                                ifndef CWAPP
000001CC 891D 00000000o         	mov [psp], ebx		;set by LOADPE.BIN
                                endif
                                if @Model ne 7
                                endif
                                	;
000001D2 BA 00000000o           	mov	edx,offset HiThere
000001D7 B409                   	mov	ah,9
000001D9 CD21                   	int	21h
000001DB 66C705 00000004o 03    	mov	ErrorNumber,3
         00
                                	;
000001E4 BF 00000B50o           	mov	edi,offset NewHeader+2
000001E9 B93E000000             	mov	ecx,size NewHeaderStruc-2
000001EE 32C0                   	xor	al,al
000001F0 F3AA                   	rep	stosb
                                	;
000001F2 C605 000039C3o 2B      	mov	OptionTable+'G','+'	;default to groups.
000001F9 C605 000039BEo 2B      	mov	OptionTable+'B','+'	;default to bind loader.
00000200 C605 000039D6o 2B      	mov	OptionTable+'Z','+'	;default to auto stack on near.
                                	;
00000207 E8B52C0000             	call	ReadCommand		;read the command line.
0000020C 6683F801               	cmp	ax,1
00000210 0F82FC020000           	jc	System		;need at least 2 names.
00000216 66C705 00000004o 05    	mov	ErrorNumber,5
         00
                                	@dprintf 1,<"debug messages ON",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
0000021F E83EFEFFFF          1  	call dprintf
00000224 6465627567206D6573  1  	db "debug messages ON",10,0
00000237 66833D 000039FCo 00    	cmp	word ptr[OptionTable+128],0	;get file name mask.
0000023F 0F84CD020000           	jz	System		;must have a name.
00000245 803D 000039CAo 00      	cmp	OptionTable+'N',0
0000024C 7407                   	jz	@@NoGroupDel
0000024E C605 000039C3o 00      	mov	OptionTable+'G',0	;turn group stuff off.
00000255                        @@NoGroupDel:	;
                                	;Read config file.
                                	;
00000255 E8F8280000             	call	ReadConfig
0000025A 0F85B2020000           	jnz	System
                                	;
                                	;Get the .EXE file name and add .EXE if needed.
                                	;
00000260 8B35 000039FCo         	mov	esi,dword ptr[OptionTable+128]	;get file name mask.
00000266 BF 00000100o           	mov	edi,offset EXEFileName
0000026B FC                     	cld
0000026C 32C0                   	xor	al,al
0000026E                        @@0:
0000026E A4                     	movsb
0000026F 807EFF2E               	cmp	byte ptr[esi-1],'.'
00000273 7502                   	jnz	@@1
00000275 B001                   	mov	al,1
00000277                        @@1:
00000277 807EFF00               	cmp	byte ptr[esi-1],0
0000027B 75F1                   	jnz	@@0
0000027D 0AC0                   	or	al,al
0000027F 7510                   	jnz	@@2
00000281 C647FF2E               	mov	byte ptr[edi-1],'.'
00000285 BE 00000AFCo           	mov	esi,offset EXEextension
0000028A                        @@4:
0000028A A4                     	movsb
0000028B 807EFF00               	cmp	byte ptr[esi-1],0
0000028F 75F9                   	jnz	@@4
                                	;
00000291                        @@2:	;Generate .MAP file name.
                                	;
00000291 BE 00000100o           	mov	esi,offset EXEFileName
00000296 BF 00000140o           	mov	edi,offset MapFileName
0000029B                        @@3:
0000029B A4                     	movsb
0000029C 807EFF2E               	cmp	byte ptr[esi-1],'.'
000002A0 75F9                   	jnz	@@3
000002A2 BE 00000B02o           	mov	esi,offset MAPextension
000002A7                        @@5:
000002A7 A4                     	movsb
000002A8 807EFF00               	cmp	byte ptr[esi-1],0
000002AC 75F9                   	jnz	@@5
                                	;
                                	;Generate shell file name.
                                	;
000002AE 8B1D 00000000o         	mov	ebx, psp
000002B4 668B5B2C               	mov	bx,[ebx+2ch]		;Get enviroment string selector
000002B8 66B80600               	mov ax,6
000002BC CD31                   	int 31h
000002BE 6651                   	push cx
000002C0 6652                   	push dx
000002C2 5E                     	pop esi			;Point at the enviroment string.
000002C3                        @@10a:
000002C3 8A06                   	mov	al,[esi]		;Get a byte.
000002C5 46                     	inc	esi		;/
000002C6 0AC0                   	or	al,al		;End of a string?
000002C8 75F9                   	jnz	@@10a		;keep looking.
000002CA 8A06                   	mov	al,[esi]		;Double zero?
000002CC 0AC0                   	or	al,al		;/
000002CE 75F3                   	jnz	@@10a		;keep looking.
000002D0 83C603                 	add	esi,3		;Skip last 0 and word count.
000002D3 FC                     	cld			;/
000002D4 BF 00000080o           	mov	edi,offset SHELLFileName	;Where we're gonna put it.
000002D9 8BD7                       mov	edx,edi
000002DB                        @@70:
000002DB AC                     	lodsb
000002DC AA                         stosb
000002DD 3C5C                       cmp al,'\'
000002DF 7502                       jnz noslash
000002E1 8BD7                       mov edx,edi
000002E3                        noslash:
000002E3 3C00                   	cmp	al,0		;copy till end.
000002E5 75F4                   	jnz	@@70
000002E7 8BFA                   	mov edi, edx
000002E9 BE 00000AEDo               mov esi, offset CWStubName
000002EE                        nextchar:
000002EE AC                         lodsb
000002EF AA                         stosb
000002F0 22C0                       and al,al
000002F2 75FA                       jnz nextchar
                                	;
                                	;Check file type.
                                	;
                                ;	mov	bx,EXEHandle
                                ;	call	CloseFile
000002F4 BA 00000100o           	mov	edx,offset EXEFileName
000002F9 E80B2D0000             	call	OpenFile		;Open the .EXE file.
000002FE 66C705 00000004o 06    	mov	ErrorNumber,6	;default to not found.
         00
00000307 0F8205020000           	jc	System
                                	@dprintf 1,<"Entry: open file %s ok",10>,edx
                             1    for x,<,,,,edx>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
0000030D 52                  2  	push edx
0000030E E84FFDFFFF          1  	call dprintf
00000313 456E7472793A206F70  1  	db "Entry: open file %s ok",10,0
0000032B 66A3 00000B00o         	mov	EXEHandle,ax
00000331 668BD8                 	mov	bx,ax
                                	;
                                	;See if EXE is LE format.
                                	;
00000334 BA 00000B2Bo           	mov edx, offset exehdr
00000339 B91B000000             	mov ecx, sizeof MZHdr
0000033E B43F                   	mov	ah,3fh
00000340 CD21                   	int	21h		;read the .EXE header.
00000342 6683F81B               	cmp	ax,sizeof MZHdr
00000346 7572                   	jnz	@@LEReset
00000348 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Correct ID?
         5A
00000351 7567                   	jnz	@@LEReset
00000353 66833D 00000B33o 04    	cmp	exehdr.HeaderSize, 4	; at least 40h byte header?
0000035B 725D                   	jb	@@LEReset

0000035D 66BA3C00               	mov	dx,3ch
00000361 6633C9                 	xor	cx,cx
00000364 66B80042               	mov	ax,4200h
00000368 CD21                   	int	21h
0000036A 52                     	push	edx
0000036B 8BD4                   	mov	edx,esp
0000036D B904000000             	mov	ecx,4
00000372 B43F                   	mov	ah,3fh
00000374 CD21                   	int	21h		;Fetch LE offset.
00000376 5D                     	pop	ebp
00000377 7241                   	jc	@@LEReset
00000379 663BC1                 	cmp	ax,cx
0000037C 753C                   	jnz	@@LEReset
0000037E 0BED                   	or	ebp,ebp		;We get anything?
00000380 7438                   	jz	@@LEReset
00000382 668BD5                 	mov	dx,bp
00000385 C1ED10                 	shr	ebp,16
00000388 668BCD                 	mov	cx,bp
0000038B 66B80042               	mov	ax,4200h
0000038F CD21                   	int	21h		;Move to LE section.
00000391 52                     	push	edx
00000392 8BD4                   	mov	edx,esp
00000394 B902000000             	mov	ecx,2
00000399 B43F                   	mov	ah,3fh
0000039B CD21                   	int	21h
0000039D 5A                     	pop	edx
0000039E 721A                   	jc	@@LEReset
000003A0 663BC1                 	cmp	ax,cx
000003A3 7515                   	jnz	@@LEReset
000003A5 6681FA4C45             	cmp	dx,"EL"		;LE?
000003AA 750E                   	jnz	@@LEReset

000003AC B43E                   	mov	ah,3eh
000003AE CD21                   	int	21h		;close .EXE file.
                                	;
000003B0 E8D0040000             	call	LEProcess		;convert LE file.
000003B5 E958010000             	jmp	System
                                	;
000003BA                        @@LEReset:	;Reset to start of file again.
                                	;
000003BA 6633D2                 	xor	dx,dx
000003BD 6633C9                 	xor	cx,cx
000003C0 66B80042               	mov	ax,4200h
000003C4 CD21                   	int	21h
                                	;
                                	;See if EXE is already 3P.
                                	;
                                if 0 ; exehdr was already read
                                else
000003C6 66813D 00000B2Bo 33    	cmp exehdr.Signature,'P3'   ;is .EXE a plain 3P file without MZ header?
         50
000003CF 7543                   	jnz @@DoExe
                                	@dprintf 1,<"Entry: file in 3P format, displaying info",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000003D1 E88CFCFFFF          1  	call dprintf
000003D6 456E7472793A206669  1  	db "Entry: file in 3P format, displaying info",10,0
00000401 66C705 00000004o 00    	mov	ErrorNumber,0
         00
0000040A E828130000             	call NewExeInfo
0000040F E9FE000000             	jmp	System
                                endif
                                	;
00000414                        @@DoEXE:
00000414 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
0000041A 66833D 00000B2Do 00    	cmp	exehdr._Length,0
00000422 7402                   	je	medexe2		; not rounded if no modulo

00000424 6648                   	dec	ax		;lose 1 cos its rounded up

00000426                        medexe2:
00000426 0FB7C0                 	movzx eax, ax
00000429 69C000020000           	imul eax, 200h
0000042F 0FB715 00000B2Do       	movzx edx,exehdr._Length	;add length mod 512
00000436 03C2                   	add eax, edx
00000438 50                     	push eax
00000439 665A                   	pop dx
0000043B 6659                   	pop cx
0000043D 66B80042               	mov	ax,4200h
00000441 668B1D 00000B00o       	mov	bx,EXEHandle
00000448 CD21                   	int	21h
                                	;
0000044A BA 00000B2Bo           	mov	edx,offset exehdr
0000044F B902000000             	mov	ecx,2
00000454 668B1D 00000B00o       	mov	bx,EXEHandle
0000045B B43F                   	mov	ah,3fh
0000045D CD21                   	int	21h		;read the .EXE header.
0000045F 7223                   	jc	@@Reset
00000461 66C705 00000004o 07    	mov	ErrorNumber,ERR_HDRFMT	;stub file error.
         00
0000046A 6683F802               	cmp	ax,2
0000046E 7514                   	jnz	@@Reset
00000470 66C705 00000004o 1A    	mov	ErrorNumber,ERR_ALREADY3P
         00
00000479 66813D 00000B2Bo 33    	cmp	exehdr.Signature,'P3'	;Correct ID '3P'?
         50
00000482 741D                   	jz	@@Info
                                	;
00000484                        @@Reset:
00000484 668B1D 00000B00o       	mov	bx,EXEHandle
0000048B B43E                   	mov	ah,3eh
0000048D CD21                   	int	21h
0000048F 66C705 00000004o 00    	mov	ErrorNumber,0
         00
                                	;
                                	;Now do some real processing.
                                	;
00000498 E85E120000             	call	ExeAndMap2NewExe
0000049D 7573                   	jnz	System
0000049F EB30                   	jmp	@@InfoDump
                                	;
000004A1 803D 000039CCo 00      @@Info:	cmp	OptionTable+"P",0	;Post-mortem?
000004A8 7407                   	jz	@@update
000004AA E8C6000000             	call	PostMortem
000004AF EB20                   	jmp	@@InfoDump
                                	;
000004B1                        @@update:
000004B1 803D 000039D1o 00      	cmp	OptionTable+'U',0	;Update?
000004B8 7407                   	jz	@@fastload
000004BA E80C0E0000             	call	NewCauseWay
000004BF EB10                   	jmp	@@InfoDump

000004C1                        @@fastload:
000004C1 803D 000039C2o 00      	cmp	OptionTable+"F",0	;fast load?
000004C8 7407                   	jz	@@DualMode
000004CA E8A7000000             	call	FastLoad3P
000004CF EB00                   	jmp	@@InfoDump

000004D1                        @@DualMode:
                                ;	cmp	OptionTable+'D',0	; dual mode?
                                ;	jz	@@InfoDump
                                ;	call	EXEDualMode

000004D1                        @@InfoDump:
000004D1 803D 000039C5o 00      	cmp	OptionTable+'I',0	;Info?
000004D8 7438                   	jz	System
000004DA 66FF35 00000004o       	push	ErrorNumber
000004E1 E851120000             	call	NewExeInfo
000004E6 66833D 00000004o 00    	cmp	ErrorNumber,0
000004EE 7522                   	jnz	System
000004F0 668F05 00000004o       	pop	ErrorNumber
000004F7 66833D 00000004o 1A    	cmp	ErrorNumber,26
000004FF 7511                   	jnz	System
00000501 66C705 00000004o 00    	mov	ErrorNumber,0
         00
0000050A EB06                   	jmp	System

                                	;
0000050C 66B8004C               @@9:	mov	ax,4c00h
00000510 CD21                   	int	21h
00000512                        Entry	endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
00000512                        System	proc	near
                                	;
                                	;Make sure temp file is deleted.
                                	;
00000512 BA 00000B08o           	mov	edx,offset TempFileName	;get file name.
00000517 B441                   	mov	ah,41h
00000519 CD21                   	int	21h
                                	;
0000051B 66833D 00000004o 00    	cmp	ErrorNumber,0
00000523 7416                   	jz	@@NoError
00000525 66833D 00000004o 03    	cmp	ErrorNumber,3
0000052D 740C                   	jz	@@NoError
0000052F BA 000009EEo           	mov	edx,offset ErrorText
00000534 E8F52C0000             	call	StringPRint
00000539 EB0A                   	jmp	@@DoneError
0000053B                        @@NoError:	;
0000053B BA 00000ADEo           	mov	edx,offset CarriageReturn
00000540 E8E92C0000             	call	StringPrint
00000545                        @@DoneError:	;
00000545 66833D 00000004o 1A    	cmp	ErrorNumber,26
0000054D 750A                   	jnz	@@NoName
0000054F BA 00000100o           	mov	edx,offset EXEFileName
00000554 E8D52C0000             	call	StringPrint
00000559                        @@NoName:
00000559 0FB71D 00000004o       	movzx	ebx,ErrorNumber
00000560 C1E302                 	shl	ebx,2
00000563 81C3 00000006o         	add	ebx,offset ErrorMessages	;get error message.
00000569 8B13                   	mov	edx,[ebx]
0000056B B409                   	mov	ah,9
0000056D CD21                   	int	21h		;print it.
                                	;
0000056F 66B8004C               	mov	ax,4c00h
00000573 CD21                   	int	21h
00000575                        System	endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                                ;
                                ;Add post-mortem dump code and SYM file to 3P EXE.
                                ;
00000575                        PostMortem	proc	near
00000575 C3                     	ret
00000576                        PostMortem	endp


                                COMMENT !
                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                                ;
                                ;Set the EXE dual mode flag
                                ;
                                EXEDualMode	proc	near
                                	;Open the source EXE
                                	;
                                	mov	bx,EXEHandle
                                	call	CloseFile
                                	mov	edx,offset EXEFileName
                                	call	OpenFile		;Open the .EXE file.
                                	mov	ErrorNumber,6	;default to not found.
                                	jc	@@9
                                	mov	EXEHandle,ax
                                	;
                                	mov	edx,offset exehdr
                                	mov	ecx,sizeof MZHdr
                                	mov	bx,EXEHandle
                                	mov	ah,3fh
                                	int	21h		;read the .EXE header.
                                	mov	ErrorNumber,8	;default to IO error.
                                	jc	@@9
                                	mov	ErrorNumber,9	;stub file error.
                                	cmp	ax,sizeof MZHdr
                                	jnz	@@9
                                	cmp	exehdr.Signature,'ZM'	;Correct ID?
                                	jnz	@@9
                                	;
                                	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
                                	cmp	exehdr._Length,0
                                	je	medexe10	; not rounded if no modulo
                                
                                	dec	ax		;lose 1 cos its rounded up
                                
                                medexe10:
                                	add	ax,ax		;mult by 2
                                	mov	dh,0
                                	mov	dl,ah
                                	mov	ah,al
                                	mov	al,dh		;mult by 256=*512
                                	add	ax,exehdr._Length	;add length mod 512
                                	adc	dx,0		;add any carry to dx
                                	mov	cx,ax
                                	xchg	cx,dx
                                	shl	ecx,16
                                	mov	cx,dx
                                	movzx	ebx,EXEHandle
                                	xor	al,al
                                	call	LESetFilePointer	;point to 3P bit of the file.
                                	mov	P3Offset,ecx
                                	;
                                	;Read the 3P header.
                                	;
                                	mov	edx,offset RealHeader
                                	mov	ecx,size NewHeaderStruc
                                	movzx	ebx,EXEHandle
                                	call	LEReadFile
                                	jc	@@9
                                	cmp	eax,ecx
                                	jnz	@@9
                                	;
                                	call	SetSystemConfig	; update with new info
                                	;put the pointer back to the header.
                                	;
                                	mov	ecx,P3Offset
                                	xor	al,al
                                	call	LESetFilePointer
                                	;
                                	;Update the header
                                	;
                                	mov	edx,offset RealHeader
                                	mov	ecx,size NewHeaderStruc
                                	movzx	ebx,EXEHandle
                                	call	LEWriteFile
                                	jc	@@9
                                	cmp	eax,ecx
                                	jnz	@@9
                                
                                @@8:
                                	movzx	ebx,EXEHandle
                                	call	LECloseFile
                                
                                	mov	ErrorNumber,0
                                	clc
                                
                                @@9:
                                	ret
                                
                                EXEDualMode	ENDP
                                END COMMENT !

                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                                ;
                                ;Sort 3P file fixups into order and set fast load flag.
                                ;
00000576                        FastLoad3P	proc	near
                                	local @@SymbolCount:dword, @@iValue:dword, @@vValue:dword
                                	;
                                	;Open the source EXE
                                	;
0000057C 668B1D 00000B00o       	mov	bx,EXEHandle
00000583 E86B2B0000             	call	CloseFile
00000588 BA 00000100o           	mov	edx,offset EXEFileName
0000058D E8772A0000             	call	OpenFile		;Open the .EXE file.
00000592 66C705 00000004o 06    	mov	ErrorNumber,6	;default to not found.
         00
0000059B 0F82E2020000           	jc	@@9
000005A1 66A3 00000B00o         	mov	EXEHandle,ax
                                	;
000005A7 BA 00000B2Bo           	mov	edx,offset exehdr
000005AC B91B000000             	mov	ecx,sizeof MZHdr
000005B1 668B1D 00000B00o       	mov	bx,EXEHandle
000005B8 B43F                   	mov	ah,3fh
000005BA CD21                   	int	21h		;read the .EXE header.
000005BC 66C705 00000004o 08    	mov	ErrorNumber,8	;default to IO error.
         00
000005C5 0F82B8020000           	jc	@@9
000005CB 66C705 00000004o 09    	mov	ErrorNumber,9	;stub file error.
         00
000005D4 6683F81B               	cmp	ax,sizeof MZHdr
000005D8 0F85A5020000           	jnz	@@9
000005DE 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Correct ID?
         5A
000005E7 0F8596020000           	jnz	@@9
                                	;
000005ED 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
000005F3 66833D 00000B2Do 00    	cmp	exehdr._Length,0
000005FB 7402                   	je	medexe3		; not rounded if no modulo

000005FD 6648                   	dec	ax		;lose 1 cos its rounded up

000005FF                        medexe3:
000005FF 6603C0                 	add	ax,ax		;mult by 2
00000602 B600                   	mov	dh,0
00000604 8AD4                   	mov	dl,ah
00000606 8AE0                   	mov	ah,al
00000608 8AC6                   	mov	al,dh		;mult by 256=*512
0000060A 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
00000611 6683D200               	adc	dx,0		;add any carry to dx
00000615 668BC8                 	mov	cx,ax
00000618 6687CA                 	xchg	cx,dx
0000061B C1E110                 	shl	ecx,16
0000061E 668BCA                 	mov	cx,dx
00000621 0FB71D 00000B00o       	movzx	ebx,EXEHandle
00000628 32C0                   	xor	al,al
0000062A E85B0C0000             	call	LESetFilePointer	;point to 3P bit of the file.
0000062F 890D 00003976o         	mov	P3Offset,ecx
                                	;
                                	;Read the 3P header.
                                	;
00000635 BA 00003926o           	mov	edx,offset RealHeader
0000063A B940000000             	mov	ecx,size NewHeaderStruc
0000063F 0FB71D 00000B00o       	movzx	ebx,EXEHandle
00000646 E80A0C0000             	call	LEReadFile
0000064B 0F8232020000           	jc	@@9
00000651 3BC1                   	cmp	eax,ecx
00000653 0F852A020000           	jnz	@@9
                                	;
                                	;Check it is a 3P section.
                                	;
00000659 66813D 00003926o 33    	cmp	word ptr[RealHeader.NewID],"P3"
         50
00000662 0F851B020000           	jnz	@@9
                                	;
                                	;Get some memory for the relocation table.
                                	;
00000668 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
0000066E 83F902                 	cmp	ecx,1+1
00000671 0F82F6010000           	jc	@@8
00000677 C1E102                 	shl	ecx,2
0000067A E8C60B0000             	call	LEMalloc
0000067F 0F82FE010000           	jc	@@9
00000685 8935 0000396Eo         	mov	RelocMem,esi
0000068B E8B50B0000             	call	LEMalloc
00000690 0F82ED010000           	jc	@@9
00000696 8935 00003972o         	mov	RelocMem+4,esi
                                	;
                                	;Move to the relocations.
                                	;
0000069C 0FB70D 00003934o       	movzx	ecx,[RealHeader.NewSegments]
000006A3 C1E103                 	shl	ecx,3
000006A6 B001                   	mov	al,1
000006A8 0FB71D 00000B00o       	movzx	ebx,EXEHandle
000006AF E8D60B0000             	call	LESetFilePointer
                                	;
                                	;Read the relocations.
                                	;
000006B4 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
000006BA C1E102                 	shl	ecx,2
000006BD 8B15 0000396Eo         	mov	edx,RelocMem
000006C3 0FB71D 00000B00o       	movzx	ebx,EXEHandle
000006CA E8860B0000             	call	LEReadFile
000006CF 0F82AE010000           	jc	@@9
000006D5 3BC1                   	cmp	eax,ecx
000006D7 0F85A6010000           	jnz	@@9

                                	;
                                	;Make the table.
                                	;
000006DD 8B3D 00003972o         	mov	edi,RelocMem+4
000006E3 A1 0000396Eo           	mov	eax,RelocMem
000006E8 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
000006EE 1E                     	push	ds
000006EF 07                     	pop	es
000006F0 FC                     	cld
000006F1                        @@00:
000006F1 AB                     	stosd
000006F2 83C004                 	add	eax,4
000006F5 49                     	dec	ecx
000006F6 75F9                   	jnz	@@00


                                ;
                                ;Thingy sort the relocation pointers.
                                ;
000006F8 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
000006FE 894DFC                 	mov	@@SymbolCount,ecx
                                	;
                                	;Now do the sort.
                                	;
00000701 8B45FC                 	mov	eax,@@SymbolCount
00000704 83F801                 	cmp	eax,1
00000707 0F86CD000000           	jbe	@@sortend		; sorted by definition
0000070D 33DB                   	xor	ebx,ebx
0000070F 8BD3                   	mov	edx,ebx
00000711 B309                   	mov	bl,9
00000713 F7F3                   	div	ebx
00000715 8BC8                   	mov	ecx,eax		; ecx == quotient, N/9
                                ;
                                ; for (h=1;h<=N/9;h=3*h+1);
                                ;
00000717 8BC3                   	mov	eax,ebx		; eax==9
00000719 B001                   	mov	al,1		; eax==1, h
0000071B B303                   	mov	bl,3		; ebx==3
0000071D 33D2                   	xor	edx,edx		; zero for multiply loop
0000071F                        @@sethloop:	;
0000071F 3BC1                   	cmp	eax,ecx		; h<=N/9
00000721 7705                   	ja	@@sort2
00000723 F7E3                   	mul	ebx		; 3*h, assume 32-bit result (pretty safe bet)
00000725 40                     	inc	eax		; 3*h+1
00000726 EBF7                   	jmp	@@sethloop
                                ;
                                ; ebx will play role of j, edx will play role of h
                                ;
00000728 8BD0                   @@sort2:	mov	edx,eax		; edx == h
                                ;
                                ; for (;h>0;...
                                ;
0000072A                        @@hloop:
0000072A 0BD2                   	or	edx,edx		; h>0
0000072C 0F84A8000000           	je	@@sortend
                                ;
                                ; for(i=h+1...
                                ;
00000732 8BC2                   	mov	eax,edx
00000734 40                     	inc	eax
00000735 8945F8                 	mov	@@iValue,eax
                                ;
                                ; for(...;i<=N;...){
                                ;
00000738 8B45F8                 @@iloop:	mov	eax,@@iValue
0000073B 3B45FC                 	cmp	eax,@@SymbolCount
0000073E 0F8785000000           	ja	@@nexth
                                	;
00000744 8B0D 00003972o         	mov	ecx,RelocMem+4
0000074A 8B4C81FC               	mov	ecx,[ecx-4+eax*4]
0000074E 894DF4                 	mov	@@vValue,ecx		; v=a[i]
00000751 8BD8                   	mov	ebx,eax		; j=i
                                ;
                                ; while(j>h && a[j-h]>v){
                                ;
00000753                        @@whileloop:
00000753 3BDA                   	cmp	ebx,edx		; j>h
00000755 7655                   	jbe	@@whilefail
                                	;
00000757 8BC3                   	mov	eax,ebx
00000759 2BC2                   	sub	eax,edx		; eax==j-h
0000075B 8B35 00003972o         	mov	esi,RelocMem+4
00000761 8B7486FC               	mov	esi,[esi-4+eax*4]	; esi==a[j-h]
00000765 8B7DF4                 	mov	edi,@@vValue		; edi==v
00000768 33C9                   	xor	ecx,ecx		; zero high bytes of register for following repe
                                ;
                                ; a[j-h] > v
                                ;
                                	pushm	esi,edi
                             1  	IRP	X,<esi,edi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000076A 56                  2  	PUSH	esi			;SAVE THE REGISTER
0000076B 57                  2  	PUSH	edi			;SAVE THE REGISTER
0000076C 8B36                   	mov	esi,[esi]
0000076E 8B3F                   	mov	edi,[edi]
00000770 81E6FFFFFF0F           	and	esi,0FFFFFFFh
00000776 81E7FFFFFF0F           	and	edi,0FFFFFFFh
0000077C 3BF7                   	cmp	esi,edi
                                	popm	esi,edi
                             1  	IRP	X,<,,,,,,,,edi,esi> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000077E 5F                  2  	POP	edi				;POP THE REGISTER
0000077F 5E                  2  	POP	esi				;POP THE REGISTER
00000780 762A                   	jbe	@@whilefail		; first < second, a[j-h]<v

00000782                        @@dochange:	;
00000782 8BC3                   	mov	eax,ebx
00000784 2BC2                   	sub	eax,edx		; eax==j-h
00000786 8D048500000000         	lea	eax,[eax*4]
0000078D 0305 00003972o         	add	eax,RelocMem+4
00000793 8B40FC                 	mov	eax,[eax-4]		; eax==a[j-h]
00000796 53                     	push	ebx
00000797 8D1C9D00000000         	lea	ebx,[ebx*4]
0000079E 031D 00003972o         	add	ebx,RelocMem+4
000007A4 8943FC                 	mov	[ebx-4],eax		; a[j]=a[j-h]
000007A7 5B                     	pop	ebx
000007A8 2BDA                   	sub	ebx,edx		; j-=h
000007AA EBA7                   	jmp	@@whileloop
000007AC                        @@whilefail:	;
000007AC 8B45F4                 	mov	eax,@@vValue
000007AF 53                     	push	ebx
000007B0 8D1C9D00000000         	lea	ebx,[ebx*4]
000007B7 031D 00003972o         	add	ebx,RelocMem+4
000007BD 8943FC                 	mov	[ebx-4],eax		; a[j]=v
000007C0 5B                     	pop	ebx
                                ;
                                ; for(...;i++){
                                ;
000007C1 FF45F8                 	inc	@@iValue
000007C4 E96FFFFFFF             	jmp	@@iloop
                                ;
                                ; for (...;h/=3){
                                ;
000007C9 8BC2                   @@nexth:	mov	eax,edx
000007CB 33D2                   	xor	edx,edx
000007CD 8BCA                   	mov	ecx,edx
000007CF B103                   	mov	cl,3
000007D1 F7F1                   	div	ecx
000007D3 8BD0                   	mov	edx,eax
000007D5 E950FFFFFF             	jmp	@@hloop
000007DA                        @@sortend:	;


                                ;
                                ;Use list to order output.
                                ;
000007DA 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
000007E0 8B3D 00003972o         	mov	edi,RelocMem+4
000007E6                        @@01:
000007E6 8B37                   	mov	esi,[edi]
000007E8 A5                     	movsd
000007E9 49                     	dec	ecx
000007EA 75FA                   	jnz	@@01

                                ;
                                ;Copy second table back to first.
                                ;
000007EC 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
000007F2 8B35 00003972o         	mov	esi,RelocMem+4
000007F8 8B3D 0000396Eo         	mov	edi,RelocMem
000007FE F3A5                   	rep	movsd


                                ;
                                ;Set speed load flag in the header.
                                ;
00000800 810D 00003946o 00      	or	dword ptr[RealHeader.NewFlags],1 shl 30
         000040

                                	;
                                	;Put the pointer back to start of relocations.
                                	;
0000080A 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
00000810 C1E102                 	shl	ecx,2
00000813 F7D9                   	neg	ecx
00000815 B001                   	mov	al,1
00000817 0FB71D 00000B00o       	movzx	ebx,EXEHandle
0000081E E8670A0000             	call	LESetFilePointer
                                	;
                                	;Write new relocations.
                                	;
00000823 8B0D 00003936o         	mov	ecx,dword ptr[RealHeader.NewRelocs]
00000829 C1E102                 	shl	ecx,2
0000082C 8B15 0000396Eo         	mov	edx,RelocMem
00000832 0FB71D 00000B00o       	movzx	ebx,EXEHandle
00000839 E8B7090000             	call	LEWriteFile
0000083E 7243                   	jc	@@9
00000840 3BC1                   	cmp	eax,ecx
00000842 753F                   	jnz	@@9

                                	;
                                	;put the pointer back to the header.
                                	;
00000844 8B0D 00003976o         	mov	ecx,P3Offset
0000084A 32C0                   	xor	al,al
0000084C E8390A0000             	call	LESetFilePointer
                                	;
                                	;Update the header
                                	;
00000851 BA 00003926o           	mov	edx,offset RealHeader
00000856 B940000000             	mov	ecx,size NewHeaderStruc
0000085B 0FB71D 00000B00o       	movzx	ebx,EXEHandle
00000862 E88E090000             	call	LEWriteFile
00000867 721A                   	jc	@@9
00000869 3BC1                   	cmp	eax,ecx
0000086B 7516                   	jnz	@@9


0000086D 0FB71D 00000B00o       @@8:	movzx	ebx,EXEHandle
00000874 E8C5090000             	call	LECloseFile

00000879 66C705 00000004o 00    	mov	ErrorNumber,0
         00
00000882 F8                     	clc


                                @@9:	ret
00000885                        FastLoad3P	endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                                ;
                                ;Convert an LE format file into 3P format.
                                ;
00000885                        LEProcess	proc	near
00000885 E872080000             	call	FetchLEFile		;Read the LE file.
0000088A 7226                   	jc	@@9
0000088C E8D9060000             	call	Create3PFile		;Create the 3P image.
00000891 721F                   	jc	@@9
00000893 E8E5020000             	call	CreateRelocations	;Build relocation list.
00000898 7218                   	jc	@@9
0000089A E85A020000             	call	Create3PHeader	;Build the header.
0000089F 7211                   	jc	@@9
000008A1 E80D000000             	call	Write3PFile		;Now write the 3P file.
000008A6 720A                   	jc	@@9
000008A8 66C705 00000004o 00    	mov	ErrorNumber,0
         00
000008B1 F8                     	clc
000008B2 C3                     @@9:	ret
000008B3                        LEProcess	endp


                                ;------------------------------------------------------------------------------
                                ;
                                ;Write the file at last.
                                ;
000008B3                        Write3PFile	proc	near
000008B3 BE 000038EAo           	mov	esi,offset Write3PText
000008B8 E8FA090000             	call	LEPrintString
                                	;
                                	;Load the extender stub CWSTUB.EXE
                                	;
000008BD BA 00000080o           	mov	edx,offset SHELLFileName	; get extender stub CWSTUB.EXE
                                	@dprintf 1,<"Write3PFile: open stub %s",10>,edx
                             1    for x,<,,,,edx>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000008C2 52                  2  	push edx
000008C3 E89AF7FFFF          1  	call dprintf
000008C8 577269746533504669  1  	db "Write3PFile: open stub %s",10,0
000008E3 E8BA090000             	call	LEOpenFile
000008E8 66C705 00000004o 2A    	mov	ErrorNumber,42              ;open error
         00
000008F1 0F8200020000           	jc	@@9
000008F7 BA 00000B2Bo           	mov	edx,offset exehdr
000008FC B91B000000             	mov	ecx,sizeof MZHdr
                                	@dprintf 1,<"Write3PFile: read header",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00000901 E85CF7FFFF          1  	call dprintf
00000906 577269746533504669  1  	db "Write3PFile: read header",10,0
00000920 E830090000             	call	LEReadFile
00000925 0F82CC010000           	jc	@@9
0000092B 3BC1                   	cmp	eax,ecx
0000092D 0F85C4010000           	jnz	@@9
00000933 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
00000939 66833D 00000B2Do 00    	cmp	exehdr._Length,0
00000941 7402                   	je	medexe4		; not rounded if no modulo

00000943 6648                   	dec	ax		;lose 1 cos its rounded up

00000945                        medexe4:
00000945 6603C0                 	add	ax,ax		;mult by 2
00000948 B600                   	mov	dh,0
0000094A 8AD4                   	mov	dl,ah
0000094C 8AE0                   	mov	ah,al
0000094E 8AC6                   	mov	al,dh		;mult by 256=*512
00000950 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
00000957 6683D200               	adc	dx,0		;add any carry to dx
0000095B 668BC8                 	mov	cx,ax
0000095E 6687CA                 	xchg	cx,dx
00000961 C1E110                 	shl	ecx,16
00000964 668BCA                 	mov	cx,dx
00000967 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000970 83C104                 	add	ecx,4
00000973 E8CD080000             	call	LEMalloc
00000978 0F8279010000           	jc	@@9
0000097E 83E904                 	sub	ecx,4
00000981 8935 00003966o         	mov	StubMem,esi
00000987 890E                   	mov	dword ptr[esi],ecx
00000989 83C604                 	add	esi,4
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000098C 51                  2  	PUSH	ecx			;SAVE THE REGISTER
0000098D 56                  2  	PUSH	esi			;SAVE THE REGISTER
0000098E 33C9                   	xor	ecx,ecx
00000990 32C0                   	xor	al,al
00000992 E8F3080000             	call	LESetFilePointer
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00000997 5E                  2  	POP	esi				;POP THE REGISTER
00000998 59                  2  	POP	ecx				;POP THE REGISTER
00000999 66C705 00000004o 2A    	mov	ErrorNumber,42
         00
000009A2 8BD6                   	mov	edx,esi
000009A4 E8AC080000             	call	LEReadFile
000009A9 0F8248010000           	jc	@@9
000009AF 3BC1                   	cmp	eax,ecx
000009B1 0F8540010000           	jnz	@@9
                                	;
                                	;Create the output file.
                                	;
000009B7 BA 00000B08o           	mov	edx,offset TEMPFileName
                                	@dprintf 1,<"Write3PFile: create temp file %s",10>,edx
                             1    for x,<,,,,edx>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000009BC 52                  2  	push edx
000009BD E8A0F6FFFF          1  	call dprintf
000009C2 577269746533504669  1  	db "Write3PFile: create temp file %s",10,0
000009E4 E8F4070000             	call	LECreateFile
000009E9 66C705 00000004o 25    	mov	ErrorNumber,37
         00
000009F2 0F82FF000000           	jc	@@9
                                	;
                                	;Write the stub.
                                	;
000009F8 66C705 00000004o 26    	mov	ErrorNumber,38
         00
00000A01 8B15 00003966o         	mov	edx,StubMem
00000A07 8B0A                   	mov	ecx,[edx]
00000A09 83C204                 	add	edx,4
00000A0C E8E4070000             	call	LEWriteFile
00000A11 0F82E0000000           	jc	@@9
00000A17 3BC1                   	cmp	eax,ecx
00000A19 0F85D8000000           	jnz	@@9
                                	;
                                	;Write the main header.
                                	;
00000A1F BA 00003926o           	mov	edx,offset RealHeader
00000A24 B940000000             	mov	ecx,size NewHeaderStruc
00000A29 E8C7070000             	call	LEWriteFile
00000A2E 66C705 00000004o 26    	mov	ErrorNumber,38
         00
00000A37 0F82BA000000           	jc	@@9
00000A3D 3BC1                   	cmp	eax,ecx
00000A3F 0F85B2000000           	jnz	@@9
                                	;
                                	;Write the segment definitions.
                                	;
00000A45 8B35 00003912o         	mov	esi,ObjectList	;Point to the segment list.
00000A4B 8B2E                   	mov	ebp,[esi]		;Get number of entries.
00000A4D 83C604                 	add	esi,4
00000A50                        @@0:
00000A50 8BD6                   	mov	edx,esi		;Point to segment defintion.
00000A52 B908000000             	mov	ecx,4+4
00000A57 E899070000             	call	LEWriteFile		;Write this entry.
00000A5C 66C705 00000004o 26    	mov	ErrorNumber,38
         00
00000A65 0F828C000000           	jc	@@9
00000A6B 3BC1                   	cmp	eax,ecx
00000A6D 0F8584000000           	jnz	@@9
00000A73 83C610                 	add	esi,size _Seg_	;Next entry.
00000A76 4D                     	dec	ebp
00000A77 75D7                   	jnz	@@0		;Do all segments.
                                	;
                                	;Write the relocation entries.
                                	;
00000A79 8B35 00003916o         	mov	esi,RelocationList
00000A7F 0BF6                   	or	esi,esi
00000A81 741E                   	jz	@@1
00000A83 8B0E                   	mov	ecx,[esi]		;Get number of entries.
00000A85 C1E102                 	shl	ecx,2		;Dword per entry.
00000A88 83C604                 	add	esi,4
00000A8B 8BD6                   	mov	edx,esi		;Point to data.
00000A8D E863070000             	call	LEWriteFile
00000A92 66C705 00000004o 26    	mov	ErrorNumber,38
         00
00000A9B 725A                   	jc	@@9
00000A9D 3BC1                   	cmp	eax,ecx
00000A9F 7556                   	jnz	@@9
                                	;
00000AA1                        @@1:	;Write the EXE image.
                                	;
00000AA1 8B35 00003912o         	mov	esi,ObjectList	;Point to object definitions.
00000AA7 8B2E                   	mov	ebp,[esi]		;Get number of entries.
00000AA9 83C604                 	add	esi,4		;Point to real data.
00000AAC                        @@2:
00000AAC 8B4E08                 	mov	ecx,_Seg_.Seg_Length[esi]	;Get segments length.
00000AAF 8B560C                 	mov	edx,[esi]._Seg_.Seg_Memory	;point to segments image.
00000AB2 E83E070000             	call	LEWriteFile
00000AB7 66C705 00000004o 26    	mov	ErrorNumber,38
         00
00000AC0 7235                   	jc	@@9
00000AC2 3BC1                   	cmp	eax,ecx
00000AC4 7531                   	jnz	@@9
00000AC6 83C610                 	add	esi,size _Seg_	;point to next entry.
00000AC9 4D                     	dec	ebp
00000ACA 75E0                   	jnz	@@2		;Do all entries.
                                	;
                                	;Close the output file.
                                	;
00000ACC E86D070000             	call	LECloseFile
                                	;
                                	;Delete origional .EXE
                                	;
00000AD1 BA 00000100o           	mov	edx,offset EXEFileName	;get file name mask.
00000AD6 B441                   	mov	ah,41h
00000AD8 CD21                   	int	21h
00000ADA 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00000AE3 7212                   	jc	@@9
                                	;
                                	;now rename it.
                                	;
00000AE5 BA 00000B08o           	mov	edx,offset TempFileName
00000AEA BF 00000100o           	mov	edi,offset EXEFileName		;get file name mask.
00000AEF B456                   	mov	ah,56h
00000AF1 CD21                   	int	21h
00000AF3 7202                   	jc	@@9
                                	;
00000AF5 F8                     	clc
00000AF6 C3                     	ret
                                	;
00000AF7 F9                     @@9:	stc
00000AF8 C3                     	ret
00000AF9                        Write3PFile	endp


                                ;------------------------------------------------------------------------------
                                ;
                                ;Create 3P header data.
                                ;
00000AF9                        Create3PHeader	proc	near
00000AF9 BE 000038CDo           	mov	esi,offset BuildHeaderText
00000AFE E8B4070000             	call	LEPrintString
                                	;
00000B03 BF 00003926o           	mov	edi,offset RealHeader
                                	;
                                	;Set auto DS object number if there is one.
                                	;
00000B08 8B35 000038FEo         	mov	esi,LEAddress
00000B0E 8B8694000000           	mov	eax,[esi+94h]
00000B14 66894728               	mov	[edi].NewHeaderStruc.NewAutoDS,ax
                                	;
                                	;Set number of segments and increase file length field.
                                	;
00000B18 8B35 00003912o         	mov	esi,ObjectList
00000B1E 8B06                   	mov	eax,[esi]		;Get number of segments.
00000B20 6689470E               	mov	[edi].NewHeaderStruc.NewSegments,ax
00000B24 C1E003                 	shl	eax,3		;8 bytes per seg.
00000B27 894702                 	mov	[edi].NewHeaderStruc.NewSize,eax
                                	;
                                	;Set number of relocations and increase file length field.
                                	;
00000B2A 8B35 00003916o         	mov	esi,RelocationList
00000B30 33C0                   	xor	eax,eax
00000B32 0BF6                   	or	esi,esi
00000B34 7402                   	jz	@@0
00000B36 8B06                   	mov	eax,[esi]
00000B38                        @@0:
00000B38 894710                 	mov	[edi].NewHeaderStruc.NewRelocs,eax
00000B3B C1E002                 	shl	eax,2		;4 bytes per entry.
00000B3E 014702                 	add	[edi].NewHeaderStruc.NewSize,eax
                                	;
                                	;Set EXE image length and increase file length field.
                                	;
00000B41 A1 0000391Ao           	mov	eax,SegmentBase	;This is now total length.
00000B46 894706                 	mov	[edi].NewHeaderStruc.NewLength,eax
00000B49 89470A                 	mov	[edi].NewHeaderStruc.NewAlloc,eax
00000B4C 014702                 	add	[edi].NewHeaderStruc.NewSize,eax
                                	;
                                	;Include header in length field.
                                	;
00000B4F 83470240               	add	[edi].NewHeaderStruc.NewSize,size NewHeaderStruc
                                	;
                                	;Set entry CS:EIP
                                	;
00000B53 8B35 000038FEo         	mov	esi,LEAddress
00000B59 8B4618                 	mov	eax,[esi+18h]	;CS object number.
00000B5C 48                     	dec	eax
00000B5D 66894718               	mov	[edi].NewHeaderStruc.NewEntryCS,ax
00000B61 8B461C                 	mov	eax,[esi+1Ch]	;EIP value.
00000B64 894714                 	mov	[edi].NewHeaderStruc.NewEntryEIP,eax
                                	;
                                	;Set entry SS:ESP
                                	;
00000B67 8B35 000038FEo         	mov	esi,LEAddress
00000B6D 8B4620                 	mov	eax,[esi+20h]	;SS object number.
00000B70 48                     	dec	eax
00000B71 6689471E               	mov	[edi].NewHeaderStruc.NewEntrySS,ax
00000B75 8B4624                 	mov	eax,[esi+24h]	;ESP value.
00000B78 89471A                 	mov	[edi].NewHeaderStruc.NewEntryESP,eax
                                	;
00000B7B F8                     	clc
00000B7C C3                     	ret
00000B7D                        Create3PHeader	endp


                                ;------------------------------------------------------------------------------
                                ;
                                ;Create a 3P format relocation table from the LE fixup tables.
                                ;
00000B7D                        CreateRelocations proc near
                                	@dprintf 1,<"CreateRelocations enter",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00000B7D E8E0F4FFFF          1  	call dprintf
00000B82 43726561746552656C  1  	db "CreateRelocations enter",10,0
00000B9B BE 000038B0o           	mov	esi,offset BuildRelocsText
00000BA0 E812070000             	call	LEPrintString
                                	;
                                	;Setup a pointer to the object definitions.
                                	;
00000BA5 C705 0000396Ao 00      	mov	RelocationCount,0
         000000
                                	;
00000BAF 8B35 000038FEo         	mov	esi,LEAddress
00000BB5 8B4E44                 	mov	ecx,[esi+44h]	;Get number of Objects.
00000BB8 037640                 	add	esi,[esi+40h]	;Point to object table.
00000BBB 890D 0000390Ao         	mov	ObjectCount,ecx
00000BC1 8935 0000390Eo         	mov	ObjectBase,esi
00000BC7 A1 00003912o           	mov	eax,ObjectList
00000BCC 83C004                 	add	eax,4
00000BCF A3 00000B17o           	mov	SegmentList,eax
                                	;
00000BD4                        @@0:
00000BD4 8B35 0000390Eo         	mov	esi,ObjectBase
00000BDA 8B4E10                 	mov	ecx,[esi+10h]	;Get number of pages.
00000BDD 890D 0000391Eo         	mov	PageCount,ecx
00000BE3 C705 00003922o 00      	mov	PageCount+4,0
         000000
00000BED 8B560C                 	mov	edx,[esi+0Ch]	;Get page table index.
00000BF0 4A                     	dec	edx
00000BF1 8BEA                   	mov	ebp,edx		;Set base page map entry.
00000BF3                        @@1:	;
00000BF3 8BD5                   	mov	edx,ebp
00000BF5 8B35 000038FEo         	mov	esi,LEAddress
00000BFB 037668                 	add	esi,[esi+68h]	;Point to fixup page maps.
00000BFE 8B4C9604               	mov	ecx,[esi+4+edx*4]	;Get next offset.
00000C02 8B1496                 	mov	edx,[esi+edx*4]	;Get start offset.
00000C05 2BCA                   	sub	ecx,edx		;Get number of bytes
00000C07 0F84DF020000           	jz	@@4
                                	;
00000C0D 8B35 000038FEo         	mov	esi,LEAddress
00000C13 03766C                 	add	esi,[esi+6Ch]	;Point to fixup data.
00000C16 03F2                   	add	esi,edx		;Move to start of this pages fixups.
                                	;
00000C18                        @@2:
00000C18 8A06                   	mov	al,[esi]		;Get type byte.
00000C1A 8AD8                   	mov	bl,al
00000C1C C0EB04                 	shr	bl,4		;Get single/multiple flag.
00000C1F 8AF8                   	mov	bh,al
00000C21 80E70F                 	and	bh,15		;Get type.
00000C24 46                     	inc	esi
00000C25 49                     	dec	ecx
00000C26 8A06                   	mov	al,[esi]		;Get second type byte.
00000C28 8AD0                   	mov	dl,al
00000C2A 80E203                 	and	dl,3		;Get internal/external specifier.
00000C2D 8AF0                   	mov	dh,al
00000C2F C0EE02                 	shr	dh,2		;Get destination type.
00000C32 46                     	inc	esi
00000C33 49                     	dec	ecx
                                	;
00000C34 66C705 00000004o 27    	mov	ErrorNumber,39
         00
00000C3D 0ADB                   	or	bl,bl		;Check it's a single entry.
00000C3F 0F85D6020000           	jnz	@@9
                                	;
00000C45 66C705 00000004o 28    	mov	ErrorNumber,40
         00
00000C4E 0AD2                   	or	dl,dl		;Check it's an internal target.
00000C50 0F85C5020000           	jnz	@@9
                                	;
00000C56 66C705 00000004o 2B    	mov	ErrorNumber,43
         00
00000C5F F6C63B                 	test	dh,111011b		;Check for un-known bits.
00000C62 0F85B3020000           	jnz	@@9
                                	;
00000C68 80FF02                 	cmp	bh,0010b		;Word segment?
00000C6B 7429                   	jz	@@Seg16
00000C6D 80FF07                 	cmp	bh,0111b		;32-bit offset?
00000C70 0F848E000000           	jz	@@32BitOff
00000C76 80FF06                 	cmp	bh,0110b		;Seg:32-bit offset?
00000C79 0F8482010000           	jz	@@Seg1632BitOff
00000C7F 80FF08                 	cmp	bh,1000b		;32-bit self relative?
00000C82 0F840D010000           	jz	@@Self32Off
                                	;
00000C88 66C705 00000004o 29    	mov	ErrorNumber,41
         00
00000C91 E985020000             	jmp	@@9
                                	;
00000C96                        @@Seg16:	;Deal with a 16-bit segment.
                                	;
                                	;EBP	- Page offset within segment.
                                	;w[esi] - offset within page.
                                	;b[esi+2] - target object+1.
                                	;
00000C96 66C705 00000004o 2B    	mov	ErrorNumber,43
         00
00000C9F F6C604                 	test	dh,4
00000CA2 0F8573020000           	jnz	@@9
                                	;
00000CA8 8B3D 00000B17o         	mov	edi,SegmentList
00000CAE 8B7F0C                 	mov	edi,[edi]._Seg_.Seg_Memory
00000CB1 A1 00003922o           	mov	eax,PageCount+4	;Get page number.
00000CB6 C1E00C                 	shl	eax,12
00000CB9 03F8                   	add	edi,eax		;Point to the right page.
00000CBB 0FBF06                 	movsx	eax,word ptr[esi]
00000CBE 0BC0                   	or	eax,eax
00000CC0 7837                   	js	@@Neg0
00000CC2 03F8                   	add	edi,eax		;Point to the right offset.
00000CC4 0FB64602               	movzx	eax,byte ptr[esi+2]		;Get the target segment.
00000CC8 48                     	dec	eax
00000CC9 668907                 	mov	[edi],ax		;Store target.
                                	;
00000CCC 8B3D 00000B17o         	mov	edi,SegmentList
00000CD2 8B3F                   	mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
00000CD4 A1 00003922o           	mov	eax,PageCount+4	;Get page number within segment.
00000CD9 C1E00C                 	shl	eax,12
00000CDC 03F8                   	add	edi,eax		;Include page offset.
00000CDE 0FB706                 	movzx	eax,word ptr[esi]
00000CE1 03F8                   	add	edi,eax		;Include byte offset.
00000CE3 8BC7                   	mov	eax,edi
00000CE5 E833020000             	call	AddRelocationEntry	;Add it to the list.
00000CEA 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000CF3 0F8222020000           	jc	@@9
                                	;
00000CF9                        @@Neg0:
00000CF9 83C603                 	add	esi,2+1
00000CFC 83E903                 	sub	ecx,2+1
00000CFF E9DA010000             	jmp	@@3
                                	;
00000D04                        @@32BitOff:	;Deal with a 32-bit offset.
                                	;
                                	;EBP	- Page offset within segment.
                                	;w[esi] - offset within page.
                                	;b[esi+2] - target object+1
                                	;w[esi+3] - target offset.
                                	;
00000D04 8B3D 00000B17o         	mov	edi,SegmentList
00000D0A 8B7F0C                 	mov	edi,[edi]._Seg_.Seg_Memory
00000D0D A1 00003922o           	mov	eax,PageCount+4	;Get page number.
00000D12 C1E00C                 	shl	eax,12
00000D15 03F8                   	add	edi,eax		;Point to the right page.
00000D17 0FBF06                 	movsx	eax,word ptr[esi]
00000D1A 0BC0                   	or	eax,eax
00000D1C 785D                   	js	@@Neg1
00000D1E 03F8                   	add	edi,eax		;Point to the right offset.
00000D20 0FB64602               	movzx	eax,byte ptr[esi+2]		;Get the target segment.
00000D24 48                     	dec	eax
00000D25 52                     	push	edx
00000D26 BA10000000             	mov	edx,size _Seg_
00000D2B F7E2                   	mul	edx
00000D2D 5A                     	pop	edx
00000D2E 83C004                 	add	eax,4		;skip dword count.
00000D31 0305 00003912o         	add	eax,ObjectList	;point to target segment details.
00000D37 8B00                   	mov	eax,[eax]._Seg_.Seg_BaseAddress	;Get target segments offset from start of image.
00000D39 0FB75E03               	movzx	ebx,word ptr[esi+3]		;Get target offset.
00000D3D F6C604                 	test	dh,4
00000D40 7403                   	jz	@@Big0
00000D42 8B5E03                 	mov	ebx,[esi+3]		;Get target offset.
00000D45                        @@Big0:
00000D45 03C3                   	add	eax,ebx
00000D47 8907                   	mov	[edi],eax
                                	;
00000D49 8B3D 00000B17o         	mov	edi,SegmentList
00000D4F 8B3F                   	mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
00000D51 A1 00003922o           	mov	eax,PageCount+4	;Get page number within segment.
00000D56 C1E00C                 	shl	eax,12
00000D59 03F8                   	add	edi,eax		;Include page offset.
00000D5B 0FB706                 	movzx	eax,word ptr[esi]
00000D5E 03F8                   	add	edi,eax		;Include byte offset.
00000D60 8BC7                   	mov	eax,edi
00000D62 0D00000010             	or	eax,1 shl 28		;Mark it as a 32-bit offset.
00000D67 E8B1010000             	call	AddRelocationEntry	;Add it to the list.
00000D6C 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000D75 0F82A0010000           	jc	@@9
                                	;
00000D7B 83C605                 @@Neg1:	add	esi,2+1+2
00000D7E 83E905                 	sub	ecx,2+1+2
00000D81 F6C604                 	test	dh,4
00000D84 0F8454010000           	jz	@@3
00000D8A 83C602                 	add	esi,2
00000D8D 83E902                 	sub	ecx,2
00000D90 E949010000             	jmp	@@3

                                	;
00000D95                        @@Self32Off:	;Deal with a 32-bit self relative offset.
                                	;
                                	;EBP	- Page offset within segment.
                                	;w[esi] - offset within page.
                                	;b[esi+2] - target object+1
                                	;w[esi+3] - target offset.
                                	;
00000D95 8B3D 00000B17o         	mov	edi,SegmentList
00000D9B 8B1F                   	mov	ebx,[edi]._Seg_.Seg_BaseAddress
00000D9D 8B7F0C                 	mov	edi,[edi]._Seg_.Seg_Memory
00000DA0 A1 00003922o           	mov	eax,PageCount+4	;Get page number.
00000DA5 C1E00C                 	shl	eax,12
00000DA8 03D8                   	add	ebx,eax
00000DAA 03F8                   	add	edi,eax		;Point to the right page.
00000DAC 0FBF06                 	movsx	eax,word ptr[esi]
00000DAF 0BC0                   	or	eax,eax
00000DB1 7834                   	js	@@sfNeg1
00000DB3 03D8                   	add	ebx,eax
00000DB5 03F8                   	add	edi,eax		;Point to the right offset.
00000DB7 0FB64602               	movzx	eax,byte ptr[esi+2]		;Get the target segment.
00000DBB 48                     	dec	eax
00000DBC 52                     	push	edx
00000DBD BA10000000             	mov	edx,size _Seg_
00000DC2 F7E2                   	mul	edx
00000DC4 5A                     	pop	edx
00000DC5 83C004                 	add	eax,4		;skip dword count.
00000DC8 0305 00003912o         	add	eax,ObjectList	;point to target segment details.
00000DCE 8B00                   	mov	eax,[eax]._Seg_.Seg_BaseAddress	;Get target segments offset from start of image.
00000DD0 53                     	push	ebx
00000DD1 0FB75E03               	movzx	ebx,word ptr[esi+3]		;Get target offset.
00000DD5 F6C604                 	test	dh,4
00000DD8 7403                   	jz	@@sfBig0
00000DDA 8B5E03                 	mov	ebx,[esi+3]		;Get target offset.
00000DDD                        @@sfBig0:
00000DDD 03C3                   	add	eax,ebx
00000DDF 5B                     	pop	ebx
00000DE0 83C304                 	add	ebx,4
00000DE3 2BC3                   	sub	eax,ebx
00000DE5 8907                   	mov	[edi],eax
                                	;
00000DE7                        @@sfNeg1:
00000DE7 83C605                 	add	esi,2+1+2
00000DEA 83E905                 	sub	ecx,2+1+2
00000DED F6C604                 	test	dh,4
00000DF0 0F84E8000000           	jz	@@3
00000DF6 83C602                 	add	esi,2
00000DF9 83E902                 	sub	ecx,2
00000DFC E9DD000000             	jmp	@@3

                                	;
00000E01                        @@Seg1632BitOff: ;Deal with an FWORD fixup by splitting into a seg16 and 32-bit
                                	;offset relocation entry.
                                	;
                                	;EBP	- Page offset within segment.
                                	;w[esi] - offset within page.
                                	;b[esi+2] - target object+1
                                	;w[esi+3] - target offset.
                                	;
00000E01 8B3D 00000B17o         	mov	edi,SegmentList
00000E07 8B7F0C                 	mov	edi,[edi]._Seg_.Seg_Memory
00000E0A A1 00003922o           	mov	eax,PageCount+4	;Get page number.
00000E0F C1E00C                 	shl	eax,12
00000E12 03F8                   	add	edi,eax		;Point to the right page.
00000E14 0FBF06                 	movsx	eax,word ptr[esi]
00000E17 0BC0                   	or	eax,eax
00000E19 0F88AC000000           	js	@@Neg2
00000E1F 03F8                   	add	edi,eax		;Point to the right offset.
00000E21 83C704                 	add	edi,4		;Point to the seg bit.
00000E24 0FB64602               	movzx	eax,byte ptr[esi+2]		;Get the target segment.
00000E28 48                     	dec	eax
00000E29 668907                 	mov	[edi],ax		;Store target.
                                	;
00000E2C 8B3D 00000B17o         	mov	edi,SegmentList
00000E32 8B3F                   	mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
00000E34 A1 00003922o           	mov	eax,PageCount+4	;Get page number within segment.
00000E39 C1E00C                 	shl	eax,12
00000E3C 03F8                   	add	edi,eax		;Include page offset.
00000E3E 0FB706                 	movzx	eax,word ptr[esi]
00000E41 03F8                   	add	edi,eax		;Include byte offset.
00000E43 83C704                 	add	edi,4		;Point to the seg bit.
00000E46 8BC7                   	mov	eax,edi
00000E48 E8D0000000             	call	AddRelocationEntry	;Add it to the list.
00000E4D 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000E56 0F82BF000000           	jc	@@9
                                	;
00000E5C 8B3D 00000B17o         	mov	edi,SegmentList
00000E62 8B7F0C                 	mov	edi,[edi]._Seg_.Seg_Memory
00000E65 A1 00003922o           	mov	eax,PageCount+4	;Get page number.
00000E6A C1E00C                 	shl	eax,12
00000E6D 03F8                   	add	edi,eax		;Point to the right page.
00000E6F 0FB706                 	movzx	eax,word ptr[esi]
00000E72 03F8                   	add	edi,eax		;Point to the right offset.
00000E74 0FB64602               	movzx	eax,byte ptr[esi+2]		;Get the target segment.
00000E78 48                     	dec	eax
00000E79 52                     	push	edx
00000E7A BA10000000             	mov	edx,size _Seg_
00000E7F F7E2                   	mul	edx
00000E81 5A                     	pop	edx
00000E82 83C004                 	add	eax,4		;skip dword count.
00000E85 0305 00003912o         	add	eax,ObjectList	;point to target segment details.
00000E8B 8B00                   	mov	eax,[eax]._Seg_.Seg_BaseAddress	;Get target segments offset from start of image.
00000E8D 0FB75E03               	movzx	ebx,word ptr[esi+3]		;Get target offset.
00000E91 F6C604                 	test	dh,4
00000E94 7403                   	jz	@@Big1
00000E96 8B5E03                 	mov	ebx,[esi+3]		;Get target offset.
00000E99                        @@Big1:
00000E99 03C3                   	add	eax,ebx
00000E9B 8907                   	mov	[edi],eax
                                	;
00000E9D 8B3D 00000B17o         	mov	edi,SegmentList
00000EA3 8B3F                   	mov	edi,[edi]._Seg_.Seg_BaseAddress	;Get offset from image start.
00000EA5 A1 00003922o           	mov	eax,PageCount+4	;Get page number within segment.
00000EAA C1E00C                 	shl	eax,12
00000EAD 03F8                   	add	edi,eax		;Include page offset.
00000EAF 0FB706                 	movzx	eax,word ptr[esi]
00000EB2 03F8                   	add	edi,eax		;Include byte offset.
00000EB4 8BC7                   	mov	eax,edi
00000EB6 0D00000010             	or	eax,1 shl 28		;Mark it as a 32-bit offset.
00000EBB E85D000000             	call	AddRelocationEntry	;Add it to the list.
00000EC0 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000EC9 7250                   	jc	@@9
                                	;
00000ECB 83C605                 @@Neg2:	add	esi,2+1+2
00000ECE 83E905                 	sub	ecx,2+1+2
00000ED1 F6C604                 	test	dh,4
00000ED4 7408                   	jz	@@3
00000ED6 83C602                 	add	esi,2
00000ED9 83E902                 	sub	ecx,2
00000EDC EB00                   	jmp	@@3
                                	;
00000EDE                        @@3:
00000EDE FF05 0000396Ao         	inc	RelocationCount
00000EE4 0BC9                   	or	ecx,ecx
00000EE6 0F852CFDFFFF           	jnz	@@2
                                	;
00000EEC                        @@4:
00000EEC 45                     	inc	ebp
00000EED FF05 00003922o         	inc	PageCount+4
00000EF3 FF0D 0000391Eo         	dec	PageCount
00000EF9 0F85F4FCFFFF           	jnz	@@1
                                	;
00000EFF 8305 00000B17o 10      	add	SegmentList,size _Seg_
00000F06 8305 0000390Eo 18      	add	ObjectBase,18h
00000F0D FF0D 0000390Ao         	dec	ObjectCount
00000F13 0F85BBFCFFFF           	jnz	@@0
                                	;
00000F19                        @@8:
00000F19 F8                     	clc
00000F1A C3                     	ret
                                	;
00000F1B                        @@9:
00000F1B F9                     	stc
00000F1C C3                     	ret
00000F1D                        CreateRelocations endp


                                ;------------------------------------------------------------------------------
                                ;
                                ;Add an entry to the relocation list.
                                ;
                                ;On Entry:
                                ;
                                ;EAX	- Item to add.
                                ;
                                ;On Exit:
                                ;
                                ;Carry set on error else,
                                ;
                                ;All registers preserved.
                                ;
00000F1D                        AddRelocationEntry proc near
00000F1D 60                     	pushad
00000F1E 833D 00003916o 00      	cmp	RelocationList,0
00000F25 7518                   	jnz	@@0
00000F27 B904000000             	mov	ecx,4
00000F2C E814030000             	call	LEMalloc
00000F31 7234                   	jc	@@9
00000F33 8935 00003916o         	mov	RelocationList,esi
00000F39 C70600000000           	mov	dword ptr[esi],0
                                	;
00000F3F                        @@0:
00000F3F 8B35 00003916o         	mov	esi,RelocationList
00000F45 8B0E                   	mov	ecx,[esi]		;Get current number of entries.
00000F47 41                     	inc	ecx
00000F48 C1E102                 	shl	ecx,2		;dword per entry.
00000F4B 83C104                 	add	ecx,4		;allow for count dword.
00000F4E E8D9020000             	call	LEReMalloc
00000F53 7212                   	jc	@@9
00000F55 8935 00003916o         	mov	RelocationList,esi	;store new list address.
00000F5B FF06                   	inc	dword ptr[esi]		;increase entry count.
00000F5D 03F1                   	add	esi,ecx
00000F5F 83EE04                 	sub	esi,4		;point to new entry.
00000F62 8906                   	mov	[esi],eax		;store entry.
                                	;
00000F64 F8                     	clc
00000F65 EB01                   	jmp	@@10
                                	;
00000F67                        @@9:
00000F67 F9                     	stc
00000F68                        @@10:
00000F68 61                     	popad
00000F69 C3                     	ret
00000F6A                        AddRelocationEntry endp


                                ;------------------------------------------------------------------------------
                                ;
                                ;Create 3P version of LE file in memory.
                                ;
00000F6A                        Create3PFile	proc	near
                                	@dprintf 1,<"Create3PFile enter",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00000F6A E8F3F0FFFF          1  	call dprintf
00000F6F 437265617465335046  1  	db "Create3PFile enter",10,0
00000F83 BE 0000388Eo           	mov	esi,offset BuildImageText
00000F88 E82A030000             	call	LEPrintString
                                	;
00000F8D 8B35 000038FEo         	mov	esi,LEAddress
00000F93 8B4E44                 	mov	ecx,[esi+44h]	;Get number of Objects.
00000F96 037640                 	add	esi,[esi+40h]	;Point to object table.
00000F99 890D 0000390Ao         	mov	ObjectCount,ecx
00000F9F 8935 0000390Eo         	mov	ObjectBase,esi
                                	;
00000FA5                        @@0:                    ;<--- loop
00000FA5 833D 00003912o 00      	cmp	ObjectList,0	;Started object list yet?
00000FAC 7525                   	jnz	@@0_0
00000FAE B904000000             	mov	ecx,4
00000FB3 E88D020000             	call	LEMalloc
00000FB8 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000FC1 0F8233010000           	jc	@@9
00000FC7 8935 00003912o         	mov	ObjectList,esi
00000FCD C70600000000           	mov	dword ptr[esi],0
00000FD3                        @@0_0:
00000FD3 8B35 00003912o         	mov	esi,ObjectList
00000FD9 8B06                   	mov	eax,[esi]		;Get number of entries.
00000FDB 40                     	inc	eax
00000FDC BA10000000             	mov	edx,size _Seg_
00000FE1 F7E2                   	mul	edx
00000FE3 83C004                 	add	eax,4
00000FE6 8BC8                   	mov	ecx,eax
00000FE8 E83F020000             	call	LEReMalloc		;Enlarge it.
00000FED 66C705 00000004o 24    	mov	ErrorNumber,36
         00
00000FF6 0F82FE000000           	jc	@@9
00000FFC 8935 00003912o         	mov	ObjectList,esi
00001002 FF06                   	inc	dword ptr[esi]
00001004 03F1                   	add	esi,ecx
00001006 83EE10                 	sub	esi,size _Seg_	;Point to new entry.
00001009 8BFE                   	mov	edi,esi
0000100B B910000000             	mov	ecx,size _Seg_
00001010 32C0                   	xor	al,al
00001012 F3AA                   	rep	stosb		;Clear it out.
00001014 8BFE                   	mov	edi,esi
                                	;
00001016 A1 0000391Ao           	mov	eax,SegmentBase
0000101B 8907                   	mov	[edi]._Seg_.Seg_BaseAddress,eax
0000101D 8B35 0000390Eo         	mov	esi,ObjectBase
00001023 8B0E                   	mov	ecx,[esi]		;Get segments size.
                                ;	add	ecx,15
                                ;	and	ecx,not 15
00001025 010D 0000391Ao         	add	SegmentBase,ecx
0000102B 894F08                 	mov	[edi]._Seg_.Seg_Length,ecx	;Set segments size.
                                	;
0000102E E812020000             	call	LEMalloc
00001033 66C705 00000004o 24    	mov	ErrorNumber,36
         00
0000103C 0F82B8000000           	jc	@@9
00001042 89770C                 	mov	[edi]._Seg_.Seg_Memory,esi	;Store segments address.
                                	pushm	eax,ecx,edi
                             1  	IRP	X,<eax,ecx,edi,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001045 50                  2  	PUSH	eax			;SAVE THE REGISTER
00001046 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001047 57                  2  	PUSH	edi			;SAVE THE REGISTER
00001048 8BFE                   	mov	edi,esi
0000104A 32C0                   	xor	al,al
0000104C F3AA                   	rep	stosb
                                	popm	eax,ecx,edi
                             1  	IRP	X,<,,,,,,,edi,ecx,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000104E 5F                  2  	POP	edi				;POP THE REGISTER
0000104F 59                  2  	POP	ecx				;POP THE REGISTER
00001050 58                  2  	POP	eax				;POP THE REGISTER
                                	;
00001051 8B35 0000390Eo         	mov	esi,ObjectBase
00001057 8B4608                 	mov	eax,[esi+08h]	;Get objects flags.
0000105A 33DB                   	xor	ebx,ebx
0000105C A904000000             	test	eax,4		;Executable?
00001061 7508                   	jnz	@@1
00001063 43                     	inc	ebx		;Make it Data.
00001064 A902000000             	test	eax,2		;Writeable?
00001069 7400                   	jz	@@1
                                ;	add	ebx,2		;Read only data.
0000106B                        @@1:
0000106B C1E318                 	shl	ebx,24
0000106E A900200000             	test	eax,2000h		;Big bit set?
00001073 7408                   	jz	@@2
00001075 81CB00000004           	or	ebx,1 shl 26		;Force 32-bit.
0000107B EB06                   	jmp	@@3
0000107D                        @@2:
0000107D 81CB00000002           	or	ebx,1 shl 25		;Force 16-bit.
00001083                        @@3:
00001083 8B4708                 	mov	eax,[edi]._Seg_.Seg_Length
00001086 3D00001000             	cmp	eax,100000h		;>1M?
0000108B 7208                   	jc	@@4
0000108D C1E80C                 	shr	eax,12
00001090 0D00001000             	or	eax,1 shl 20
00001095                        @@4:
00001095 0BD8                   	or	ebx,eax		;Include length.
00001097 81CB00000008           	or	ebx,1 shl 27		;mark target type
0000109D 895F04                 	mov	[edi]._Seg_.Seg_Type,ebx	;Store the 3P type.
                                	;
000010A0 8B35 0000390Eo         	mov	esi,ObjectBase
000010A6 8B4E10                 	mov	ecx,[esi+10h]	;Get number of pages.
000010A9 8B560C                 	mov	edx,[esi+0Ch]	;Get page table index.
000010AC 8B6F08                 	mov	ebp,[edi]._Seg_.Seg_Length	;Get maximum length again.
000010AF 8B7F0C                 	mov	edi,[edi]._Seg_.Seg_Memory	;Point to segments memory.
000010B2 8B1D 000038FEo         	mov	ebx,LEAddress
000010B8 039B80000000           	add	ebx,[ebx+80h]
000010BE 2B1D 00003906o         	sub	ebx,LEOffset
                                	;
000010C4                        @@5:
000010C4 8BC2                   	mov	eax,edx		;Get page number.
000010C6 48                     	dec	eax		;make it base 0.
000010C7 C1E00C                 	shl	eax,12		;*4096.
000010CA 03C3                   	add	eax,ebx		;Make offset from data pages.
000010CC 8BF0                   	mov	esi,eax
                                	;
000010CE B800100000             	mov	eax,4096		;Default page size.
000010D3                        @@6:
000010D3 3BE8                   	cmp	ebp,eax		;Want whole page?
000010D5 7302                   	jnc	@@7
000010D7 8BC5                   	mov	eax,ebp		;Force smaller value.
000010D9                        @@7:
000010D9 51                     	push	ecx
000010DA 8BC8                   	mov	ecx,eax		;Get length to copy.
000010DC F3A4                   	rep	movsb		;Copy this page.
000010DE 59                     	pop	ecx
000010DF 2BE8                   	sub	ebp,eax		;Update length remaining.
000010E1 42                     	inc	edx		;Next page index.
000010E2 49                     	dec	ecx
000010E3 75EE                   	jnz	@@6		;Get all pages.
                                	;
000010E5 8305 0000390Eo 18      	add	ObjectBase,18h	;Next object
000010EC FF0D 0000390Ao         	dec	ObjectCount
000010F2 0F85ADFEFFFF           	jnz	@@0		;Do all objects.
                                	;
000010F8 F8                     	clc
000010F9 C3                     	ret
                                	;
000010FA                        @@9:
000010FA F9                     	stc
000010FB C3                     	ret
000010FC                        Create3PFile	endp


                                ;------------------------------------------------------------------------------
                                ;
                                ;Fetch the specified LE file, just the LE bit not its stub.
                                ;
000010FC                        FetchLEFile	proc	near
                                	@dprintf 1,<"FetchLEFile enter",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000010FC E861EFFFFF          1  	call dprintf
00001101 46657463684C454669  1  	db "FetchLEFile enter",10,0
00001114 BE 00003871o           	mov	esi,offset ReadingLEText
00001119 E899010000             	call	LEPrintString
                                	;
0000111E BA 00000100o           	mov	edx,offset EXEFileName
00001123 E87A010000             	call	LEOpenFile
00001128 66C705 00000004o 20    	mov	ErrorNumber,32
         00
00001131 0F82A4000000           	jc	@@9
00001137 B93C000000             	mov	ecx,3ch
0000113C 32C0                   	xor	al,al
0000113E E847010000             	call	LESetFilePointer	;Move to the LE bit.
00001143 52                     	push	edx
00001144 8BD4                   	mov	edx,esp
00001146 B904000000             	mov	ecx,4
0000114B E805010000             	call	LEReadFile		;Read offset to LE.
00001150 5A                     	pop	edx
00001151 8915 00003906o         	mov	LEOffset,edx
00001157 66C705 00000004o 21    	mov	ErrorNumber,33
         00
00001160 7279                   	jc	@@9
00001162 3BC1                   	cmp	eax,ecx
00001164 7575                   	jnz	@@9
00001166 33C9                   	xor	ecx,ecx
00001168 B002                   	mov	al,2
0000116A E81B010000             	call	LESetFilePointer	;Get file length.
0000116F 2BCA                   	sub	ecx,edx		;Lose stub section from length.
00001171 87CA                   	xchg	ecx,edx
00001173 32C0                   	xor	al,al
00001175 E810010000             	call	LESetFilePointer	;Point to LE section.
0000117A 87CA                   	xchg	ecx,edx
0000117C 51                     	push	ecx
0000117D 81C1FF0F0000           	add	ecx,4095
00001183 81E100F0FFFF           	and	ecx,not 4095
00001189 E8B7000000             	call	LEMalloc		;Get memory for the file.
0000118E 59                     	pop	ecx
0000118F 66C705 00000004o 22    	mov	ErrorNumber,34
         00
00001198 7241                   	jc	@@9
                                	pushm	eax,ecx,edi
                             1  	IRP	X,<eax,ecx,edi,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000119A 50                  2  	PUSH	eax			;SAVE THE REGISTER
0000119B 51                  2  	PUSH	ecx			;SAVE THE REGISTER
0000119C 57                  2  	PUSH	edi			;SAVE THE REGISTER
0000119D 81C1FF0F0000           	add	ecx,4095
000011A3 81E100F0FFFF           	and	ecx,not 4095
000011A9 8BFE                   	mov	edi,esi
000011AB 32C0                   	xor	al,al
000011AD F3AA                   	rep	stosb
                                	popm	eax,ecx,edi
                             1  	IRP	X,<,,,,,,,edi,ecx,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000011AF 5F                  2  	POP	edi				;POP THE REGISTER
000011B0 59                  2  	POP	ecx				;POP THE REGISTER
000011B1 58                  2  	POP	eax				;POP THE REGISTER
000011B2 8BD6                   	mov	edx,esi
000011B4 E89C000000             	call	LEReadFile		;Read the file.
000011B9 66C705 00000004o 23    	mov	ErrorNumber,35
         00
000011C2 7217                   	jc	@@9
000011C4 3BC1                   	cmp	eax,ecx
000011C6 7513                   	jnz	@@9
000011C8 E871000000             	call	LECloseFile		;Close the file again.
                                	;
000011CD 8935 000038FEo         	mov	LEAddress,esi	;Store LE files address.
000011D3 890D 00003902o         	mov	LELength,ecx		;Store its length as well.
000011D9 F8                     	clc
000011DA C3                     	ret
                                	;
000011DB F9                     @@9:	stc
000011DC C3                     	ret
000011DD                        FetchLEFile	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Create a file.
                                ;
                                ;On Entry:
                                ;
                                ;EDX	- File name.
                                ;
                                ;On Exit:
                                ;
                                ;Carry set on error and EBX=0 else,
                                ;
                                ;EBX	- File handle.
                                ;
000011DD                        LECreateFile	proc	near
                                	pushm	eax,ecx
                             1  	IRP	X,<eax,ecx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000011DD 50                  2  	PUSH	eax			;SAVE THE REGISTER
000011DE 51                  2  	PUSH	ecx			;SAVE THE REGISTER
000011DF B43C                   	mov	ah,3ch		;Create function.
000011E1 6633C9                 	xor	cx,cx		;normal attributes.
000011E4 CD21                   	int	21h
000011E6 668BD8                 	mov	bx,ax
000011E9 7304                   	jnc	l0
000011EB 6633DB                 	xor	bx,bx
000011EE F9                     	stc
000011EF                        l0:
000011EF 0FB7DB                 	movzx	ebx,bx
                                	popm	eax,ecx
                             1  	IRP	X,<,,,,,,,,ecx,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000011F2 59                  2  	POP	ecx				;POP THE REGISTER
000011F3 58                  2  	POP	eax				;POP THE REGISTER
000011F4 C3                     	ret
000011F5                        LECreateFile	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Write some data to a file.
                                ;
                                ;On Entry:
                                ;
                                ;EDX	- Address to write from.
                                ;ECX	- Length to write.
                                ;EBX	- file handle.
                                ;
                                ;On Exit:
                                ;
                                ;EAX	- Bytes written.
                                ;
000011F5                        LEWriteFile	proc	near
                                	pushm	ecx,edx,esi
                             1  	IRP	X,<ecx,edx,esi,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000011F5 51                  2  	PUSH	ecx			;SAVE THE REGISTER
000011F6 52                  2  	PUSH	edx			;SAVE THE REGISTER
000011F7 56                  2  	PUSH	esi			;SAVE THE REGISTER
000011F8 33F6                   	xor	esi,esi
000011FA                        @@0:
                                	pushm	ebx,ecx,edx,esi
                             1  	IRP	X,<ebx,ecx,edx,esi,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000011FA 53                  2  	PUSH	ebx			;SAVE THE REGISTER
000011FB 51                  2  	PUSH	ecx			;SAVE THE REGISTER
000011FC 52                  2  	PUSH	edx			;SAVE THE REGISTER
000011FD 56                  2  	PUSH	esi			;SAVE THE REGISTER
000011FE 81F9FFFF0000           	cmp	ecx,65535		;size of chunks to load.
00001204 7205                   	jc	@@1
00001206 B9FFFF0000             	mov	ecx,65535		;as close to 64k as can get.
0000120B                        @@1:
0000120B B440                   	mov	ah,40h
0000120D CD21                   	int	21h		;read from the file.
                                	popm	ebx,ecx,edx,esi
                             1  	IRP	X,<,,,,,,esi,edx,ecx,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000120F 5E                  2  	POP	esi				;POP THE REGISTER
00001210 5A                  2  	POP	edx				;POP THE REGISTER
00001211 59                  2  	POP	ecx				;POP THE REGISTER
00001212 5B                  2  	POP	ebx				;POP THE REGISTER
00001213 7211                   	jc	@@2
00001215 0FB7C0                 	movzx	eax,ax		;get length read.
00001218 03F0                   	add	esi,eax		;update length read counter.
0000121A 03D0                   	add	edx,eax		;move memory pointer.
0000121C 2BC8                   	sub	ecx,eax		;update length counter.
0000121E 7406                   	jz	@@2		;read as much as was wanted.
00001220 0BC0                   	or	eax,eax		;did we write anything?
00001222 7402                   	jz	@@2
00001224 EBD4                   	jmp	@@0
00001226                        @@2:
00001226 8BC6                   	mov	eax,esi
                                	popm	ecx,edx,esi
                             1  	IRP	X,<,,,,,,,esi,edx,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001228 5E                  2  	POP	esi				;POP THE REGISTER
00001229 5A                  2  	POP	edx				;POP THE REGISTER
0000122A 59                  2  	POP	ecx				;POP THE REGISTER
0000122B C3                     	ret
0000122C                        LEWriteFile	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Re-size previously allocated memory.
                                ;
                                ;On Entry:
                                ;
                                ;ECX	- New size.
                                ;ESI	- Current address of memory.
                                ;
                                ;On Exit:
                                ;
                                ;Carry set on error and ESI=0 else,
                                ;
                                ;ESI	- New address of memory.
                                ;
                                ;All other registers preserved.
                                ;
0000122C                        LEReMalloc	proc	near
                                	pushm	eax,edx
                             1  	IRP	X,<eax,edx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000122C 50                  2  	PUSH	eax			;SAVE THE REGISTER
0000122D 52                  2  	PUSH	edx			;SAVE THE REGISTER
                                if @Model ne 7
                                endif
0000122E E8721C0000             	call	ResMemLinear32
00001233 7203                   	jc	l0
                                if @Model ne 7
                                endif
00001235 F8                     	clc
00001236 EB03                   	jmp	l1
00001238                        l0:
00001238 33F6                   	xor	esi,esi
0000123A F9                     	stc
0000123B                        l1:	popm	eax,edx
                             1  	IRP	X,<,,,,,,,,edx,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000123B 5A                  2  	POP	edx				;POP THE REGISTER
0000123C 58                  2  	POP	eax				;POP THE REGISTER
0000123D C3                     	ret
0000123E                        LEReMalloc	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Close a file.
                                ;
                                ;On Entry:
                                ;
                                ;EBX	- file handle.
                                ;
0000123E                        LECloseFile	proc	near
0000123E 50                     	push	eax
0000123F B43E                   	mov	ah,3eh
00001241 CD21                   	int	21h
00001243 58                     	pop	eax
00001244 C3                     	ret
00001245                        LECloseFile	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Allocate some DS relative memory.
                                ;
                                ;On Entry:
                                ;
                                ;ECX	- Bytes required.
                                ;
                                ;On Exit:
                                ;
                                ;Carry set on error and ESI=0 else,
                                ;
                                ;ESI	- DS relative address of allocated memory.
                                ;
                                ;All other registers preserved.
                                ;
00001245                        LEMalloc	proc	near
00001245 50                     	push	eax
00001246 E82F1C0000             	call	GetMemLinear32
0000124B 7203                   	jc	l0
                                if @Model ne 7
                                endif
0000124D F8                     	clc
0000124E EB03                   	jmp	l1
00001250                        l0:
00001250 33F6                   	xor	esi,esi
00001252 F9                     	stc
00001253                        l1:
00001253 58                     	pop	eax
00001254 C3                     	ret
00001255                        LEMalloc	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Read some data from a file.
                                ;
                                ;On Entry:
                                ;
                                ;EDX	- Address to read to.
                                ;ECX	- length to read.
                                ;EBX	- file handle.
                                ;
                                ;On Exit:
                                ;
                                ;EAX	- bytes read.
                                ;
00001255                        LEReadFile	proc	near
                                	pushm	ecx,edx,esi
                             1  	IRP	X,<ecx,edx,esi,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001255 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001256 52                  2  	PUSH	edx			;SAVE THE REGISTER
00001257 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001258 33F6                   	xor	esi,esi		;reset length read.
0000125A                        @@0:
                                	pushm	ebx,ecx,edx,esi
                             1  	IRP	X,<ebx,ecx,edx,esi,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000125A 53                  2  	PUSH	ebx			;SAVE THE REGISTER
0000125B 51                  2  	PUSH	ecx			;SAVE THE REGISTER
0000125C 52                  2  	PUSH	edx			;SAVE THE REGISTER
0000125D 56                  2  	PUSH	esi			;SAVE THE REGISTER
0000125E 81F9FFFF0000           	cmp	ecx,65535		;size of chunks to load.
00001264 7205                   	jc	@@1
00001266 B9FFFF0000             	mov	ecx,65535		;as close to 64k as can get.
0000126B                        @@1:
0000126B B43F                   	mov	ah,3fh
0000126D CD21                   	int	21h		;read from the file.
                                	popm	ebx,ecx,edx,esi
                             1  	IRP	X,<,,,,,,esi,edx,ecx,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000126F 5E                  2  	POP	esi				;POP THE REGISTER
00001270 5A                  2  	POP	edx				;POP THE REGISTER
00001271 59                  2  	POP	ecx				;POP THE REGISTER
00001272 5B                  2  	POP	ebx				;POP THE REGISTER
00001273 720F                   	jc	@@2		;DOS error so exit NOW.
00001275 0FB7C0                 	movzx	eax,ax		;get length read.
00001278 03F0                   	add	esi,eax		;update length read counter.
0000127A 03D0                   	add	edx,eax		;move memory pointer.
0000127C 2BC8                   	sub	ecx,eax		;update length counter.
0000127E 7404                   	jz	@@2		;read as much as was wanted.
00001280 0BC0                   	or	eax,eax		;did we read anything?
00001282 75D6                   	jnz	@@0
00001284                        @@2:
00001284 8BC6                   	mov	eax,esi
                                	popm	ecx,edx,esi
                             1  	IRP	X,<,,,,,,,esi,edx,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001286 5E                  2  	POP	esi				;POP THE REGISTER
00001287 5A                  2  	POP	edx				;POP THE REGISTER
00001288 59                  2  	POP	ecx				;POP THE REGISTER
00001289 C3                     	ret
0000128A                        LEReadFile	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Set the file pointer position for a file.
                                ;
                                ;On Entry:
                                ;
                                ;AL	- method.
                                ;EBX	- handle.
                                ;ECX	- position.
                                ;
                                ;Methods are:
                                ;
                                ;0	- Absolute offset from start.
                                ;1	- signed offset from current position.
                                ;2	- signed offset from end of file.
                                ;
                                ;On Exit:
                                ;
                                ;ECX	- absolute offset from start of file.
                                ;
0000128A                        LESetFilePointer proc near
                                	pushm	eax,edx
                             1  	IRP	X,<eax,edx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000128A 50                  2  	PUSH	eax			;SAVE THE REGISTER
0000128B 52                  2  	PUSH	edx			;SAVE THE REGISTER
0000128C 668BD1                 	mov	dx,cx
0000128F C1E910                 	shr	ecx,16
00001292 B442                   	mov	ah,42h		;set pointer function.
00001294 CD21                   	int	21h
00001296 668BCA                 	mov	cx,dx
00001299 C1E110                 	shl	ecx,16
0000129C 668BC8                 	mov	cx,ax		;fetch small result.
                                	popm	eax,edx
                             1  	IRP	X,<,,,,,,,,edx,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000129F 5A                  2  	POP	edx				;POP THE REGISTER
000012A0 58                  2  	POP	eax				;POP THE REGISTER
000012A1 C3                     	ret
000012A2                        LESetFilePointer endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Open a file.
                                ;
                                ;On Entry:
                                ;
                                ;EDX	- File name.
                                ;
                                ;On Exit:
                                ;
                                ;Carry set on error and EBX=0 else,
                                ;
                                ;EBX	- File handle.
                                ;
000012A2                        LEOpenFile	proc	near
000012A2 50                     	push	eax
000012A3 66B8023D               	mov	ax,3d02h		;Open with read & write access.
000012A7 CD21                   	int	21h
000012A9 668BD8                 	mov	bx,ax
000012AC 7304                   	jnc	l0
000012AE 6633DB                 	xor	bx,bx
000012B1 F9                     	stc
000012B2                        l0:
000012B2 58                     	pop	eax
000012B3 0FB7DB                 	movzx	ebx,bx
000012B6 C3                     	ret
000012B7                        LEOpenFile	endp


                                ;-------------------------------------------------------------------------
                                ;
                                ;Print null terminated string on screen via DOS.
                                ;
                                ;On Entry:
                                ;
                                ;ESI	- pointer to string to print.
                                ;
000012B7                        LEPrintString	proc	near
                                	pushm	eax,esi,edx
                             1  	IRP	X,<eax,esi,edx,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000012B7 50                  2  	PUSH	eax			;SAVE THE REGISTER
000012B8 56                  2  	PUSH	esi			;SAVE THE REGISTER
000012B9 52                  2  	PUSH	edx			;SAVE THE REGISTER
000012BA                        l0:
000012BA 8A16                   	mov	dl,[esi]
000012BC 46                     	inc	esi
000012BD 0AD2                   	or	dl,dl
000012BF 7406                   	jz	l1
000012C1 B402                   	mov	ah,2
000012C3 CD21                   	int	21h
000012C5 EBF3                   	jmp	l0
000012C7                        l1:
                                	popm	eax,esi,edx
                             1  	IRP	X,<,,,,,,,edx,esi,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000012C7 5A                  2  	POP	edx				;POP THE REGISTER
000012C8 5E                  2  	POP	esi				;POP THE REGISTER
000012C9 58                  2  	POP	eax				;POP THE REGISTER
000012CA C3                     	ret
000012CB                        LEPrintString	endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
000012CB                        NewCauseWay	proc	near
                                ;
                                ;Write new CauseWay loader to a 3P file.
                                ;
                                	@dprintf 1,<"NewCauseWay enter",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000012CB E892EDFFFF          1  	call dprintf
000012D0 4E6577436175736557  1  	db "NewCauseWay enter",10,0
000012E3 668B1D 00000B00o       	mov	bx,EXEHandle
000012EA E8041E0000             	call	CloseFile
000012EF BA 00000100o           	mov	edx,offset EXEFileName
000012F4 E8101D0000             	call	OpenFile		;Open the .EXE file.
000012F9 66C705 00000004o 06    	mov	ErrorNumber,6	;default to not found.
         00
00001302 0F825C030000           	jc	@@9
00001308 66A3 00000B00o         	mov	EXEHandle,ax
                                	;
                                	;Create temp file.
                                	;
0000130E BA 00000B08o           	mov	edx,offset TempFileName	;get DOS to give us a temp file.
00001313 E8241D0000             	call	CreateFile
00001318 66C705 00000004o 13    	mov	ErrorNumber,19	;default to can't create output.
         00
00001321 0F823D030000           	jc	@@9		;oops.
00001327 66A3 00000B15o         	mov	TempHandle,ax
                                	;
                                	;Copy 386SHELL to temp file.
                                	;
0000132D BA 00000080o           	mov	edx,offset SHELLFileName	;get extender stub (stub from CW.EXE)
00001332 E8D21C0000             	call	OpenFile
00001337 66C705 00000004o 09    	mov	ErrorNumber,9	;no stub file.
         00
00001340 0F821E030000           	jc	@@9
00001346 66A3 00000AFAo         	mov	SHELLHandle,ax
                                	;
0000134C BA 00000A62o           	mov	edx,offset ProcessStubText
00001351 E8D81E0000             	call	StringPrint
                                	;

00001356 BA 00000B2Bo           	mov	edx,offset exehdr
0000135B B91B000000             	mov	ecx,sizeof MZHdr
00001360 668B1D 00000AFAo       	mov	bx,SHELLHandle
00001367 B43F                   	mov	ah,3fh
00001369 CD21                   	int	21h		;read the .EXE header.
0000136B 66C705 00000004o 08    	mov	ErrorNumber,8	;default to IO error.
         00
00001374 0F82EA020000           	jc	@@9
0000137A 66C705 00000004o 09    	mov	ErrorNumber,9	;stub file error.
         00
00001383 6683F81B               	cmp	ax,sizeof MZHdr
00001387 0F85D7020000           	jnz	@@9
0000138D 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Correct ID?
         5A
00001396 0F85C8020000           	jnz	@@9
                                	;
0000139C 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
000013A2 66833D 00000B2Do 00    	cmp	exehdr._Length,0
000013AA 7402                   	je	medexe5		; not rounded if no modulo

000013AC 6648                   	dec	ax		;lose 1 cos its rounded up

000013AE                        medexe5:
000013AE 6603C0                 	add	ax,ax		;mult by 2
000013B1 B600                   	mov	dh,0
000013B3 8AD4                   	mov	dl,ah
000013B5 8AE0                   	mov	ah,al
000013B7 8AC6                   	mov	al,dh		;mult by 256=*512
000013B9 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
000013C0 6683D200               	adc	dx,0		;add any carry to dx
000013C4 668BC8                 	mov	cx,ax
                                	pushm	cx,dx
                             1  	IRP	X,<cx,dx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000013C7 6651                2  	PUSH	cx			;SAVE THE REGISTER
000013C9 6652                2  	PUSH	dx			;SAVE THE REGISTER
000013CB 66BAE5FF               	mov	dx,-1bh
000013CF 66B9FFFF               	mov	cx,-1
000013D3 668B1D 00000AFAo       	mov	bx,SHELLHandle
000013DA 66B80142               	mov	ax,4201h
000013DE CD21                   	int	21h		;move back to start of CWSTUB.EXE
                                	popm	cx,dx
                             1  	IRP	X,<,,,,,,,,dx,cx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000013E0 665A                2  	POP	dx				;POP THE REGISTER
000013E2 6659                2  	POP	cx				;POP THE REGISTER
                                	;
                                	;Get memory for shell.
                                	;
000013E4 8BDA                   	mov	ebx,edx
000013E6 C1E310                 	shl	ebx,16
000013E9 668BD9                 	mov	bx,cx
                                ;	push	ebx
                                ;	sys	GetMemNear		;get memory for shell.
                                ;	pop	ebx
000013EC 8BCB                   	mov	ecx,ebx
000013EE E8871A0000             	call	GetMemLinear32

000013F3 66C705 00000004o 02    	mov	ErrorNumber,2
         00
000013FC 0F8262020000           	jc	@@9
                                	;
                                	;Read shell into memory.
                                	;
                                	pushm	ebx,esi
                             1  	IRP	X,<ebx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001402 53                  2  	PUSH	ebx			;SAVE THE REGISTER
00001403 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001404 8BCB                   	mov	ecx,ebx
00001406 8BFE                   	mov	edi,esi
00001408 668B1D 00000AFAo       	mov	bx,SHELLHandle
0000140F E86B1C0000             	call	ReadFile
                                	popm	ebx,esi
                             1  	IRP	X,<,,,,,,,,esi,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001414 5E                  2  	POP	esi				;POP THE REGISTER
00001415 5B                  2  	POP	ebx				;POP THE REGISTER
00001416 66C705 00000004o 08    	mov	ErrorNumber,8
         00
0000141F 0F823F020000           	jc	@@9
00001425 3BC3                   	cmp	eax,ebx		;did we read enough?
00001427 0F8537020000           	jnz	@@9
                                	pushm	ebx,esi
                             1  	IRP	X,<ebx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
0000142D 53                  2  	PUSH	ebx			;SAVE THE REGISTER
0000142E 56                  2  	PUSH	esi			;SAVE THE REGISTER
                                	;
                                	;Write shell to temp.
                                	;
                                	popm	ebx,esi
                             1  	IRP	X,<,,,,,,,,esi,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000142F 5E                  2  	POP	esi				;POP THE REGISTER
00001430 5B                  2  	POP	ebx				;POP THE REGISTER
                                	pushm	ebx,esi
                             1  	IRP	X,<ebx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001431 53                  2  	PUSH	ebx			;SAVE THE REGISTER
00001432 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001433 8BCB                   	mov	ecx,ebx
00001435 668B1D 00000B15o       	mov	bx,TEMPHandle
0000143C E8781C0000             	call	WriteFile
                                	popm	ebx,esi
                             1  	IRP	X,<,,,,,,,,esi,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001441 5E                  2  	POP	esi				;POP THE REGISTER
00001442 5B                  2  	POP	ebx				;POP THE REGISTER
00001443 0F821B020000           	jc	@@9
00001449 3BC3                   	cmp	eax,ebx		;did we write enough?
0000144B 0F8513020000           	jnz	@@9

                                	@dprintf 1,<"NewCauseWay: at memory release",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00001451 E80CECFFFF          1  	call dprintf
00001456 4E6577436175736557  1  	db "NewCauseWay: at memory release",10,0

                                ;	sys	RelMemNear		;release memory now.
00001476 E81C1A0000             	call	RelMemLinear32

                                	;
                                	;Skip past old CauseWay.
                                	;
0000147B 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001484 668B1D 00000B00o       	mov	bx,EXEHandle
0000148B BA 00000B2Bo           	mov	edx,offset exehdr	;somewhere to put the info.
00001490 B91B000000             	mov	ecx,sizeof MZHdr	;size of it.
00001495 B43F                   	mov	ah,3fh
00001497 CD21                   	int	21h
00001499 0F82C5010000           	jc	@@9
0000149F 6683F81B               	cmp	ax,sizeof MZHdr		;did we read right amount?
000014A3 0F85BB010000           	jnz	@@9
                                	;
                                	;Check for normal MZ header first.
                                	;
000014A9 66C705 00000004o 07    	mov	ErrorNumber,7
         00
000014B2 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Normal EXE?
         5A
000014BB 0F85A3010000           	jnz	@@9
                                	;
000014C1 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
000014C7 66833D 00000B2Do 00    	cmp	exehdr._Length,0
000014CF 7402                   	je	medexe6		; not rounded if no modulo

000014D1 6648                   	dec	ax		;lose 1 cos its rounded up

000014D3                        medexe6:
000014D3 6603C0                 	add	ax,ax		;mult by 2
000014D6 B600                   	mov	dh,0
000014D8 8AD4                   	mov	dl,ah
000014DA 8AE0                   	mov	ah,al
000014DC 8AC6                   	mov	al,dh		;mult by 256=*512
000014DE 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
000014E5 6683D200               	adc	dx,0		;add any carry to dx
000014E9 668BC8                 	mov	cx,ax
                                	pushm	cx,dx
                             1  	IRP	X,<cx,dx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000014EC 6651                2  	PUSH	cx			;SAVE THE REGISTER
000014EE 6652                2  	PUSH	dx			;SAVE THE REGISTER
                                	;
                                	;Find out where the end of the file is.
                                	;
000014F0 6633C9                 	xor	cx,cx
000014F3 668BD1                 	mov	dx,cx
000014F6 B002                   	mov	al,2
000014F8 668B1D 00000B00o       	mov	bx,EXEHandle
000014FF E86C1B0000             	call	SetFilePointer	;move to the end of the file.
00001504 668BC1                 	mov	ax,cx
00001507 668BDA                 	mov	bx,dx
                                	popm	cx,dx
                             1  	IRP	X,<,,,,,,,,dx,cx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000150A 665A                2  	POP	dx				;POP THE REGISTER
0000150C 6659                2  	POP	cx				;POP THE REGISTER
0000150E 662BC1                 	sub	ax,cx
00001511 661BDA                 	sbb	bx,dx		;get remaining length.
                                	pushm	ax,bx
                             1  	IRP	X,<ax,bx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001514 6650                2  	PUSH	ax			;SAVE THE REGISTER
00001516 6653                2  	PUSH	bx			;SAVE THE REGISTER
00001518 B000                   	mov	al,0
0000151A 668B1D 00000B00o       	mov	bx,EXEHandle
00001521 E84A1B0000             	call	SetFilePointer	;point to the 3P header again.
                                	popm	ax,bx
                             1  	IRP	X,<,,,,,,,,bx,ax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001526 665B                2  	POP	bx				;POP THE REGISTER
00001528 6658                2  	POP	ax				;POP THE REGISTER
0000152A C1E310                 	shl	ebx,16
0000152D 668BD8                 	mov	bx,ax

                                	@dprintf 1,<'NewCauseWay: at get memory',10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00001530 E82DEBFFFF          1  	call dprintf
00001535 4E6577436175736557  1  	db 'NewCauseWay: at get memory',10,0

                                ;	push	ebx
                                ;	sys	GetMemNear		;get some memory for it.
                                ;	pop	ebx
00001551 8BCB                   	mov	ecx,ebx
00001553 E822190000             	call	GetMemLinear32

00001558 66C705 00000004o 02    	mov	ErrorNumber,2
         00
00001561 0F82FD000000           	jc	@@9
                                	;
                                	;Read real file into memory.
                                	;
00001567 66C705 00000004o 08    	mov	ErrorNumber,8
         00
                                	pushm	esi,ebx
                             1  	IRP	X,<esi,ebx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001570 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001571 53                  2  	PUSH	ebx			;SAVE THE REGISTER
00001572 8BCB                   	mov	ecx,ebx
00001574 8BFE                   	mov	edi,esi
00001576 1E                     	push	ds
00001577 07                     	pop	es
00001578 668B1D 00000B00o       	mov	bx,EXEHandle
0000157F E8FB1A0000             	call	ReadFile
                                	popm	esi,ecx
                             1  	IRP	X,<,,,,,,,,ecx,esi> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001584 59                  2  	POP	ecx				;POP THE REGISTER
00001585 5E                  2  	POP	esi				;POP THE REGISTER
00001586 0F82D8000000           	jc	@@9
0000158C 3BC1                   	cmp	eax,ecx
0000158E 0F82D0000000           	jc	@@9
                                	;
                                	;Write real file to temp.
                                	;
                                	pushm	esi,ecx
                             1  	IRP	X,<esi,ecx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001594 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001595 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001596 668B1D 00000B15o       	mov	bx,TEMPHandle
0000159D E8171B0000             	call	WriteFile
                                	popm	esi,ecx
                             1  	IRP	X,<,,,,,,,,ecx,esi> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000015A2 59                  2  	POP	ecx				;POP THE REGISTER
000015A3 5E                  2  	POP	esi				;POP THE REGISTER
000015A4 0F82BA000000           	jc	@@9
000015AA 3BC1                   	cmp	eax,ecx
000015AC 0F85B2000000           	jnz	@@9
                                ;	sys	RelMemNear		;release the memory.
000015B2 E8E0180000             	call	RelMemLinear32


                                	;
                                	;Close the files.
                                	;
000015B7 668B1D 00000B15o       	mov	bx,TEMPHandle
000015BE E8301B0000             	call	CloseFile		;close the temp file.
000015C3 66C705 00000B15o 00    	mov	TEMPHandle,0
         00
000015CC 668B1D 00000B00o       	mov	bx,EXEHandle
000015D3 E81B1B0000             	call	CloseFile		;close the file again.
000015D8 66C705 00000B00o 00    	mov	EXEHandle,0
         00
000015E1 668B1D 00000AFAo       	mov	bx,SHELLHandle
000015E8 E8061B0000             	call	CloseFile
000015ED 66C705 00000AFAo 00    	mov	SHELLHandle,0
         00
                                	;

                                	@dprintf 1,<"NewCauseWay: File %s",10>,offset EXEFileName
                             1    for x,<,,,,offset EXEFileName>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000015F6 68 00000100o        2  	push offset EXEFileName
000015FB E862EAFFFF          1  	call dprintf
00001600 4E6577436175736557  1  	db "NewCauseWay: File %s",10,0

                                	;Delete origional .EXE
                                	;
00001616 BA 00000100o           	mov	edx,offset EXEFileName	;get file name mask.
0000161B B441                   	mov	ah,41h
0000161D CD21                   	int	21h
0000161F 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001628 723A                   	jc	@@9
                                	;

                                	@dprintf 1,<'NewCauseWay: at rename',10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
0000162A E833EAFFFF          1  	call dprintf
0000162F 4E6577436175736557  1  	db 'NewCauseWay: at rename',10,0

                                	;now rename it.
                                	;
00001647 BA 00000B08o           	mov	edx,offset TempFileName
0000164C BF 00000100o           	mov	edi,offset EXEFileName		;get file name mask.
00001651 B456                   	mov	ah,56h
00001653 CD21                   	int	21h
00001655 720D                   	jc	@@9
                                	;
00001657 66C705 00000004o 00    	mov	ErrorNumber,0
         00
00001660 6633C0                 	xor	ax,ax
00001663 C3                     	ret
                                	;
00001664 66B8FFFF               @@9:	mov	ax,-1
00001668 660BC0                 	or	ax,ax
0000166B C3                     	ret
0000166C                        NewCauseWay	endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
0000166C                        SetSystemConfig proc near
                                ;
                                ;Set Flags entry in header.
                                ;
0000166C 33C0                   	xor	eax,eax
                                	;
0000166E 803D 000039C0o 00      	cmp	OptionTable+'D',0	;Dual mode?
00001675 740C                   	jz	@@2
00001677 0D00000100             	or	eax,65536		;enable dual mode.

                                ; don't set data bit under dual mode because it can confuse things
                                ;  why, I don't know, it just does
                                ;  MED 06/11/96
0000167C 0D00400000             	or	eax,16384		;set 16 bit code segments.
                                ;	or	eax,1+16384		;16 bit code.

00001681 EB0E                   	jmp	@@0
                                	;
00001683 803D 000039AFo 00      @@2:	cmp	OptionTable+'3',0
0000168A 7505                   	jnz	@@0
0000168C 0D01400000             	or	eax,1+16384		;16 bit code.
00001691                        @@0:	;
00001691 803D 000039C8o 00      	cmp	OptionTable+'L',0	;LDT ?
00001698 7405                   	jz	@@1
0000169A 0D80000000             	or	eax,128
0000169F                        @@1:	;
0000169F BE 00000B4Eo           	mov	esi,offset NewHeader
000016A4 894620                 	mov	[esi].NewHeaderStruc.NewFlags,eax
                                	;
                                	;Get auto stack size.
                                	;
000016A7 66C705 00000004o 1B    	mov	ErrorNumber,27
         00
000016B0 803D 000039CFo 00      	cmp	OptionTable+'S',0
000016B7 7441                   	jz	@@NoAutoESP
000016B9 8B35 00003B48o         	mov	esi,dword ptr[OptionTable+128+('S'*4)]
000016BF 0BF6                   	or	esi,esi
000016C1 0F844BEEFFFF           	jz	System
000016C7 33D2                   	xor	edx,edx
000016C9                        @@ss0:
000016C9 0FB606                 	movzx	eax,byte ptr[esi]
000016CC 0AC0                   	or	al,al
000016CE 7422                   	jz	@@ss1
000016D0 3C30                   	cmp	al,'0'
000016D2 0F823AEEFFFF           	jc	System
000016D8 3C3A                   	cmp	al,'9'+1
000016DA 0F8332EEFFFF           	jnc	System
000016E0 2C30                   	sub	al,'0'
000016E2 50                     	push	eax
000016E3 B80A000000             	mov	eax,10
000016E8 F7E2                   	mul	edx
000016EA 8BD0                   	mov	edx,eax
000016EC 58                     	pop	eax
000016ED 03D0                   	add	edx,eax
000016EF 46                     	inc	esi
000016F0 EBD7                   	jmp	@@ss0
000016F2                        @@ss1:
000016F2 BE 00000B4Eo           	mov	esi,offset NewHeader
000016F7 895624                 	mov	[esi].NewHeaderStruc.NewAutoStack,edx
                                	;
000016FA                        @@NoAutoESP:
000016FA C3                     	ret
000016FB                        SetSystemConfig endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
000016FB                        ExeAndMap2NewExe proc near
                                	@dprintf 1,<"ExeAndMap2NewExe entry",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
000016FB E862E9FFFF          1  	call dprintf
00001700 457865416E644D6170  1  	db "ExeAndMap2NewExe entry",10,0
                                	;
                                	;Setup hard wired flags, like 16/32 bit etc.
                                	;
00001718 8BCB                   	mov	ecx,ebx
0000171A E84DFFFFFF             	call	SetSystemConfig
                                	;
0000171F E84F0E0000             	call	ReadMapFile		;process map file details.
00001724 7510                   	jnz	@@9
                                	;
00001726 E8C8060000             	call	ProcessFile		;do the nitty gritty.
0000172B 7509                   	jnz	@@9
                                	;
0000172D 66C705 00000004o 00    	mov	ErrorNumber,0	;clear error number.
         00
00001736 C3                     @@9:	ret
00001737                        ExeAndMap2NewExe endp


                                ;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
00001737                        NewExeInfo	proc	near
                                ;
                                ;Display details of file in CauseWay format format.
                                ;
00001737 BA 00000ADEo           	mov	edx,offset CarriageReturn
0000173C E8ED1A0000             	call	StringPrint
                                	;
00001741 668B1D 00000B00o       	mov	bx,EXEHandle
00001748 E8A6190000             	call	CloseFile
0000174D BA 00000100o           	mov	edx,offset EXEFileName
00001752 E8B2180000             	call	OpenFile		;Open the .EXE file.
00001757 66C705 00000004o 06    	mov	ErrorNumber,6	;default to not found.
         00
00001760 0F825E060000           	jc	@@9
00001766 66A3 00000B00o         	mov	EXEHandle,ax
                                	;
0000176C 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001775 668BD8                 	mov	bx,ax
00001778 BA 00000B2Bo           	mov	edx,offset exehdr	;somewhere to put the info.
0000177D B91B000000             	mov	ecx,sizeof MZHdr	;size of it.
00001782 B43F                   	mov	ah,3fh
00001784 CD21                   	int	21h
00001786 0F8238060000           	jc	@@9
0000178C 6683F81B               	cmp	ax,sizeof MZHdr		;did we read right amount?
00001790 0F852E060000           	jnz	@@9
                                	;
                                	;Check for normal MZ header first.
                                	;
00001796 66C705 00000004o 07    	mov	ErrorNumber,7
         00
0000179F 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Normal EXE?
         5A
000017A8 7410                   	jz	@@10
                                	;
                                	;Move back to EXE details.
                                	;
000017AA 66BAE5FF               	mov	dx,-(1bh)
000017AE 66B9FFFF               	mov	cx,-1
000017B2 66B80142               	mov	ax,4201h
000017B6 CD21                   	int	21h		;move back to start of the header.
000017B8 EB34                   	jmp	@@Look3P
000017BA                        @@10:	;
000017BA 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
000017C0 66833D 00000B2Do 00    	cmp	exehdr._Length,0
000017C8 7402                   	je	medexe7		; not rounded if no modulo

000017CA 6648                   	dec	ax		;lose 1 cos its rounded up

000017CC                        medexe7:
000017CC 6603C0                 	add	ax,ax		;mult by 2
000017CF B600                   	mov	dh,0
000017D1 8AD4                   	mov	dl,ah
000017D3 8AE0                   	mov	ah,al
000017D5 8AC6                   	mov	al,dh		;mult by 256=*512
000017D7 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
000017DE 6683D200               	adc	dx,0		;add any carry to dx
000017E2 668BC8                 	mov	cx,ax
000017E5 6687CA                 	xchg	cx,dx		;swap round for DOS.
000017E8 66B80042               	mov	ax,4200h		;set absolute position.
000017EC CD21                   	int	21h
                                	;
000017EE                        @@Look3P:
000017EE 66C705 00000004o 08    	mov	ErrorNumber,8
         00
000017F7 668B1D 00000B00o       	mov	bx,EXEHandle
000017FE BA 00000B4Eo           	mov	edx,offset NewHeader	;somewhere to put the info.
00001803 66B94000               	mov	cx,size NewHeaderStruc	;size of it.
00001807 B43F                   	mov	ah,3fh
00001809 CD21                   	int	21h
0000180B 0F82B3050000           	jc	@@9
00001811 66C705 00000004o 07    	mov	ErrorNumber,7
         00
0000181A 6683F840               	cmp	ax,size NewHeaderStruc	;did we read right amount?
0000181E 0F85A0050000           	jnz	@@9
00001824 66813D 00000B4Eo 33    	cmp	word ptr[NewHeader],'P3'	;ID ok?
         50
0000182D 0F8591050000           	jnz	@@9
                                	;
00001833 BE 00000B4Eo           	mov	esi,offset NewHeader	;somewhere to put the info.
00001838 BA 00003660o           	mov	edx,offset bit16text
0000183D F7462001000000         	test	[esi].NewHeaderStruc.NewFlags,1
00001844 7513                   	jnz	@@its16
00001846 BA 00003676o           	mov	edx,offset bit32text
0000184B F7462000000100         	test	[esi].NewHeaderStruc.NewFlags,65536
00001852 7405                   	jz	@@its16
00001854 BA 0000368Co           	mov	edx,offset bitdualtext
00001859                        @@its16:
00001859 B409                   	mov	ah,9
0000185B CD21                   	int	21h
                                	;
0000185D BE 00000B4Eo           	mov	esi,offset NewHeader	;somewhere to put the info.
00001862 BA 000036A5o           	mov	edx,offset SpeedLoadText
00001867 F7462000000040         	test	[esi].NewHeaderStruc.NewFlags,1 shl 30
0000186E 7505                   	jnz	@@nospeed
00001870 BA 00000AE1o           	mov	edx,offset CarriageReturn2
00001875                        @@NoSpeed:
00001875 B409                   	mov	ah,9
00001877 CD21                   	int	21h

                                	;
00001879 BA 000036BDo           	mov	edx,offset NewSizeT
0000187E E8AB190000             	call	StringPrint
00001883 BE 00000B4Eo           	mov	esi,offset NewHeader
00001888 8B4602                 	mov	eax,[esi].NewHeaderStruc.NewSize
0000188B B908000000             	mov	ecx,8
00001890 BF 00000180o           	mov	edi,offset LineBuffer
00001895 E82B050000             	call	Bin2Hex
0000189A C60700                 	mov	byte ptr[edi],0
0000189D BA 00000180o           	mov	edx,offset LineBuffer
000018A2 E887190000             	call	StringPrint
000018A7 BA 00000ADEo           	mov	edx,offset CarriageReturn
000018AC E87D190000             	call	StringPrint
                                	;
000018B1 BA 000036CBo           	mov	edx,offset NewLengthT
000018B6 E873190000             	call	StringPrint
000018BB BE 00000B4Eo           	mov	esi,offset NewHeader
000018C0 8B4606                 	mov	eax,[esi].NewHeaderStruc.NewLength
000018C3 B908000000             	mov	ecx,8
000018C8 BF 00000180o           	mov	edi,offset LineBuffer
000018CD E8F3040000             	call	Bin2Hex
000018D2 C60700                 	mov	byte ptr[edi],0
000018D5 BA 00000180o           	mov	edx,offset LineBuffer
000018DA E84F190000             	call	StringPrint
000018DF BA 00000ADEo           	mov	edx,offset CarriageReturn
000018E4 E845190000             	call	StringPrint
                                	;
000018E9 BA 000036D9o           	mov	edx,offset NewAllocT
000018EE E83B190000             	call	StringPrint
000018F3 BE 00000B4Eo           	mov	esi,offset NewHeader
000018F8 8B460A                 	mov	eax,[esi].NewHeaderStruc.NewAlloc
000018FB B908000000             	mov	ecx,8
00001900 BF 00000180o           	mov	edi,offset LineBuffer
00001905 E8BB040000             	call	Bin2Hex
0000190A C60700                 	mov	byte ptr[edi],0
0000190D BA 00000180o           	mov	edx,offset LineBuffer
00001912 E817190000             	call	StringPrint
00001917 BA 00000ADEo           	mov	edx,offset CarriageReturn
0000191C E80D190000             	call	StringPrint
                                	;
00001921 BA 000036E7o           	mov	edx,offset NewSegmentsT
00001926 E803190000             	call	StringPrint
0000192B BE 00000B4Eo           	mov	esi,offset NewHeader
00001930 0FB7460E               	movzx	eax,[esi].NewHeaderStruc.NewSegments
00001934 B908000000             	mov	ecx,8
00001939 BF 00000180o           	mov	edi,offset LineBuffer
0000193E E882040000             	call	Bin2Hex
00001943 C60700                 	mov	byte ptr[edi],0
00001946 BA 00000180o           	mov	edx,offset LineBuffer
0000194B E8DE180000             	call	StringPrint
00001950 BA 00000ADEo           	mov	edx,offset CarriageReturn
00001955 E8D4180000             	call	StringPrint
                                	;
0000195A BA 000036F5o           	mov	edx,offset NewRelocsT
0000195F E8CA180000             	call	StringPrint
00001964 BE 00000B4Eo           	mov	esi,offset NewHeader
00001969 8B4610                 	mov	eax,[esi].NewHeaderStruc.NewRelocs
0000196C B908000000             	mov	ecx,8
00001971 BF 00000180o           	mov	edi,offset LineBuffer
00001976 E84A040000             	call	Bin2Hex
0000197B C60700                 	mov	byte ptr[edi],0
0000197E BA 00000180o           	mov	edx,offset LineBuffer
00001983 E8A6180000             	call	StringPrint
00001988 BA 00000ADEo           	mov	edx,offset CarriageReturn
0000198D E89C180000             	call	StringPrint
                                	;
00001992 BA 00003703o           	mov	edx,offset NewEntryEIPT
00001997 E892180000             	call	StringPrint
0000199C BE 00000B4Eo           	mov	esi,offset NewHeader
000019A1 8B4614                 	mov	eax,[esi].NewHeaderStruc.NewEntryEIP
000019A4 B908000000             	mov	ecx,8
000019A9 BF 00000180o           	mov	edi,offset LineBuffer
000019AE E812040000             	call	Bin2Hex
000019B3 C60700                 	mov	byte ptr[edi],0
000019B6 BA 00000180o           	mov	edx,offset LineBuffer
000019BB E86E180000             	call	StringPrint
000019C0 BA 00000ADEo           	mov	edx,offset CarriageReturn
000019C5 E864180000             	call	StringPrint
                                	;
000019CA BA 00003711o           	mov	edx,offset NewEntryCSt
000019CF E85A180000             	call	StringPrint
000019D4 BE 00000B4Eo           	mov	esi,offset NewHeader
000019D9 0FB74618               	movzx	eax,[esi].NewHeaderStruc.NewEntryCS
000019DD B908000000             	mov	ecx,8
000019E2 BF 00000180o           	mov	edi,offset LineBuffer
000019E7 E8D9030000             	call	Bin2Hex
000019EC C60700                 	mov	byte ptr[edi],0
000019EF BA 00000180o           	mov	edx,offset LineBuffer
000019F4 E835180000             	call	StringPrint
000019F9 BA 00000ADEo           	mov	edx,offset CarriageReturn
000019FE E82B180000             	call	StringPrint
                                	;
00001A03 BA 0000371Fo           	mov	edx,offset NewEntryESPt
00001A08 E821180000             	call	StringPrint
00001A0D BE 00000B4Eo           	mov	esi,offset NewHeader
00001A12 8B461A                 	mov	eax,[esi].NewHeaderStruc.NewEntryESP
00001A15 B908000000             	mov	ecx,8
00001A1A BF 00000180o           	mov	edi,offset LineBuffer
00001A1F E8A1030000             	call	Bin2Hex
00001A24 C60700                 	mov	byte ptr[edi],0
00001A27 BA 00000180o           	mov	edx,offset LineBuffer
00001A2C E8FD170000             	call	StringPrint
00001A31 BA 00000ADEo           	mov	edx,offset CarriageReturn
00001A36 E8F3170000             	call	StringPrint
                                	;
00001A3B BA 0000372Do           	mov	edx,offset NewEntrySSt
00001A40 E8E9170000             	call	StringPrint
00001A45 BE 00000B4Eo           	mov	esi,offset NewHeader
00001A4A 0FB7461E               	movzx	eax,[esi].NewHeaderStruc.NewEntrySS
00001A4E B908000000             	mov	ecx,8
00001A53 BF 00000180o           	mov	edi,offset LineBuffer
00001A58 E868030000             	call	Bin2Hex
00001A5D C60700                 	mov	byte ptr[edi],0
00001A60 BA 00000180o           	mov	edx,offset LineBuffer
00001A65 E8C4170000             	call	StringPrint
00001A6A BA 00000ADEo           	mov	edx,offset CarriageReturn
00001A6F E8BA170000             	call	StringPrint
                                	;
00001A74 BA 0000373Bo           	mov	edx,offset NewEntryAutoSS
00001A79 E8B0170000             	call	StringPrint
00001A7E BE 00000B4Eo           	mov	esi,offset NewHeader
00001A83 8B4624                 	mov	eax,[esi].NewHeaderStruc.NewAutoStack
00001A86 B908000000             	mov	ecx,8
00001A8B BF 00000180o           	mov	edi,offset LineBuffer
00001A90 E830030000             	call	Bin2Hex
00001A95 C60700                 	mov	byte ptr[edi],0
00001A98 BA 00000180o           	mov	edx,offset LineBuffer
00001A9D E88C170000             	call	StringPrint
00001AA2 BA 00000ADEo           	mov	edx,offset CarriageReturn
00001AA7 E882170000             	call	StringPrint
                                	;
                                	;See if segment/relocation details are required.
                                	;
00001AAC 8B35 00003B20o         	mov	esi,dword ptr[OptionTable+128+("I"*4)]
00001AB2 0BF6                   	or	esi,esi
00001AB4 0F8401030000           	jz	@@8
                                	;
00001ABA BA 00003749o           	mov	edx,offset ReadingMainText
00001ABF E86A170000             	call	StringPrint
                                	;
                                	;Get segment definition table memory.
                                	;
00001AC4 66C705 00000004o 02    	mov	ErrorNumber,2
         00
00001ACD BE 00000B4Eo           	mov	esi,offset NewHeader

                                ;	movzx	ebx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
                                ;	shl	ebx,3		;8 bytes per entry.
                                ;	sys	GetMemNear
00001AD2 0FB74E0E               	movzx	ecx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
00001AD6 C1E103                 	shl	ecx,3		;8 bytes per entry.
00001AD9 E89C130000             	call	GetMemLinear32
00001ADE 0F82E0020000           	jc	@@9
00001AE4 8935 00000B17o         	mov	SegmentList,esi
                                	;
                                	;Read segment definitions.
                                	;
00001AEA 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001AF3 BE 00000B4Eo           	mov	esi,offset NewHeader
00001AF8 0FB74E0E               	movzx	ecx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
00001AFC C1E103                 	shl	ecx,3		;8 bytes per entry.
00001AFF 668B1D 00000B00o       	mov	bx,EXEHandle
00001B06 8B3D 00000B17o         	mov	edi,SegmentList
00001B0C 51                     	push	ecx
00001B0D E86D150000             	call	ReadFile
00001B12 59                     	pop	ecx
00001B13 0F82AB020000           	jc	@@9
00001B19 3BC1                   	cmp	eax,ecx
00001B1B 0F85A3020000           	jnz	@@9
                                	;
                                	;Get relocation table memory.
                                	;
00001B21 66C705 00000004o 02    	mov	ErrorNumber,2
         00
00001B2A BE 00000B4Eo           	mov	esi,offset NewHeader

                                ;	mov	ebx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations
                                ;	shl	ebx,2		;4 bytes per entry.
                                ;	sys	GetMemNear
00001B2F 8B4E10                 	mov	ecx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations
00001B32 C1E102                 	shl	ecx,2		;4 bytes per entry.
00001B35 E840130000             	call	GetMemLinear32
00001B3A 0F8284020000           	jc	@@9
00001B40 8935 00000B27o         	mov	RelocSegment,esi
                                	;
                                	;Read relocations.
                                	;
00001B46 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001B4F BE 00000B4Eo           	mov	esi,offset NewHeader
00001B54 8B4E10                 	mov	ecx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations.
00001B57 C1E102                 	shl	ecx,2		;4 bytes per entry.
00001B5A 668B1D 00000B00o       	mov	bx,EXEHandle
00001B61 8B3D 00000B27o         	mov	edi,RelocSegment
00001B67 51                     	push	ecx
00001B68 E812150000             	call	ReadFile
00001B6D 59                     	pop	ecx
00001B6E 0F8250020000           	jc	@@9
00001B74 3BC1                   	cmp	eax,ecx
00001B76 0F8548020000           	jnz	@@9
                                	;
                                	;Get image memory.
                                	;
00001B7C 66C705 00000004o 02    	mov	ErrorNumber,2
         00
00001B85 BE 00000B4Eo           	mov	esi,offset NewHeader

                                ;	mov	ebx,[esi].NewHeaderStruc.NewAlloc	;get memory size required.
                                ;	sys	GetMemNear
00001B8A 8B4E0A                 	mov	ecx,[esi].NewHeaderStruc.NewAlloc	;get memory size required.
00001B8D E8E8120000             	call	GetMemLinear32
00001B92 0F822C020000           	jc	@@9
00001B98 8935 00000B23o         	mov	EXESegment,esi
                                	;
00001B9E 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001BA7 BE 00000B4Eo           	mov	esi,offset NewHeader
                                if 0
                                endif    
00001BAC                        @@NotComp:
00001BAC 8B3D 00000B23o         	mov	edi,EXESegment
00001BB2 8B4E06                 	mov	ecx,[esi].NewHeaderStruc.NewLength	;get image length.
00001BB5 668B1D 00000B00o       	mov	bx,EXEHandle
00001BBC 51                     	push	ecx
00001BBD E8BD140000             	call	ReadFile		;read the file.
00001BC2 59                     	pop	ecx
00001BC3 0F82FB010000           	jc	@@9		;problems problems.
00001BC9 3BC1                   	cmp	eax,ecx		;did we get right amount?
00001BCB 0F85F3010000           	jnz	@@9
                                	;
00001BD1                        @@ImageLoaded:
00001BD1 668B1D 00000B00o       	mov	bx,EXEHandle
00001BD8 E816150000             	call	CloseFile
00001BDD 66C705 00000B00o 00    	mov	EXEHandle,0
         00
                                	;
                                	;Check if seg details needed.
                                	;
00001BE6 8B35 00003B20o         	mov	esi,dword ptr[OptionTable+128+("I"*4)]
00001BEC                        @@5:
00001BEC AC                     	lodsb
00001BED 0AC0                   	or	al,al
00001BEF 0F84B3000000           	jz	@@6
00001BF5 E875120000             	call	UpperChar
00001BFA 3C53                   	cmp	al,"S"
00001BFC 75EE                   	jnz	@@5
                                	;
                                	;Display header.
                                	;
00001BFE BA 0000377Bo           	mov	edx,offset SegmentStuff
00001C03 E826160000             	call	StringPrint
                                	;
                                	;Display details.
                                	;
00001C08 BE 00000B4Eo           	mov	esi,offset NewHeader
00001C0D 0FB74E0E               	movzx	ecx,[esi].NewHeaderStruc.NewSegments	;get number of segments.
00001C11 8B35 00000B17o         	mov	esi,SegmentList
00001C17 33C0                   	xor	eax,eax
00001C19                        @@0:
00001C19 50                     	push	eax
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001C1A 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001C1B 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001C1C BF 00000180o           	mov	edi,offset LineBuffer
00001C21 B904000000             	mov	ecx,4
00001C26 E89A010000             	call	Bin2Hex
00001C2B C60720                 	mov	byte ptr[edi],' '
00001C2E 47                     	inc	edi
00001C2F 8B06                   	mov	eax,0[esi]
00001C31 B908000000             	mov	ecx,8
00001C36 E88A010000             	call	Bin2Hex
00001C3B C60720                 	mov	byte ptr[edi],' '
00001C3E 47                     	inc	edi
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001C3F 5E                  2  	POP	esi				;POP THE REGISTER
00001C40 59                  2  	POP	ecx				;POP THE REGISTER
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001C41 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001C42 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001C43 8B4604                 	mov	eax,4[esi]
00001C46 25FFFF0F00             	and	eax,0fffffh		;mask to 20 bits.
00001C4B F7460400001000         	test	dword ptr[esi+4],1 shl 20	;G bit set?
00001C52 7408                   	jz	@@1
00001C54 C1E00C                 	shl	eax,12
00001C57 0DFF0F0000             	or	eax,4095
00001C5C                        @@1:
00001C5C B908000000             	mov	ecx,8
00001C61 E85F010000             	call	Bin2Hex
00001C66 C60720                 	mov	byte ptr[edi],' '
00001C69 C6470100               	mov	byte ptr[edi+1],0
00001C6D BA 00000180o           	mov	edx,offset LineBuffer
00001C72 E8B7150000             	call	StringPrint
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001C77 5E                  2  	POP	esi				;POP THE REGISTER
00001C78 59                  2  	POP	ecx				;POP THE REGISTER
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001C79 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001C7A 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001C7B 8B4604                 	mov	eax,4[esi]
00001C7E C1E815                 	shr	eax,21		;move type into useful place.
00001C81 83E00F                 	and	eax,0fh		;isolate type.
00001C84 8B1485 00000E28o       	mov	edx,[SegClassList][eax*4]
00001C8B E89E150000             	call	StringPrint
00001C90 BA 00000ADEo           	mov	edx,offset CarriageReturn
00001C95 E894150000             	call	StringPrint
                                	;
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001C9A 5E                  2  	POP	esi				;POP THE REGISTER
00001C9B 59                  2  	POP	ecx				;POP THE REGISTER
00001C9C 58                     	pop	eax
00001C9D 40                     	inc	eax
00001C9E 83C608                 	add	esi,8
00001CA1 49                     	dec	ecx
00001CA2 0F8571FFFFFF           	jnz	@@0
                                	;
                                	;See if relocation details are needed.
                                	;
00001CA8                        @@6:
00001CA8 8B35 00003B20o         	mov	esi,dword ptr[OptionTable+128+("I"*4)]
00001CAE                        @@7:
00001CAE AC                     	lodsb
00001CAF 0AC0                   	or	al,al
00001CB1 0F8404010000           	jz	@@8
00001CB7 E8B3110000             	call	UpperChar
00001CBC 3C52                   	cmp	al,"R"
00001CBE 75EE                   	jnz	@@7
                                	;
                                	;Display header.
                                	;
00001CC0 BA 000037F8o           	mov	edx,offset RelocStuff
00001CC5 E864150000             	call	StringPrint
                                	;
                                	;Display details.
                                	;
00001CCA BE 00000B4Eo           	mov	esi,offset NewHeader
00001CCF 8B4E10                 	mov	ecx,[esi].NewHeaderStruc.NewRelocs	;get number of relocations.
00001CD2 8B35 00000B27o         	mov	esi,RelocSegment
00001CD8 33C0                   	xor	eax,eax
00001CDA                        @@2:
00001CDA 50                     	push	eax
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001CDB 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001CDC 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001CDD BF 00000180o           	mov	edi,offset LineBuffer
00001CE2 B904000000             	mov	ecx,4
00001CE7 E8D9000000             	call	Bin2Hex
00001CEC C60720                 	mov	byte ptr[edi],' '
00001CEF 47                     	inc	edi
00001CF0 8B06                   	mov	eax,[esi]
00001CF2 C1E81C                 	shr	eax,28
00001CF5 0430                   	add	al,"0"
00001CF7 8807                   	mov	byte ptr[edi],al
00001CF9 47                     	inc	edi
00001CFA C60720                 	mov	byte ptr[edi]," "
00001CFD 47                     	inc	edi
00001CFE 8B06                   	mov	eax,[esi]
00001D00 25FFFFFF0F             	and	eax,0FFFFFFFh
00001D05 B908000000             	mov	ecx,8
00001D0A E8B6000000             	call	Bin2Hex
00001D0F C60720                 	mov	byte ptr[edi],' '
00001D12 47                     	inc	edi
00001D13 C60720                 	mov	byte ptr[edi],' '
00001D16 47                     	inc	edi
00001D17 C60720                 	mov	byte ptr[edi],' '
00001D1A 47                     	inc	edi
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001D1B 5E                  2  	POP	esi				;POP THE REGISTER
00001D1C 59                  2  	POP	ecx				;POP THE REGISTER
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001D1D 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001D1E 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001D1F 8B36                   	mov	esi,[esi]
00001D21 8BC6                   	mov	eax,esi
00001D23 C1E81C                 	shr	eax,28
00001D26 81E6FFFFFF0F           	and	esi,0FFFFFFFh
00001D2C BB 00000B4Eo           	mov	ebx,offset NewHeader
00001D31 3B7306                 	cmp	esi,[ebx].NewHeaderStruc.NewLength	;check against image size.
00001D34 7209                   	jc	@@3
00001D36                        @@RelInv:
00001D36 BE 00003865o           	mov	esi,offset invalidtext
00001D3B A5                     	movsd
00001D3C A5                     	movsd
00001D3D EB57                   	jmp	@@4
                                	;
00001D3F                        @@3:
00001D3F 0335 00000B23o         	add	esi,EXESegment
00001D45 0BC0                   	or	eax,eax
00001D47 7421                   	jz	@@Seg16
00001D49 48                     	dec	eax
00001D4A 7402                   	jz	@@Offset32
00001D4C EBE8                   	jmp	@@RelInv
                                	;
00001D4E                        @@Offset32:
00001D4E 8B06                   	mov	eax,[esi]
00001D50 B908000000             	mov	ecx,8
00001D55 E86B000000             	call	Bin2Hex
00001D5A C70720202020           	mov	dword ptr[edi],"    "
00001D60 83C704                 	add	edi,4
00001D63 3B4306                 	cmp	eax,[ebx].NewHeaderStruc.NewLength	;check against image size.
00001D66 73CE                   	jnc	@@RelInv
00001D68 EB2C                   	jmp	@@4
                                	;
00001D6A                        @@Seg16:
00001D6A 0FB706                 	movzx	eax,word ptr[esi]
00001D6D 6650                   	push	ax
00001D6F B908000000             	mov	ecx,8
00001D74 E84C000000             	call	Bin2Hex
00001D79 C70720202020           	mov	dword ptr[edi],"    "
00001D7F 83C704                 	add	edi,4
00001D82 6658                   	pop	ax
00001D84 BB 00000B4Eo           	mov	ebx,offset NewHeader
00001D89 663B430E               	cmp	ax,[ebx].NewHeaderStruc.NewSegments
00001D8D 7207                   	jc	@@4
00001D8F BE 00003865o           	mov	esi,offset invalidtext
00001D94 A5                     	movsd
00001D95 A5                     	movsd
                                	;
00001D96                        @@4:
00001D96 C60700                 	mov	byte ptr[edi],0
00001D99 BA 00000180o           	mov	edx,offset LineBuffer
00001D9E E88B140000             	call	StringPrint
00001DA3 BA 00000ADEo           	mov	edx,offset CarriageReturn
00001DA8 E881140000             	call	StringPrint
                                	;
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001DAD 5E                  2  	POP	esi				;POP THE REGISTER
00001DAE 59                  2  	POP	ecx				;POP THE REGISTER
00001DAF 58                     	pop	eax
00001DB0 40                     	inc	eax
00001DB1 83C604                 	add	esi,4
00001DB4 49                     	dec	ecx
00001DB5 0F851FFFFFFF           	jnz	@@2
                                	;
00001DBB                        @@8:
00001DBB 66C705 00000004o 00    	mov	ErrorNumber,0
         00
00001DC4                        @@9:
00001DC4 C3                     	ret
00001DC5                        NewExeInfo	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=-=
00001DC5                        Bin2Hex	proc	near
                                ;
                                ;Convert number into ASCII Hex version.
                                ;
                                ;On Entry:-
                                ;
                                ;EAX	- Number to convert.
                                ;ECX	- Digits to do.
                                ;EDI	- Buffer to put string in.
                                ;
                                	pushm	edi,ecx
                             1  	IRP	X,<edi,ecx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001DC5 57                  2  	PUSH	edi			;SAVE THE REGISTER
00001DC6 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00001DC7 BB 00001DE3o           	mov	ebx,offset HexTable
00001DCC 03F9                   	add	edi,ecx
00001DCE 4F                     	dec	edi
00001DCF 8BD0                   	mov	edx,eax
00001DD1 8AC2                   @@0:	mov	al,dl
00001DD3 C1EA04                 	shr	edx,4
00001DD6 240F                   	and	al,15
00001DD8 D7                     	xlat
00001DD9 8807                   	mov	[edi],al
00001DDB 4F                     	dec	edi
00001DDC E2F3                   	loop	@@0
                                	popm	edi,ecx
                             1  	IRP	X,<,,,,,,,,ecx,edi> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001DDE 59                  2  	POP	ecx				;POP THE REGISTER
00001DDF 5F                  2  	POP	edi				;POP THE REGISTER
00001DE0 03F9                   	add	edi,ecx
00001DE2 C3                     	ret
00001DE3 303132333435363738     HexTable	db '0123456789ABCDEF'
00001DF3                        Bin2Hex	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
00001DF3                        ProcessFile	proc	near
                                ;
                                ;Generate new style relocation table and write new .EXE file.
                                ;
                                	@dprintf 1,<"ProcessFile start",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00001DF3 E86AE2FFFF          1  	call dprintf
00001DF8 50726F636573734669  1  	db "ProcessFile start",10,0
00001E0B 668B1D 00000B00o       	mov	bx,EXEHandle
00001E12 E8DC120000             	call	CloseFile
00001E17 BA 00000100o           	mov	edx,offset EXEFileName
00001E1C E8E8110000             	call	OpenFile		;Open the .EXE file.
00001E21 66C705 00000004o 06    	mov	ErrorNumber,6	;default to not found.
         00
00001E2A 0F8215070000           	jc	@@9
00001E30 66A3 00000B00o         	mov	EXEHandle,ax
                                	;
                                	;Create temp file.
                                	;
00001E36 BA 00000B08o           	mov	edx,offset TempFileName	;get DOS to give us a temp file.
00001E3B E8FC110000             	call	CreateFile
00001E40 66C705 00000004o 13    	mov	ErrorNumber,19	;default to can't create output.
         00
00001E49 0F82F6060000           	jc	@@9		;oops.
00001E4F 66A3 00000B15o         	mov	TempHandle,ax
                                	;
                                	;Copy 386SHELL to temp file.
                                	;
00001E55 803D 000039BEo 00      	cmp	OptionTable+'B',0
00001E5C 0F84D8010000           	jz	@@NoBind
                                	;
00001E62 BA 00000080o           	mov	edx,offset SHELLFileName	;get extender stub CWSTUB.EXE
00001E67 E89D110000             	call	OpenFile
00001E6C 66C705 00000004o 09    	mov	ErrorNumber,9	;no stub file.
         00
00001E75 0F82CA060000           	jc	@@9
00001E7B 66A3 00000AFAo         	mov	SHELLHandle,ax
                                	;
00001E81 BA 00000A62o           	mov	edx,offset ProcessStubText
00001E86 E8A3130000             	call	StringPrint
                                	;
00001E8B BA 00000B2Bo           	mov	edx,offset exehdr
00001E90 B91B000000             	mov	ecx,sizeof MZHdr
00001E95 668B1D 00000AFAo       	mov	bx,SHELLHandle
00001E9C B43F                   	mov	ah,3fh
00001E9E CD21                   	int	21h		;read the .EXE header.
00001EA0 66C705 00000004o 08    	mov	ErrorNumber,8	;default to IO error.
         00
00001EA9 0F8296060000           	jc	@@9
00001EAF 66C705 00000004o 09    	mov	ErrorNumber,9	;stub file error.
         00
00001EB8 6683F81B               	cmp	ax,sizeof MZHdr
00001EBC 0F8583060000           	jnz	@@9
00001EC2 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Correct ID?
         5A
00001ECB 0F8574060000           	jnz	@@9
                                	@dprintf 1,<"ProcessFile - stub file exists and has correct header",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00001ED1 E88CE1FFFF          1  	call dprintf
00001ED6 50726F636573734669  1  	db "ProcessFile - stub file exists and has correct header",10,0
                                	;
00001F0D 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
00001F13 66833D 00000B2Do 00    	cmp	exehdr._Length,0
00001F1B 7402                   	je	medexe8		; not rounded if no modulo

00001F1D 6648                   	dec	ax		;lose 1 cos its rounded up

00001F1F                        medexe8:
00001F1F 6603C0                 	add	ax,ax		;mult by 2
00001F22 B600                   	mov	dh,0
00001F24 8AD4                   	mov	dl,ah
00001F26 8AE0                   	mov	ah,al
00001F28 8AC6                   	mov	al,dh		;mult by 256=*512
00001F2A 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
00001F31 6683D200               	adc	dx,0		;add any carry to dx
00001F35 668BC8                 	mov	cx,ax
                                	pushm	cx,dx
                             1  	IRP	X,<cx,dx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001F38 6651                2  	PUSH	cx			;SAVE THE REGISTER
00001F3A 6652                2  	PUSH	dx			;SAVE THE REGISTER
00001F3C 66BAE5FF               	mov	dx,-1bh
00001F40 66B9FFFF               	mov	cx,-1
00001F44 668B1D 00000AFAo       	mov	bx,SHELLHandle
00001F4B 66B80142               	mov	ax,4201h
00001F4F CD21                   	int	21h		;move back to start of 386SHELL.
                                	popm	cx,dx
                             1  	IRP	X,<,,,,,,,,dx,cx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001F51 665A                2  	POP	dx				;POP THE REGISTER
00001F53 6659                2  	POP	cx				;POP THE REGISTER
                                	;
                                	;Get memory for shell.
                                	;
00001F55 8BDA                   	mov	ebx,edx
00001F57 C1E310                 	shl	ebx,16
00001F5A 668BD9                 	mov	bx,cx

                                ;	push	ebx
                                ;	sys	GetMemNear		;get memory for shell.
                                ;	pop	ebx
00001F5D 8BCB                   	mov	ecx,ebx
00001F5F E8160F0000             	call	GetMemLinear32
00001F64 66C705 00000004o 02    	mov	ErrorNumber,2
         00
00001F6D 0F82D2050000           	jc	@@9
                                	@dprintf 1,<"ProcessFile - memory alloc ok",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00001F73 E8EAE0FFFF          1  	call dprintf
00001F78 50726F636573734669  1  	db "ProcessFile - memory alloc ok",10,0
                                	;
                                	;Read shell into memory.
                                	;
                                	pushm	ebx,esi
                             1  	IRP	X,<ebx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001F97 53                  2  	PUSH	ebx			;SAVE THE REGISTER
00001F98 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001F99 8BCB                   	mov	ecx,ebx
00001F9B 8BFE                   	mov	edi,esi
00001F9D 668B1D 00000AFAo       	mov	bx,SHELLHandle
00001FA4 E8D6100000             	call	ReadFile
                                	popm	ebx,esi
                             1  	IRP	X,<,,,,,,,,esi,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001FA9 5E                  2  	POP	esi				;POP THE REGISTER
00001FAA 5B                  2  	POP	ebx				;POP THE REGISTER
00001FAB 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00001FB4 0F828B050000           	jc	@@9
00001FBA 3BC3                   	cmp	eax,ebx		;did we read enough?
00001FBC 0F8583050000           	jnz	@@9
                                	@dprintf 1,<"ProcessFile - stub read ok",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00001FC2 E89BE0FFFF          1  	call dprintf
00001FC7 50726F636573734669  1  	db "ProcessFile - stub read ok",10,0
                                	pushm	ebx,esi
                             1  	IRP	X,<ebx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001FE3 53                  2  	PUSH	ebx			;SAVE THE REGISTER
00001FE4 56                  2  	PUSH	esi			;SAVE THE REGISTER
                                	;
                                	;Write shell to temp.
                                	;
                                	popm	ebx,esi
                             1  	IRP	X,<,,,,,,,,esi,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001FE5 5E                  2  	POP	esi				;POP THE REGISTER
00001FE6 5B                  2  	POP	ebx				;POP THE REGISTER
                                	pushm	ebx,esi
                             1  	IRP	X,<ebx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00001FE7 53                  2  	PUSH	ebx			;SAVE THE REGISTER
00001FE8 56                  2  	PUSH	esi			;SAVE THE REGISTER
00001FE9 8BCB                   	mov	ecx,ebx
00001FEB 668B1D 00000B15o       	mov	bx,TEMPHandle
00001FF2 E8C2100000             	call	WriteFile
                                	popm	ebx,esi
                             1  	IRP	X,<,,,,,,,,esi,ebx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00001FF7 5E                  2  	POP	esi				;POP THE REGISTER
00001FF8 5B                  2  	POP	ebx				;POP THE REGISTER
00001FF9 0F8246050000           	jc	@@9
00001FFF 3BC3                   	cmp	eax,ebx		;did we write enough?
00002001 0F853E050000           	jnz	@@9
                                ;	sys	RelMemNear		;release memory now.
00002007 E88B0E0000             	call	RelMemLinear32
                                	@dprintf 1,<"ProcessFile - stub write to tmp file ok",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
0000200C E851E0FFFF          1  	call dprintf
00002011 50726F636573734669  1  	db "ProcessFile - stub write to tmp file ok",10,0

                                	;
0000203A                        @@NoBind:	;Process .EXE relocation table and produce new format header.
                                	;
0000203A BA 00000B2Bo           	mov	edx,offset exehdr
0000203F B91B000000             	mov	ecx,sizeof MZHdr
00002044 668B1D 00000B00o       	mov	bx,EXEHandle
0000204B B43F                   	mov	ah,3fh
0000204D CD21                   	int	21h		;read the .EXE header.
0000204F 66C705 00000004o 08    	mov	ErrorNumber,8	;default to IO error.
         00
00002058 0F82E7040000           	jc	@@9
0000205E 66C705 00000004o 07    	mov	ErrorNumber,7	;bad header.
         00
00002067 6683F81B               	cmp	ax,sizeof MZHdr
0000206B 0F85D4040000           	jnz	@@9
00002071 66813D 00000B2Bo 4D    	cmp	exehdr.Signature,'ZM'	;Correct ID?
         5A
0000207A 0F85C5040000           	jnz	@@9

                                	@dprintf 1,<"ProcessFile - .exe read ok",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00002080 E8DDDFFFFF          1  	call dprintf
00002085 50726F636573734669  1  	db "ProcessFile - .exe read ok",10,0
                                	;
                                	;Get header size in bytes.
                                	;
000020A1 668B1D 00000B33o       	mov	bx,exehdr.HeaderSize	;Work out header size.
000020A8 6633C9                 	xor	cx,cx		;/
000020AB 6603DB                 	add	bx,bx		;/
000020AE 6683D100               	adc	cx,0		;/
000020B2 6603DB                 	add	bx,bx		;/
000020B5 6683D100               	adc	cx,0		;/
000020B9 6603DB                 	add	bx,bx		;/
000020BC 6683D100               	adc	cx,0		;/
000020C0 6603DB                 	add	bx,bx		;/
000020C3 6683D100               	adc	cx,0		;/
000020C7 66891D 00000B46o       	mov	word ptr[ExeSize1],bx	;/
000020CE 66890D 00000B48o       	mov	word ptr[ExeSize1+2],cx	;/
                                	;
                                	;Get exe image size in bytes.
                                	;
000020D5 66A1 00000B2Fo         	mov	ax,exehdr._Length+2	;get length in 512 byte blocks
000020DB 66833D 00000B2Do 00    	cmp	exehdr._Length,0
000020E3 7402                   	je	medexe9		; not rounded if no modulo

000020E5 6648                   	dec	ax		;lose 1 cos its rounded up

000020E7                        medexe9:
000020E7 6603C0                 	add	ax,ax		;mult by 2
000020EA B600                   	mov	dh,0
000020EC 8AD4                   	mov	dl,ah
000020EE 8AE0                   	mov	ah,al
000020F0 8AC6                   	mov	al,dh		;mult by 256=*512
000020F2 660305 00000B2Do       	add	ax,exehdr._Length	;add length mod 512
000020F9 6683D200               	adc	dx,0		;add any carry to dx
000020FD 662BC3                 	sub	ax,bx		;remove header total size.
00002100 661BD1                 	sbb	dx,cx		;/
00002103 66A3 00000B4Ao         	mov	word ptr[ExeSize2],ax	;/
00002109 668915 00000B4Co       	mov	word ptr[ExeSize2+2],dx	;/
                                	;
00002110 C1E210                 	shl	edx,16
00002113 668BD0                 	mov	dx,ax
00002116 BE 00000B4Eo           	mov	esi,offset NewHeader
0000211B 895606                 	mov	[esi].NewHeaderStruc.NewLength,edx	;store EXE image length in the header.
0000211E A1 00000B1Fo           	mov	eax,SegmentTotal
00002123 6689460E               	mov	[esi].NewHeaderStruc.NewSegments,ax
00002127 0FB705 00000B31o       	movzx	eax,exehdr.RelocNum
0000212E 894610                 	mov	[esi].NewHeaderStruc.NewRelocs,eax
                                	;
00002131 0FB705 00000B3Fo       	movzx	eax,exehdr.EntryIP
00002138 894614                 	mov	[esi].NewHeaderStruc.NewEntryEIP,eax	;setup entry offset.
                                	;
0000213B 803D 000039D6o 00      	cmp	OptionTable+'Z',0
00002142 7409                   	jz	@@NormStack
00002144 803D 000039CAo 00      	cmp	OptionTable+'N',0
0000214B 750A                   	jnz	@@GotStackNear
0000214D                        @@NormStack:
0000214D 0FB705 00000B3Bo       	movzx	eax,exehdr.EntrySP
00002154 89461A                 	mov	[esi].NewHeaderStruc.NewEntryESP,eax	;setup ESP offset.
00002157                        @@GotStackNear: ;
00002157 0FB705 00000B41o       	movzx	eax,exehdr.EntryCS	;get entry CS.
0000215E 8B3D 00000B17o         	mov	edi,SegmentList	;make segment details addressable.
00002164 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;get number of entries to check.
0000216A 6633D2                 	xor	dx,dx		;reset entry number.
0000216D 803D 000039CAo 00      	cmp	OptionTable+'N',0
00002174 7405                   	jz	@@4
00002176 83C710                 	add	edi,16
00002179 6642                   	inc	dx
0000217B                        @@4:
0000217B 8B1F                   	mov	ebx,[edi+0]		;get segment base.
0000217D C1EB04                 	shr	ebx,4		;convert to paragraph.
00002180 3BC3                   	cmp	eax,ebx		;this the one we're after?
00002182 7410                   	jz	@@5
00002184 83C710                 	add	edi,16
00002187 6642                   	inc	dx		;update entry counter.
00002189 E2F0                   	loop	@@4
0000218B 6633D2                 	xor	dx,dx		;reset to zero.
0000218E 8B3D 00000B17o         	mov	edi,SegmentList	;/
00002194                        @@5:
00002194 66895618               	mov	[esi].NewHeaderStruc.NewEntryCS,dx	;store segment entry number.
00002198 66C705 00000004o 14    	mov	ErrorNumber,20
         00
000021A1 66837F0800             	cmp	word ptr[edi+8],0
000021A6 0F8599030000           	jnz	@@9		;entry point is not in a code segment.
                                	;
000021AC 803D 000039D6o 00      	cmp	OptionTable+'Z',0
000021B3 7409                   	jz	@@NormStack2
000021B5 803D 000039CAo 00      	cmp	OptionTable+'N',0
000021BC 7551                   	jnz	@@10
000021BE                        @@NormStack2:	;
000021BE 0FB705 00000B39o       	movzx	eax,exehdr.StackSeg	;get entry SS.
000021C5 8B3D 00000B17o         	mov	edi,SegmentList	;make segment details addressable.
000021CB 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;get number of entries to check.
000021D1 6633D2                 	xor	dx,dx		;reset entry number.
000021D4                        @@6:
000021D4 66837F0802             	cmp	word ptr[edi+8],2		;stack segment?
000021D9 7509                   	jnz	@@6_0
000021DB 8B1F                   	mov	ebx,[edi+0]		;get segment base.
000021DD C1EB04                 	shr	ebx,4		;convert to paragraph.
000021E0 3BC3                   	cmp	eax,ebx		;this the one we're after?
000021E2 741F                   	jz	@@7
000021E4                        @@6_0:
000021E4 83C710                 	add	edi,16
000021E7 6642                   	inc	dx		;update entry counter.
000021E9 E2E9                   	loop	@@6
                                	;
000021EB 66833D 00000B3Bo 00    	cmp	exehdr.EntrySP,0
000021F3 7414                   	jz	@@8
000021F5 66C705 00000004o 19    	mov	ErrorNumber,25	;force an error.
         00
000021FE E942030000             	jmp	@@9
00002203                        @@7:
00002203 6689561E               	mov	[esi].NewHeaderStruc.NewEntrySS,dx	;store segment entry number.
00002207 EB06                   	jmp	@@10
00002209                        @@8:
00002209 66C7461E0000           	mov	[esi].NewHeaderStruc.NewEntrySS,0
                                	;
0000220F                        @@10:	;Get some memory for the relocation table.
                                	;
0000220F BA 00000A99o           	mov	edx,offset ProcessExeText	;let user know whats happening.
00002214 E815100000             	call	StringPrint
                                	;

                                ;	movzx	ebx,exehdr.RelocNum	;get number of relocation items.
                                ;	or	ebx,ebx
                                ;	jz	@@NoRelocMem
                                ;	shl	ebx,2
                                ;	sys	GetMemNear
00002219 0FB70D 00000B31o       	movzx	ecx,exehdr.RelocNum	;get number of relocation items.
00002220 85C9                   	test	ecx,ecx
00002222 0F8484000000           	jz	@@NoRelocMem
00002228 C1E102                 	shl	ecx,2
0000222B E84A0C0000             	call	GetMemLinear32
00002230 66C705 00000004o 02    	mov	ErrorNumber,2	;not enough memory.
         00
00002239 0F8206030000           	jc	@@9
0000223F 8935 00000B27o         	mov	RelocSegment,esi	;stow the memory address.
                                	;
00002245 668B15 00000B43o       	mov	dx,exehdr.RelocFirst
0000224C 66B90000               	mov	cx,0
00002250 668B1D 00000B00o       	mov	bx,EXEHandle
00002257 66B80042               	mov	ax,4200h
0000225B CD21                   	int	21h		;move to relocation table.
                                	;
0000225D 0FB70D 00000B31o       	movzx	ecx,exehdr.RelocNum
00002264 C1E102                 	shl	ecx,2
00002267 668B1D 00000B00o       	mov	bx,EXEHandle
0000226E 8B3D 00000B27o         	mov	edi,RelocSegment
00002274 E8060E0000             	call	ReadFile		;read the relocation table.
00002279 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00002282 0F82BD020000           	jc	@@9
                                	;
                                	;Convert relocation table to linear offsets.
                                	;
00002288 0FB70D 00000B31o       	movzx	ecx,exehdr.RelocNum	;number of entries.
0000228F 8B35 00000B27o         	mov	esi,RelocSegment	;list of relocations.
00002295                        @@1:
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00002295 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00002296 56                  2  	PUSH	esi			;SAVE THE REGISTER
00002297 0FB74602               	movzx	eax,word ptr[esi+2]		;get segment offset.
0000229B C1E004                 	shl	eax,4		;make it linear.
0000229E 0FB71E                 	movzx	ebx,word ptr[esi+0]		;get offset.
000022A1 03C3                   	add	eax,ebx		;add in offset.
000022A3 8906                   	mov	dword ptr[esi],eax		;store linear offset.
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000022A5 5E                  2  	POP	esi				;POP THE REGISTER
000022A6 59                  2  	POP	ecx				;POP THE REGISTER
000022A7 83C604                 	add	esi,4
000022AA E2E9                   	loop	@@1
                                	;
000022AC                        @@NoRelocMem:	;Get some memory for the exe image.
                                	;

                                ;	mov	ebx,d[ExeSize2]	;get exe image size.
                                ;	sys	GetMemNear
000022AC 8B0D 00000B4Ao         	mov	ecx,dword ptr[ExeSize2]	;get exe image size.
000022B2 E8C30B0000             	call	GetMemLinear32
000022B7 66C705 00000004o 02    	mov	ErrorNumber,2
         00
000022C0 0F827F020000           	jc	@@9
000022C6 8935 00000B23o         	mov	EXESegment,esi
                                	;
000022CC 668B15 00000B46o       	mov	dx,word ptr[ExeSize1]	;get image file offset.
000022D3 668B0D 00000B48o       	mov	cx,word ptr[ExeSize1+2]
000022DA 668B1D 00000B00o       	mov	bx,EXEHandle
000022E1 66B80042               	mov	ax,4200h
000022E5 CD21                   	int	21h		;move to start of exe image.
000022E7 66C705 00000004o 08    	mov	ErrorNumber,8
         00
000022F0 0F824F020000           	jc	@@9
000022F6 8B3D 00000B23o         	mov	edi,EXESegment
000022FC 668B1D 00000B00o       	mov	bx,EXEHandle
00002303 8B0D 00000B4Ao         	mov	ecx,dword ptr[ExeSize2]
00002309 E8710D0000             	call	ReadFile		;read exe image into memory.
                                	;
0000230E BA 00000ABCo           	mov	edx,offset GenerateExeText
00002313 E8160F0000             	call	StringPrint
                                	;
00002318 668B1D 00000B15o       	mov	bx,TEMPHandle
0000231F 66B90000               	mov	cx,0
00002323 66BA0000               	mov	dx,0
00002327 66B80142               	mov	ax,4201h
0000232B CD21                   	int	21h
0000232D C1E210                 	shl	edx,16
00002330 668BD0                 	mov	dx,ax
00002333 8915 0000386Do         	mov	Real3POffset,edx
                                	;
                                	;Write main header.
                                	;
00002339 BA 00000B4Eo           	mov	edx,offset NewHeader	;write the header to make space.
0000233E 668B1D 00000B15o       	mov	bx,TempHandle
00002345 66B94000               	mov	cx,size NewHeaderStruc
00002349 B440                   	mov	ah,40h
0000234B CD21                   	int	21h
                                	;
                                	;Write segment definitions.
                                	;
0000234D 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;get number to do.
00002353 8B35 00000B17o         	mov	esi,SegmentList	;the segment definitions.
00002359                        @@0:
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00002359 51                  2  	PUSH	ecx			;SAVE THE REGISTER
0000235A 56                  2  	PUSH	esi			;SAVE THE REGISTER
0000235B 8B06                   	mov	eax,[esi+0]		;get the base.
0000235D A3 00000180o           	mov	dword ptr[LineBuffer],eax
00002362 8B4604                 	mov	eax,[esi+4]		;get the limit.
00002365 3D00001000             	cmp	eax,100000h
0000236A 7212                   	jc	@@Small
0000236C 83F8FF                 	cmp	eax,-1
0000236F 7405                   	jz	@@NoRoundUp
00002371 05FF0F0000             	add	eax,4095
00002376                        @@NoRoundUp:
00002376 C1E80C                 	shr	eax,12		;lose bottom bits.
00002379 0D00001000             	or	eax,1 shl 20		;Set our version of the G bit.
0000237E                        @@Small:
0000237E 0FB75E08               	movzx	ebx,word ptr[esi+8]		;get segment type.
00002382 83E30F                 	and	ebx,15		;allows same variety as real selectors.
00002385 C1E315                 	shl	ebx,21		;put it somewhere useful.
00002388 0BC3                   	or	eax,ebx
0000238A A3 00000184o           	mov	dword ptr[LineBuffer+4],eax	;stow it in the table.
0000238F BA 00000180o           	mov	edx,offset LineBuffer
00002394 66B90800               	mov	cx,8
00002398 668B1D 00000B15o       	mov	bx,TEMPHandle
0000239F B440                   	mov	ah,40h
000023A1 CD21                   	int	21h		;write this entry.
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
000023A3 5E                  2  	POP	esi				;POP THE REGISTER
000023A4 59                  2  	POP	ecx				;POP THE REGISTER
000023A5 66C705 00000004o 08    	mov	ErrorNumber,8
         00
000023AE 0F8291010000           	jc	@@9
000023B4 6683F808               	cmp	ax,8
000023B8 0F8587010000           	jnz	@@9
000023BE 83C610                 	add	esi,16
000023C1 E296                   	loop	@@0
                                	;
                                	;Write relocation table.
                                	;
000023C3 0FB70D 00000B31o       	movzx	ecx,exehdr.RelocNum	;number of entries.
000023CA C1E102                 	shl	ecx,2
000023CD 8B35 00000B27o         	mov	esi,RelocSegment	;where they are.
000023D3 668B1D 00000B15o       	mov	bx,TEMPHandle
000023DA E8DA0C0000             	call	WriteFile
                                	;
                                	;Update exe image with real segment numbers.
                                	;
000023DF 0FB70D 00000B31o       	movzx	ecx,exehdr.RelocNum	;number of entries.
000023E6 E35A                   	jecxz	@@NoReloc
000023E8 8B35 00000B27o         	mov	esi,RelocSegment	;the relocations.
000023EE                        @@3:
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
000023EE 51                  2  	PUSH	ecx			;SAVE THE REGISTER
000023EF 56                  2  	PUSH	esi			;SAVE THE REGISTER
000023F0 8B36                   	mov	esi,[esi]		;get relocation offset.
000023F2 0335 00000B23o         	add	esi,ExeSegment	;offset into exe image.
000023F8 0FB706                 	movzx	eax,word ptr[esi]		;get value that needs relocating.
                                	;
000023FB 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;number of segments to scan.
00002401 8B3D 00000B17o         	mov	edi,SegmentList	;list of segment definitions.
00002407 33D2                   	xor	edx,edx		;reset segment number.
00002409                        @@30:
00002409 803D 000039CAo 00      	cmp	OptionTable+'N',0	;check for flat mode.
00002410 7407                   	jz	@@NotFlat
00002412 BA00000000             	mov	edx,0		;force to data referance.
00002417 EB1F                   	jmp	@@31
                                	;
00002419                        @@NotFlat:
00002419 8B1F                   	mov	ebx,[edi+0]		;get current segments base.
0000241B C1EB04                 	shr	ebx,4		;round it down.
0000241E 3BC3                   	cmp	eax,ebx
00002420 7416                   	jz	@@31
00002422 83C710                 	add	edi,16		;next segment definition.
00002425 42                     	inc	edx		;update segment number.
00002426 E2E1                   	loop	@@30
00002428 66C705 00000004o 17    	mov	ErrorNumber,23
         00
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00002431 5E                  2  	POP	esi				;POP THE REGISTER
00002432 59                  2  	POP	ecx				;POP THE REGISTER
00002433 E90D010000             	jmp	@@9
                                	;
00002438                        @@31:
00002438 668916                 	mov	[esi],dx		;store new segment value.
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
0000243B 5E                  2  	POP	esi				;POP THE REGISTER
0000243C 59                  2  	POP	ecx				;POP THE REGISTER
0000243D 83C604                 	add	esi,4		;next relocation entry.
00002440 E2AC                   	loop	@@3
                                	;
00002442                        @@NoReloc:	;Write exe image.
                                	;
00002442 8B0D 00000B4Ao         	mov	ecx,dword ptr[ExeSize2]
00002448 8B35 00000B23o         	mov	esi,ExeSegment
0000244E 668B1D 00000B15o       	mov	bx,TEMPHandle
00002455 E85F0C0000             	call	WriteFile
                                	;
                                	;Calculate file size.
                                	;
0000245A 668B1D 00000B15o       	mov	bx,TEMPHandle
00002461 66B90000               	mov	cx,0
00002465 66BA0000               	mov	dx,0
00002469 66B80142               	mov	ax,4201h
0000246D CD21                   	int	21h
0000246F C1E210                 	shl	edx,16
00002472 668BD0                 	mov	dx,ax
00002475 2B15 0000386Do         	sub	edx,Real3POffset
0000247B BE 00000B4Eo           	mov	esi,offset NewHeader
00002480 895602                 	mov	[esi].NewHeaderStruc.NewSize,edx
                                	;
                                	;Now go back and write the real header.
                                	;
00002483 8B15 0000386Do         	mov	edx,Real3POffset
00002489 668BCA                 	mov	cx,dx
0000248C C1EA10                 	shr	edx,16
0000248F 6687CA                 	xchg	cx,dx
00002492 668B1D 00000B15o       	mov	bx,TEMPHandle
00002499 66B80042               	mov	ax,4200h
0000249D CD21                   	int	21h
0000249F BA 00000B4Eo           	mov	edx,offset NewHeader	;write the header to make space.
000024A4 668B1D 00000B15o       	mov	bx,TempHandle
000024AB 66B94000               	mov	cx,size NewHeaderStruc
000024AF B440                   	mov	ah,40h
000024B1 CD21                   	int	21h
                                	;
                                	;Close the files.
                                	;
000024B3 668B1D 00000B15o       	mov	bx,TEMPHandle
000024BA E8340C0000             	call	CloseFile		;close the temp file.
000024BF 66C705 00000B15o 00    	mov	TEMPHandle,0
         00
000024C8 668B1D 00000B00o       	mov	bx,EXEHandle
000024CF E81F0C0000             	call	CloseFile		;close the file again.
000024D4 66C705 00000B00o 00    	mov	EXEHandle,0
         00
000024DD 668B1D 00000AFAo       	mov	bx,SHELLHandle
000024E4 E80A0C0000             	call	CloseFile
000024E9 66C705 00000AFAo 00    	mov	SHELLHandle,0
         00
                                	;
                                	;Delete origional .EXE
                                	;
000024F2 BA 00000100o           	mov	edx,offset EXEFileName	;get file name mask.
000024F7 B441                   	mov	ah,41h
000024F9 CD21                   	int	21h
000024FB 66C705 00000004o 08    	mov	ErrorNumber,8
         00
00002504 723F                   	jc	@@9
                                	;
                                	;now rename it.
                                	;
00002506 BA 00000B08o           	mov	edx,offset TempFileName
0000250B BF 00000100o           	mov	edi,offset EXEFileName		;get file name mask.
00002510 B456                   	mov	ah,56h
00002512 CD21                   	int	21h
00002514 722F                   	jc	@@9
                                	;
00002516 66C705 00000004o 00    	mov	ErrorNumber,0
         00
0000251F 6633C0                 	xor	ax,ax
                                	@dprintf 1,<"ProcessFile exit, ax=0 (ok)",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00002522 E83BDBFFFF          1  	call dprintf
00002527 50726F636573734669  1  	db "ProcessFile exit, ax=0 (ok)",10,0
00002544 C3                     	ret
                                	;
00002545                        @@9:
                                	@dprintf 1,<"ProcessFile exit, ax=-1 (error)",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00002545 E818DBFFFF          1  	call dprintf
0000254A 50726F636573734669  1  	db "ProcessFile exit, ax=-1 (error)",10,0
0000256B 66B8FFFF               	mov	ax,-1
0000256F 660BC0                 	or	ax,ax
00002572 C3                     	ret
00002573                        ProcessFile	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
00002573                        ReadMapFile	proc	near
                                ;
                                ;Convert the input files.
                                ;
                                	@dprintf 1,<"ReadMapFile enter",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00002573 E8EADAFFFF          1  	call dprintf
00002578 526561644D61704669  1  	db "ReadMapFile enter",10,0
                                	;
                                	;Get memory for segment list.
                                	;
0000258B 66C705 00000004o 02    	mov	ErrorNumber,2	;not enough memory.
         00

                                ;	mov	ebx,16*8192		;allow for maximum segments.
                                ;	sys	GetMemNear
00002594 B900000200             	mov	ecx,16*8192
00002599 E8DC080000             	call	GetMemLinear32
0000259E 0F8265050000           	jc	@@9
000025A4 8935 00000B17o         	mov	SegmentList,esi
                                	;
                                	;Try and open the map file.
                                	;
000025AA 66C705 00000004o 0A    	mov	ErrorNumber,10	;default to no map file.
         00
000025B3 BA 00000140o           	mov	edx,offset MapFileName
000025B8 E84C0A0000             	call	OpenFile		;try and open the map file.
000025BD 0F8246050000           	jc	@@9
000025C3 66A3 00000B06o         	mov	MapHandle,ax		;store the handle.
000025C9 BA 00000A82o           	mov	edx,offset ProcessMapText
000025CE E85B0C0000             	call	StringPrint

000025D3 E8EC0B0000             	call	InitFileBuffer

                                	;
                                	;Look for segment list ID string.
                                	;
000025D8                        @@LookID:
000025D8 BF 00000180o           	mov	edi,offset LineBuffer
000025DD 668B1D 00000B06o       	mov	bx,MapHandle
000025E4 E86B0B0000             	call	ReadLine		;read a line from the map file.
000025E9 66C705 00000004o 08    	mov	ErrorNumber,8	;default to general IO error.
         00
000025F2 0F8211050000           	jc	@@9
000025F8 66C705 00000004o 0B    	mov	ErrorNumber,11	;default to no segment header.
         00
00002601 660BC0                 	or	ax,ax		;anything to look at?
00002604 0F85FF040000           	jnz	@@9
0000260A 66C705 00000004o 12    	mov	ErrorNumber,18
         00
00002613 6681F90004             	cmp	cx,1024
00002618 0F83CD040000           	jnc	@@90
                                	;
                                	;See if right text on this line.
                                	;
0000261E BE 00000C53o           	mov	esi,offset SegHeaderText
00002623 BF 00000180o           	mov	edi,offset LineBuffer
                                	;
00002628                        @@0:
00002628 803E20                 	cmp	byte ptr[esi],' '		;need to skip white space.
0000262B 7405                   	jz	@@1
0000262D 803E09                 	cmp	byte ptr[esi],9
00002630 7503                   	jnz	@@2
00002632                        @@1:
00002632 46                     	inc	esi
00002633 EBF3                   	jmp	@@0
                                	;
00002635                        @@2:
00002635 803F20                 	cmp	byte ptr[edi],' '		;skip white space.
00002638 7405                   	jz	@@3
0000263A 803E09                 	cmp	byte ptr[esi],9
0000263D 7503                   	jnz	@@4
0000263F                        @@3:
0000263F 47                     	inc	edi
00002640 EBF3                   	jmp	@@2
                                	;
00002642                        @@4:
00002642 803E00                 	cmp	byte ptr[esi],0		;end of the header string?
00002645 7421                   	jz	@@5
00002647 803F00                 	cmp	byte ptr[edi],0		;end of the line buffer?
0000264A 748C                   	jz	@@LookID
                                	;
0000264C 8A06                   	mov	al,[esi]
0000264E E81C080000             	call	UpperChar		;case insensitive search.
00002653 86E0                   	xchg	ah,al
00002655 8A07                   	mov	al,[edi]
00002657 E813080000             	call	UpperChar
0000265C 3AC4                   	cmp	al,ah
0000265E 0F8574FFFFFF           	jnz	@@LookID		;next line if they don't match
00002664 46                     	inc	esi
00002665 47                     	inc	edi
00002666 EBC0                   	jmp	@@0		;next char if they do.
                                	;
00002668                        @@5:	;Find the next none blank line.
                                	;
00002668 668B1D 00000B06o       	mov	bx,MapHandle
0000266F BF 00000180o           	mov	edi,offset LineBuffer
00002674 E8DB0A0000             	call	ReadLine		;read another line.
00002679 66C705 00000004o 08    	mov	ErrorNumber,8	;default to general IO error.
         00
00002682 0F8281040000           	jc	@@9
00002688 660BC0                 	or	ax,ax		;did we get anything?
0000268B 0F85AB020000           	jnz	@@DoSegs		;bloody strange! No segments to process.
00002691 660BC9                 	or	cx,cx		;blank line?
00002694 74D2                   	jz	@@5		;keep reading till something happens.
00002696 66C705 00000004o 12    	mov	ErrorNumber,18
         00
0000269F 6681F90004             	cmp	cx,1024
000026A4 0F8341040000           	jnc	@@90
                                	;
                                	;Looks like we can start fetching segment values at last.
                                	;
000026AA A1 00000B17o           	mov	eax,SegmentList	;get segment buffer address.
000026AF A3 00000B1Bo           	mov	SegCurrent,eax	;setup current pointer.
                                	;
000026B4                        @@LookSeg:
000026B4 BE 00000180o           	mov	esi,offset LineBuffer	;source data.
000026B9 BF 00000D21o           	mov	edi,offset SegLayout-1	;definition of data layout.
000026BE 8B1D 00000B1Bo         	mov	ebx,SegCurrent
000026C4 C70300000000           	mov	dword ptr[ebx+0],0		;reset linear base.
000026CA C7430400000000         	mov	dword ptr[ebx+4],0		;reset byte limit.
000026D1 66C743080000           	mov	word ptr[ebx+8],0		;reset type.
                                	;
000026D7                        @@6:
000026D7 803E20                 	cmp	byte ptr[esi],' '		;skip leading white space.
000026DA 7405                   	jz	@@7
000026DC 803E09                 	cmp	byte ptr[esi],9
000026DF 7503                   	jnz	@@8
000026E1                        @@7:
000026E1 46                     	inc	esi
000026E2 EBF3                   	jmp	@@6
                                	;
000026E4                        @@8:
000026E4 47                     	inc	edi		;move to next item on the list.
000026E5 803FFF                 	cmp	byte ptr[edi],-1		;finished scan?
000026E8 0F84CE010000           	jz	@@NextSeg
000026EE 803F00                 	cmp	byte ptr[edi],0		;ignoring this column?
000026F1 740F                   	jz	@@Ignore
000026F3 803F01                 	cmp	byte ptr[edi],1		;start address?
000026F6 7417                   	jz	@@Start
000026F8 803F02                 	cmp	byte ptr[edi],2		;length?
000026FB 7455                   	jz	@@Length
000026FD E98C000000             	jmp	@@Class		;must be 3 (class) then.
                                	;
00002702                        @@Ignore:
00002702 803E20                 	cmp	byte ptr[esi],' '		;scan till more white space.
00002705 74D0                   	jz	@@6		;check next item in the list.
00002707 803E09                 	cmp	byte ptr[esi],9
0000270A 74CB                   	jz	@@6		;check next item in the list.
0000270C 46                     	inc	esi
0000270D EBF3                   	jmp	@@Ignore
                                	;
0000270F                        @@Start:
0000270F 33D2                   	xor	edx,edx		;reset acumulated value.
00002711                        @@11:
00002711 0FB606                 	movzx	eax,byte ptr[esi]		;fetch a digit.
00002714 0AC0                   	or	al,al
00002716 7425                   	jz	@@10		;finished geting value so store it.
00002718 3C20                   	cmp	al,' '
0000271A 7421                   	jz	@@10		;finished geting value so store it.
0000271C E80E040000             	call	ASCII2Bin
00002721 66C705 00000004o 0C    	mov	ErrorNumber,12	;default to bad definition.
         00
0000272A 0F82BB030000           	jc	@@90
00002730 3C48                   	cmp	al,'H'		;end of the number?
00002732 7408                   	jz	@@30
00002734 C1E204                 	shl	edx,4		;update acumulated value.
00002737 03D0                   	add	edx,eax		;/
00002739 46                     	inc	esi
0000273A EBD5                   	jmp	@@11		;keep reading till we run out.
0000273C                        @@30:
0000273C 46                     	inc	esi		;skip 'H'
0000273D                        @@10:
0000273D 8B1D 00000B1Bo         	mov	ebx,SegCurrent
00002743 8BC2                   	mov	eax,edx
00002745 83E2F0                 	and	edx,0fffffff0h	;segment has to be paragraph aligned.
00002748 8913                   	mov	[ebx+0],edx		;store start address.
0000274A 83E00F                 	and	eax,0fh
0000274D 014304                 	add	dword ptr[ebx+4],eax		;update limit base value.
00002750 EB85                   	jmp	@@6		;do next item along.
                                	;
00002752                        @@Length:
00002752 33D2                   	xor	edx,edx		;reset accumulated value.
00002754                        @@12:
00002754 0FB606                 	movzx	eax,byte ptr[esi]		;fetch a digit.
00002757 0AC0                   	or	al,al
00002759 7425                   	jz	@@13		;finished getting value so store it.
0000275B 3C20                   	cmp	al,' '
0000275D 7421                   	jz	@@13		;finished getting value so store it.
0000275F E8CB030000             	call	ASCII2Bin
00002764 66C705 00000004o 0C    	mov	ErrorNumber,12	;default to bad definition.
         00
0000276D 0F8278030000           	jc	@@90
00002773 3C48                   	cmp	al,'H'		;end of the number?
00002775 7408                   	jz	@@31
00002777 C1E204                 	shl	edx,4		;update acumulated value.
0000277A 03D0                   	add	edx,eax		;/
0000277C 46                     	inc	esi
0000277D EBD5                   	jmp	@@12		;keep reading till we run out.
0000277F                        @@31:
0000277F 46                     	inc	esi		;skip 'H'
00002780                        @@13:
00002780 8B1D 00000B1Bo         	mov	ebx,SegCurrent
00002786 015304                 	add	dword ptr[ebx+4],edx		;store length.
00002789 E949FFFFFF             	jmp	@@6		;do next item along.
                                	;
0000278E                        @@Class:	;Search class lists for this string.
                                	;
0000278E 66C705 00000004o 0E    	mov	ErrorNumber,14	;default to un-known class.
         00
00002797 BD 00000E28o           	mov	ebp,offset SegClassList	;list of lists.
0000279C 8BD6                   	mov	edx,esi		;store source position.
0000279E                        @@14:
0000279E 3E837D00FF             	cmp	ds:dword ptr[ebp],-1		;end of the list?
000027A3 0F8442030000           	jz	@@90
000027A9 3E8B5D00               	mov	ebx,ds:[ebp]		;get table pointer.
000027AD 8BF2                   	mov	esi,edx
000027AF C705 00000580o 00      	mov	dword ptr[@@WildStart1],0
         000000
                                	;
000027B9                        @@15:
000027B9 803B2A                 	cmp	byte ptr[ebx],'*'		;match anything after this point?
000027BC 7521                   	jnz	@@25
000027BE 891D 00000580o         	mov	dword ptr[@@WildStart1],ebx	;store sub-string start.
000027C4 8935 00000584o         	mov	dword ptr[@@WildStart2],esi
000027CA 807B0120               	cmp	byte ptr[ebx+1],' '		;last thing in string?
000027CE 740F                   	jz	@@25
000027D0 807B0100               	cmp	byte ptr[ebx+1],0
000027D4 7409                   	jz	@@25
000027D6 43                     	inc	ebx		;move to next char.
000027D7 891D 00000580o         	mov	dword ptr[@@WildStart1],ebx	;store sub-string start.
000027DD EBDA                   	jmp	@@15
                                	;
000027DF                        @@25:
000027DF 803B20                 	cmp	byte ptr[ebx],' '		;end of sub string?
000027E2 7405                   	jz	@@26
000027E4 803B00                 	cmp	byte ptr[ebx],0
000027E7 750A                   	jnz	@@27
000027E9                        @@26:
000027E9 C705 00000580o 00      	mov	dword ptr[@@WildStart1],0
         000000
                                	;
000027F3                        @@27:
000027F3 803E20                 	cmp	byte ptr[esi],' '		;white space?
000027F6 740A                   	jz	@@19
000027F8 803E09                 	cmp	byte ptr[esi],9		;white space?
000027FB 7405                   	jz	@@19
000027FD 803E00                 	cmp	byte ptr[esi],0		;end of the line?
00002800 7511                   	jnz	@@20
                                	;
00002802                        @@19:
00002802 803B20                 	cmp	byte ptr[ebx],' '		;if list entry is finished then we have a match.
00002805 746E                   	jz	@@21
00002807 803B00                 	cmp	byte ptr[ebx],0
0000280A 7469                   	jz	@@21
0000280C 803B2A                 	cmp	byte ptr[ebx],'*'
0000280F 7464                   	jz	@@21
00002811 EB34                   	jmp	@@17		;try next class name.
                                	;
00002813                        @@20:
00002813 8A06                   	mov	al,[esi]
00002815 E855060000             	call	UpperChar		;no case sensitivity.
0000281A 86E0                   	xchg	ah,al
0000281C 8A03                   	mov	al,[ebx]
0000281E E84C060000             	call	UpperChar
00002823 3AC4                   	cmp	al,ah		;any match?
00002825 743F                   	jz	@@16
00002827 833D 00000580o 00      	cmp	dword ptr[@@WildStart1],0	;fail it.
0000282E 7417                   	jz	@@17
00002830 FF05 00000584o         	inc	dword ptr[@@WildStart2]	;move along in source string.
00002836 8B1D 00000580o         	mov	ebx,dword ptr[@@WildStart1]	;point to sub string again.
0000283C 8B35 00000584o         	mov	esi,dword ptr[@@WildStart2]
00002842 E972FFFFFF             	jmp	@@15		;look again.
                                	;
00002847                        @@17:
00002847 803B00                 	cmp	byte ptr[ebx],0		;end of this class list?
0000284A 7421                   	jz	@@18
0000284C 803B20                 	cmp	byte ptr[ebx],' '		;seperator?
0000284F 7403                   	jz	@@22		;keep going till the end or a space.
00002851 43                     	inc	ebx
00002852 EBF3                   	jmp	@@17
00002854                        @@22:
00002854 8BF2                   	mov	esi,edx
00002856 43                     	inc	ebx		;skip the space.
00002857 C705 00000580o 00      	mov	dword ptr[@@WildStart1],0
         000000
00002861 E953FFFFFF             	jmp	@@15		;try new name.
                                	;
00002866                        @@16:
00002866 46                     	inc	esi
00002867 43                     	inc	ebx
00002868 E94CFFFFFF             	jmp	@@15		;keep comparing.
                                	;
0000286D                        @@18:
0000286D 83C504                 	add	ebp,4		;next class list entry.
00002870 E929FFFFFF             	jmp	@@14
                                	;
00002875                        @@21:
00002875 81ED 00000E28o         	sub	ebp,offset SegClassList	;get class *4
0000287B C1ED02                 	shr	ebp,2		;real class.
0000287E 53                     	push	ebx
0000287F 8B1D 00000B1Bo         	mov	ebx,SegCurrent
00002885 66896B08               	mov	word ptr[ebx+8],bp		;store class.
00002889 5B                     	pop	ebx
0000288A 6683FD04               	cmp	bp,4		;flat?
0000288E 0F8543FEFFFF           	jnz	@@6
00002894 C605 000039CAo 2B      	mov	OptionTable+'N','+'	;signal flat mode.
0000289B C605 000039C3o 00      	mov	OptionTable+'G',0
000028A2 C605 000039AFo 2B      	mov	OptionTable+'3','+'
000028A9 56                     	push	esi
000028AA BE 00000B4Eo           	mov	esi,offset NewHeader
000028AF 816620FEBF0000         	and	[esi].NewHeaderStruc.NewFlags,65535-(1+16384)	;32 bit code.
000028B6 5E                     	pop	esi
000028B7 E91BFEFFFF             	jmp	@@6
                                	;
000028BC                        @@NextSeg:
000028BC 8B1D 00000B1Bo         	mov	ebx,SegCurrent
000028C2 66837B0802             	cmp	word ptr[ebx+8],2
000028C7 7508                   	jnz	@@NoRound
000028C9 8343040F               	add	dword ptr[ebx+4],15
000028CD 836304F0               	and	dword ptr[ebx+4],0fffffff0h
000028D1                        @@NoRound:	;
000028D1 8305 00000B1Bo 10      	add	SegCurrent,16	;next segment storage slot.
000028D8 A1 00000B1Bo           	mov	eax,SegCurrent
000028DD 2B05 00000B17o         	sub	eax,SegmentList
000028E3 C1E804                 	shr	eax,4
000028E6 3D00200000             	cmp	eax,8192		;check for to many segments.
000028EB 66C705 00000004o 11    	mov	ErrorNumber,17
         00
000028F4 0F830F020000           	jnc	@@9
                                	;
000028FA 668B1D 00000B06o       	mov	bx,MapHandle
00002901 BF 00000180o           	mov	edi,offset LineBuffer
00002906 E849080000             	call	ReadLine
0000290B 66C705 00000004o 08    	mov	ErrorNumber,8	;default to general IO error.
         00
00002914 0F82EF010000           	jc	@@9
0000291A 660BC0                 	or	ax,ax		;EOF?
0000291D 751D                   	jnz	@@DoSegs
0000291F 66C705 00000004o 12    	mov	ErrorNumber,18
         00
00002928 6681F90004             	cmp	cx,1024
0000292D 0F83B8010000           	jnc	@@90
00002933 660BC9                 	or	cx,cx		;Blank line?
00002936 0F8578FDFFFF           	jnz	@@LookSeg		;Fetch next segment value.
                                	;
0000293C                        @@DoSegs:	;We've got all the segments so its time to make use of them.
                                	;
0000293C 803D 000039CAo 00      	cmp	OptionTable+'N',0	;Flat mode?
00002943 747B                   	jz	@@NoFlat
                                	;
00002945 A1 00000B1Bo           	mov	eax,SegCurrent
0000294A 2B05 00000B17o         	sub	eax,SegmentList
00002950 C1E804                 	shr	eax,4		;/16
00002953 83F801                 	cmp	eax,1
00002956 66C705 00000004o 18    	mov	ErrorNumber,24	;only one segment allowed.
         00
0000295F 0F85A4010000           	jnz	@@9
00002965 8B35 00000B17o         	mov	esi,SegmentList
0000296B 8B06                   	mov	eax,0[esi]		;get base.
0000296D 8B5E04                 	mov	ebx,4[esi]		;get limit.
00002970 C74604FFFFFFFF         	mov	dword ptr[esi+4],-1		;set limit.
00002977 83C610                 	add	esi,16		;next entry.
0000297A 8906                   	mov	0[esi],eax		;set base.
0000297C 895E04                 	mov	dword ptr[esi+4],ebx		;set limit.
0000297F 66C746080000           	mov	word ptr[esi+8],0		;set class to code.
00002985 83C610                 	add	esi,16
00002988 8935 00000B1Bo         	mov	SegCurrent,esi	;pretend normal now.
0000298E 83EE10                 	sub	esi,16
                                	;
00002991 803D 000039D6o 00      	cmp	OptionTable+'Z',0
00002998 7426                   	jz	@@NoFlat
                                	;
0000299A BF 00000B4Eo           	mov	edi,offset NewHeader
0000299F 8B4724                 	mov	eax,[edi].NewHeaderStruc.NewAutoStack
000029A2 0BC0                   	or	eax,eax
000029A4 7505                   	jnz	@@GotESPSize
000029A6 B800040000             	mov	eax,1024
000029AB                        @@GotESPSize:
000029AB 034604                 	add	eax,4[esi]
000029AE 83C003                 	add	eax,3
000029B1 83E0FC                 	and	eax,0FFFFFFFCh
000029B4 894604                 	mov	4[esi],eax
000029B7 89471A                 	mov	[edi].NewHeaderStruc.NewEntryESP,eax
000029BA 66C7471E0000           	mov	[edi].NewHeaderStruc.NewEntrySS,0
                                	;
000029C0                        @@NoFlat:
000029C0 A1 00000B1Bo           	mov	eax,SegCurrent
000029C5 2B05 00000B17o         	sub	eax,SegmentList
000029CB C1E804                 	shr	eax,4		;/16
000029CE A3 00000B1Fo           	mov	SegmentTotal,eax
000029D3 0BC0                   	or	eax,eax		;any segments found?
000029D5 66C705 00000004o 0D    	mov	ErrorNumber,13
         00
000029DE 0F8425010000           	jz	@@9
                                	;
000029E4 668B1D 00000B06o       	mov	bx,MapHandle
000029EB E803070000             	call	CloseFile		;close the file again.
000029F0 66C705 00000B06o 00    	mov	MapHandle,0
         00
                                	;
                                	;Work out where the very end of the program will be. This is the size of memory
                                	;we will need to allocate for it.
                                	;
000029F9 8B1D 00000B17o         	mov	ebx,SegmentList	;make segment details addressable.
000029FF 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;number of segments.
00002A05 33D2                   	xor	edx,edx		;reset comparison value.
00002A07                        @@23:
00002A07 837B04FF               	cmp	dword ptr[ebx+4],-1
00002A0B 740B                   	jz	@@24
00002A0D 8B03                   	mov	eax,[ebx+0]		;get segment base.
00002A0F 034304                 	add	eax,[ebx+4]		;add in length.
00002A12 3BC2                   	cmp	eax,edx		;biggest yet?
00002A14 7202                   	jc	@@24
00002A16 8BD0                   	mov	edx,eax		;store new limit.
00002A18                        @@24:
00002A18 83C310                 	add	ebx,16
00002A1B E2EA                   	loop	@@23		;do all of them.
00002A1D BE 00000B4Eo           	mov	esi,offset NewHeader
00002A22 89560A                 	mov	[esi].NewHeaderStruc.NewAlloc,edx	;store it in the new header.
                                	;
                                	;Go through segments altering limits so that they extend to the
                                	;end of the program.
                                	;
00002A25 803D 000039C3o 00      	cmp	OptionTable+'G',0	;group addressing?
00002A2C 7427                   	jz	@@NoGroup
00002A2E BE 00000B4Eo           	mov	esi,offset NewHeader
00002A33 8B460A                 	mov	eax,[esi].NewHeaderStruc.NewAlloc	;get program limit.
00002A36 8B35 00000B17o         	mov	esi,SegmentList	;the segment details.
00002A3C 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;number of segments to process.
00002A42                        @@G0:
00002A42 66837E0800             	cmp	word ptr[esi+8],0		;code segment?
00002A47 7407                   	jz	@@G1		;leave code segs as they are.
00002A49 8BD8                   	mov	ebx,eax		;copy program limit.
00002A4B 2B1E                   	sub	ebx,0[esi]		;minus segment base.
00002A4D 895E04                 	mov	4[esi],ebx		;set new limit.
00002A50                        @@G1:
00002A50 83C610                 	add	esi,16		;next segment.
00002A53 E2ED                   	loop	@@G0		;do all of them.
                                	;
00002A55                        @@NoGroup:	;Now make sure no 2 segments have the same base value.
                                	;
00002A55 803D 000039CAo 00      	cmp	OptionTable+'N',0
00002A5C 7565                   	jnz	@@NoBaseChk
00002A5E 8B35 00000B17o         	mov	esi,SegmentList	;make segment details addressable.
00002A64 8B0D 00000B1Fo         	mov	ecx,SegmentTotal	;number of segments.
00002A6A                        @@SameBase0:
                                	pushm	ecx,esi
                             1  	IRP	X,<ecx,esi,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00002A6A 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00002A6B 56                  2  	PUSH	esi			;SAVE THE REGISTER
00002A6C 8B06                   	mov	eax,[esi]		;get base.
00002A6E 8BEE                   	mov	ebp,esi
00002A70 83C610                 	add	esi,16
00002A73 49                     	dec	ecx
00002A74                        @@SameBase1:
00002A74 0BC9                   	or	ecx,ecx
00002A76 740C                   	jz	@@SameBase2
00002A78 780A                   	js	@@SameBase2
00002A7A 3B06                   	cmp	eax,[esi]		;same base?
00002A7C 7414                   	jz	@@SameBase3
00002A7E                        @@SameBase4:
00002A7E 83C610                 	add	esi,16
00002A81 49                     	dec	ecx
00002A82 EBF0                   	jmp	@@SameBase1
00002A84                        @@SameBase2:
                                	popm	ecx,esi
                             1  	IRP	X,<,,,,,,,,esi,ecx> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00002A84 5E                  2  	POP	esi				;POP THE REGISTER
00002A85 59                  2  	POP	ecx				;POP THE REGISTER
00002A86 83C610                 	add	esi,16
00002A89 49                     	dec	ecx
00002A8A 0BC9                   	or	ecx,ecx
00002A8C 7435                   	jz	@@NoBaseChk
00002A8E 7833                   	js	@@NoBaseChk
00002A90 EBD8                   	jmp	@@SameBase0
                                	;
00002A92                        @@SameBase3:
                                	pushm	eax,ecx,esi,ebp
                             1  	IRP	X,<eax,ecx,esi,ebp,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00002A92 50                  2  	PUSH	eax			;SAVE THE REGISTER
00002A93 51                  2  	PUSH	ecx			;SAVE THE REGISTER
00002A94 56                  2  	PUSH	esi			;SAVE THE REGISTER
00002A95 55                  2  	PUSH	ebp			;SAVE THE REGISTER

                                if	0
                                endif

00002A96 BA 000009F6o           	mov	edx,offset SegSamet
00002A9B E88E070000             	call	StringPrint
00002AA0 C605 000009F6o 00      	mov	SegSamet,0

                                	popm	eax,ecx,esi,ebp
                             1  	IRP	X,<,,,,,,ebp,esi,ecx,eax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00002AA7 5D                  2  	POP	ebp				;POP THE REGISTER
00002AA8 5E                  2  	POP	esi				;POP THE REGISTER
00002AA9 59                  2  	POP	ecx				;POP THE REGISTER
00002AAA 58                  2  	POP	eax				;POP THE REGISTER
                                	;
                                	;Upgrade first segment to largest length of the two.
                                	;
00002AAB 50                     	push	eax
00002AAC 3E8B4504               	mov	eax,ds:[ebp+4]
00002AB0 8B5604                 	mov	edx,[esi+4]
00002AB3 3BC2                   	cmp	eax,edx
00002AB5 7302                   	jnc	@@SameBase5
00002AB7 8BC2                   	mov	eax,edx
00002AB9                        @@SameBase5:
00002AB9 3E894504               	mov	ds:[ebp+4],eax
00002ABD 894604                 	mov	[esi+4],eax
00002AC0 58                     	pop	eax
00002AC1 EBBB                   	jmp	@@SameBase4
00002AC3                        @@NoBaseChk:	;
                                	@dprintf 1,<"ReadMapFile exit, ok",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00002AC3 E89AD5FFFF          1  	call dprintf
00002AC8 526561644D61704669  1  	db "ReadMapFile exit, ok",10,0
00002ADE 66C705 00000004o 00    	mov	ErrorNumber,0
         00
00002AE7 6633C0                 	xor	ax,ax
00002AEA C3                     	ret
                                	;
00002AEB                        @@90:
00002AEB BA 00000ADEo           	mov	edx,offset CarriageReturn
00002AF0 E839070000             	call	StringPrint
00002AF5 BA 00000180o           	mov	edx,offset LineBuffer
00002AFA E82F070000             	call	StringPrint		;print the offending line.
00002AFF BA 00000ADEo           	mov	edx,offset CarriageReturn
00002B04 E825070000             	call	StringPrint
                                	;
00002B09                        @@9:
                                	@dprintf 1,<"ReadMapFile exit, error",10>
                             1    for x,<,,,,>
 >                           1     ifnb <x>
 >                           1  	push x
 >                           1     endif
 >                           1    endm
00002B09 E854D5FFFF          1  	call dprintf
00002B0E 526561644D61704669  1  	db "ReadMapFile exit, error",10,0
00002B27 66B8FFFF               	mov	ax,-1
00002B2B 660BC0                 	or	ax,ax
00002B2E C3                     	ret
00000580                        _BSS segment
00000580 00000000               @@WildStart1	dd ?
00000584 00000000               @@WildStart2	dd ?
00000588                        _BSS ends
00002B2F                        ReadMapFile	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
00002B2F                        ASCII2Bin	proc	near
                                ;
                                ;Convert hex digit in AL into binary value.
                                ;
00002B2F E83B030000             	call	UpperChar
00002B34 3C48                   	cmp	al,'H'
00002B36 7416                   	jz	@@8
00002B38 3C30                   	cmp	al,'0'
00002B3A 7214                   	jc	@@9
00002B3C 3C41                   	cmp	al,'A'
00002B3E 7208                   	jc	@@Dec
00002B40 3C47                   	cmp	al,'F'+1
00002B42 730C                   	jnc	@@9
00002B44 2C37                   	sub	al,'A'-10
00002B46 EB06                   	jmp	@@8
00002B48                        @@Dec:
00002B48 3C3A                   	cmp	al,'9'+1
00002B4A 7304                   	jnc	@@9
00002B4C 2C30                   	sub	al,'0'
00002B4E                        @@8:
00002B4E F8                     	clc
00002B4F C3                     	ret
                                	;
00002B50 F9                     @@9:	stc
00002B51 C3                     	ret
00002B52                        ASCII2Bin	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
00002B52                        ReadConfig	proc	near
                                ;
                                ;Read configuration file.
                                ;
00002B52 E86D060000             	call	InitFileBuffer

00002B57 BA 00000AE4o           	mov	edx,offset ConfigName
00002B5C 803D 000039BFo 00      	cmp	OptionTable+'C',0	;new config file name?
00002B63 740A                   	jz	@@NoOveride
00002B65 8B15 00003B08o         	mov	edx,dword ptr[OptionTable+128+('C'*4)]
00002B6B 0BD2                   	or	edx,edx
00002B6D 7414                   	jz	@@NotCurrent
00002B6F                        @@NoOveride:
00002B6F E895040000             	call	OpenFile
00002B74 7371                   	jnc	@@ConfigOK
00002B76 803D 000039BFo 00      	cmp	OptionTable+'C',0	;new config file name?
00002B7D 0F853E010000           	jnz	@@8		;don't look for default.
00002B83                        @@NotCurrent:	;
00002B83 8B1D 00000000o         	mov	ebx, psp
                                if 0
                                else
00002B89 668B5B2C               	mov bx,[ebx+2Ch]
00002B8D 66B80600               	mov ax,6
00002B91 CD31                   	int 31h
00002B93 6651                   	push cx
00002B95 6652                   	push dx
00002B97 5E                     	pop esi
                                endif
00002B98 33ED                   	xor	ebp,ebp
00002B9A                        @@c1:
00002B9A 8A06                   	mov	al,[esi]		;Get a byte.
00002B9C 46                     	inc	esi		;/
00002B9D 0AC0                   	or	al,al		;End of a string?
00002B9F 75F9                   	jnz	@@c1		;keep looking.
00002BA1 8A06                   	mov	al,[esi]		;Double zero?
00002BA3 0AC0                   	or	al,al		;/
00002BA5 75F3                   	jnz	@@c1		;keep looking.
00002BA7 83C603                 	add	esi,3		;Skip last 0 and word count.
00002BAA BF 00000000o           	mov	edi,offset ConfigPath
00002BAF                        @@c2:
00002BAF A4                     	movsb
00002BB0 807EFF5C               	cmp	byte ptr[esi-1],'\'
00002BB4 7502                   	jnz	@@c3
00002BB6 8BEF                   	mov	ebp,edi
00002BB8                        @@c3:
00002BB8 807EFF00               	cmp	byte ptr[esi-1],0		;got to the end yet?
00002BBC 75F1                   	jnz	@@c2
00002BBE 0BED                   	or	ebp,ebp
00002BC0 7502                   	jnz	@@c99
00002BC2 8BEF                   	mov	ebp,edi
00002BC4                        @@c99:
00002BC4 4D                     	dec	ebp
00002BC5 8BFD                   	mov	edi,ebp
00002BC7 C6075C                 	mov	byte ptr[edi],'\'
00002BCA 47                     	inc	edi
00002BCB BE 00000AE4o           	mov	esi,offset ConfigName
00002BD0                        @@c4:
00002BD0 A4                     	movsb
00002BD1 807EFF00               	cmp	byte ptr[esi-1],0
00002BD5 75F9                   	jnz	@@c4
                                	;
00002BD7 BA 00000000o           	mov	edx,offset ConfigPath	;use new name.
00002BDC E828040000             	call	OpenFile
00002BE1 0F82DA000000           	jc	@@8		;don't have to have a config.
                                	;
00002BE7                        @@ConfigOK:
00002BE7 66A3 00000AF8o         	mov	ConfigHandle,ax
                                	;
00002BED                        @@Read:
00002BED 668B1D 00000AF8o       	mov	bx,ConfigHandle
00002BF4 BF 00000180o           	mov	edi,offset LineBuffer
00002BF9 E856050000             	call	ReadLine		;read a line.
00002BFE 66C705 00000004o 08    	mov	ErrorNumber,8	;default to io error.
         00
00002C07 0F82E9000000           	jc	@@9
00002C0D 660BC0                 	or	ax,ax		;end of the file?
00002C10 0F8594000000           	jnz	@@7
00002C16 66C705 00000004o 12    	mov	ErrorNumber,18
         00
00002C1F 6681F90004             	cmp	cx,1024
00002C24 0F83AE000000           	jnc	@@90
                                	;
00002C2A                        @@Scan:	;Check this line for variables.
                                	;
00002C2A BA 00000180o           	mov	edx,offset LineBuffer
00002C2F BD 00000B8Eo           	mov	ebp,offset VariableList
00002C34 8BFA                   	mov	edi,edx
00002C36 803F3B                 	cmp	byte ptr[edi],';'
00002C39 74B2                   	jz	@@Read		;comment so ignore it.
00002C3B 803F00                 	cmp	byte ptr[edi],0		;blank line?
00002C3E 74AD                   	jz	@@Read
                                	;
00002C40                        @@0:
00002C40 66C705 00000004o 0F    	mov	ErrorNumber,15
         00
00002C49 3E837D00FF             	cmp	ds:dword ptr[ebp],-1		;end of the list?
00002C4E 0F8484000000           	jz	@@90
00002C54 3E8B7500               	mov	esi,ds:[ebp]		;get text pointer.
00002C58 8BFA                   	mov	edi,edx		;source data.
                                	;
00002C5A                        @@1:
00002C5A 803F3D                 	cmp	byte ptr[edi],'='		;end of the string?
00002C5D 7505                   	jnz	@@3
00002C5F 803E00                 	cmp	byte ptr[esi],0		;end of our version as well?
00002C62 7430                   	jz	@@4
                                	;
00002C64                        @@3:
00002C64 66C705 00000004o 0F    	mov	ErrorNumber,15
         00
00002C6D 803F00                 	cmp	byte ptr[edi],0		;end of the line?
00002C70 7466                   	jz	@@90
                                	;
00002C72 803E00                 	cmp	byte ptr[esi],0		;end of the text?
00002C75 7414                   	jz	@@5
                                	;
00002C77 8A06                   	mov	al,[esi]
00002C79 E8F1010000             	call	UpperChar
00002C7E 86E0                   	xchg	ah,al
00002C80 8A07                   	mov	al,[edi]
00002C82 E8E8010000             	call	UpperChar
00002C87 3AC4                   	cmp	al,ah		;match?
00002C89 7405                   	jz	@@2
                                	;
00002C8B                        @@5:
00002C8B 83C510                 	add	ebp,16		;next variable.
00002C8E EBB0                   	jmp	@@0
                                	;
00002C90                        @@2:
00002C90 46                     	inc	esi
00002C91 47                     	inc	edi
00002C92 EBC6                   	jmp	@@1
                                	;
00002C94                        @@4:
00002C94 47                     	inc	edi
00002C95 3EFF5504               	call	ds:dword ptr[ebp+4]		;call the handler code.
00002C99 0F844EFFFFFF           	jz	@@Read
00002C9F 66C705 00000004o 10    	mov	ErrorNumber,16	;invalid setting.
         00
00002CA8 EB2E                   	jmp	@@90
                                	;
00002CAA                        @@7:
00002CAA 668B1D 00000AF8o       	mov	bx,ConfigHandle	;close the file again.
00002CB1 E83D040000             	call	CloseFile
00002CB6 66C705 00000AF8o 00    	mov	ConfigHandle,0
         00
00002CBF EB0A                   	jmp	@@10
                                	;
00002CC1                        @@8:
00002CC1 BA 00000A32o           	mov	edx,offset InternalConfig
00002CC6 E863050000             	call	StringPrint
                                	;
00002CCB                        @@10:
00002CCB 66C705 00000004o 00    	mov	ErrorNumber,0
         00
00002CD4 6633C0                 	xor	ax,ax
00002CD7 C3                     	ret
                                	;
00002CD8                        @@90:
00002CD8 BA 00000ADEo           	mov	edx,offset CarriageReturn
00002CDD E84C050000             	call	StringPrint
00002CE2 BA 00000180o           	mov	edx,offset LineBuffer
00002CE7 E842050000             	call	StringPrint
00002CEC BA 00000ADEo           	mov	edx,offset CarriageReturn
00002CF1 E838050000             	call	StringPrint
                                	;
00002CF6                        @@9:
00002CF6 66B8FFFF               	mov	ax,-1
00002CFA 660BC0                 	or	ax,ax
00002CFD C3                     	ret
00002CFE                        ReadConfig	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=-=
00002CFE                        WhiteSpaceString proc near
                                ;
                                ;Retrieve a string and convert multiple white space into single spaces. Last white space is line
                                ;terminator.
                                ;
                                	;
00002CFE 8BF7                   	mov	esi,edi
00002D00 8935 00000588o         	mov	dword ptr[@@Source],esi
00002D06 3E8B7D08               	mov	edi,ds:[ebp+8]	;get target address.
00002D0A 807FFFFF               	cmp	byte ptr[edi-1],-1		;first time?
00002D0E C647FF00               	mov	byte ptr[edi-1],0
00002D12 7409                   	jz	@@AtStart
00002D14                        @@30:
00002D14 8A07                   	mov	al,[edi]
00002D16 0AC0                   	or	al,al
00002D18 7403                   	jz	@@AtStart
00002D1A 47                     	inc	edi
00002D1B EBF7                   	jmp	@@30
00002D1D                        @@AtStart:	;
00002D1D C60720                 	mov	byte ptr[edi],' '
00002D20 47                     	inc	edi
                                	;
00002D21 32E4                   	xor	ah,ah		;clear spacing flag.
00002D23                        @@0:
00002D23 AC                     	lodsb
00002D24 3C5C                   	cmp	al,'\'		;line continuation?
00002D26 753B                   	jnz	@@5
                                	;
                                	;Read a new line.
                                	;
                                	pushm	edi,ebp
                             1  	IRP	X,<edi,ebp,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00002D28 57                  2  	PUSH	edi			;SAVE THE REGISTER
00002D29 55                  2  	PUSH	ebp			;SAVE THE REGISTER
00002D2A 668B1D 00000AF8o       	mov	bx,ConfigHandle
00002D31 8B3D 00000588o         	mov	edi,dword ptr[@@Source]
00002D37 E818040000             	call	ReadLine		;read a line.
                                	popm	edi,ebp
                             1  	IRP	X,<,,,,,,,,ebp,edi> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00002D3C 5D                  2  	POP	ebp				;POP THE REGISTER
00002D3D 5F                  2  	POP	edi				;POP THE REGISTER
00002D3E 725E                   	jc	@@9
00002D40 660BC0                 	or	ax,ax		;end of the file?
00002D43 7552                   	jnz	@@7
00002D45 6681F90004             	cmp	cx,1024
00002D4A 7352                   	jnc	@@9
                                	;
00002D4C 8B35 00000588o         	mov	esi,dword ptr[@@Source]
00002D52                        @@6:
00002D52 AC                     	lodsb
00002D53 3C20                   	cmp	al,' '
00002D55 74FB                   	jz	@@6
00002D57 3C09                   	cmp	al,9
00002D59 74F7                   	jz	@@6
00002D5B 4E                     	dec	esi
00002D5C B020                   	mov	al,' '
00002D5E AA                     	stosb
00002D5F 32E4                   	xor	ah,ah
00002D61 EBC0                   	jmp	@@0		;start reading again.
                                	;
00002D63                        @@5:
00002D63 AA                     	stosb
00002D64 807EFF00               	cmp	byte ptr[esi-1],0		;end of the string?
00002D68 741F                   	jz	@@1
00002D6A 807EFF20               	cmp	byte ptr[esi-1],' '		;need multiple space check?
00002D6E 740A                   	jz	@@2
00002D70 807EFF09               	cmp	byte ptr[esi-1],9
00002D74 7404                   	jz	@@2
00002D76 32E4                   	xor	ah,ah		;clear spacing flag.
00002D78 EBA9                   	jmp	@@0
                                	;
00002D7A                        @@2:
00002D7A 0AE4                   	or	ah,ah		;this part 2?
00002D7C 7508                   	jnz	@@3
00002D7E C647FF20               	mov	byte ptr[edi-1],' '		;make sure its a space.
00002D82 B401                   	mov	ah,1		;signal spacing start.
00002D84 EB9D                   	jmp	@@0
                                	;
00002D86                        @@3:
00002D86 4F                     	dec	edi		;move back to last one.
00002D87 EB9A                   	jmp	@@0
                                	;
00002D89                        @@1:
00002D89 4F                     	dec	edi		;back to terminator.
00002D8A 3E3B7D08               	cmp	edi,ds:[ebp+8]	;back at the start yet?
00002D8E 7407                   	jz	@@4
00002D90 807FFF20               	cmp	byte ptr[edi-1],' '		;trailing space?
00002D94 7501                   	jnz	@@4
00002D96 4F                     	dec	edi
00002D97                        @@4:	;
00002D97                        @@7:
00002D97 C60700                 	mov	byte ptr[edi],0		;terminate the line.
                                	;
00002D9A 6633C0                 	xor	ax,ax
00002D9D C3                     	ret
                                	;
00002D9E                        @@9:
00002D9E 66B8FFFF               	mov	ax,-1
00002DA2 660BC0                 	or	ax,ax
00002DA5 C3                     	ret
00000588                        _BSS segment
00000588 00000000               @@Source	dd ?
0000058C                        _BSS ends
00002DA6                        WhiteSpaceString endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
00002DA6                        SegFormatCode	proc near
                                ;
                                ;Convert input string to segment format table layout.
                                ;
00002DA6 8BD7                   	mov	edx,edi		;get source address.
00002DA8 3E8B7D08               	mov	edi,ds:[ebp+8]	;get target address.
                                	;
00002DAC                        @@5:
00002DAC 8BF2                   	mov	esi,edx
00002DAE 803E00                 	cmp	byte ptr[esi],0		;end of input?
00002DB1 7478                   	jz	@@6
                                	;
00002DB3 BD 00000CF1o           	mov	ebp,offset SegFormatTexts	;list of strings to match against.
00002DB8                        @@0:
00002DB8 66C705 00000004o 10    	mov	ErrorNumber,16	;syntax error.
         00
00002DC1 3E837D00FF             	cmp	ds:dword ptr[ebp],-1		;end of the list?
00002DC6 0F8480000000           	jz	@@9		;not a valid statement then.
00002DCC 3E8B5D00               	mov	ebx,ds:[ebp]		;get variable text.
00002DD0 8BF2                   	mov	esi,edx		;get source string.
00002DD2                        @@1:
00002DD2 803E00                 	cmp	byte ptr[esi],0		;line end?
00002DD5 7405                   	jz	@@7
00002DD7 803E20                 	cmp	byte ptr[esi],' '		;seperator?
00002DDA 7505                   	jnz	@@3
00002DDC                        @@7:
00002DDC 803B00                 	cmp	byte ptr[ebx],0		;end of variable text as well?
00002DDF 7427                   	jz	@@4		;looks like we've got a match.
00002DE1                        @@3:
00002DE1 803E20                 	cmp	byte ptr[esi],' '		;seperator?
00002DE4 741D                   	jz	@@2		;next variable text.
00002DE6 803B00                 	cmp	byte ptr[ebx],0		;end of variable text?
00002DE9 7418                   	jz	@@2		;next variable text.
00002DEB 8A06                   	mov	al,[esi]
00002DED E87D000000             	call	UpperChar
00002DF2 86E0                   	xchg	ah,al
00002DF4 8A03                   	mov	al,[ebx]
00002DF6 E874000000             	call	UpperChar
00002DFB 3AC4                   	cmp	al,ah		;do they match?
00002DFD 7504                   	jnz	@@2
00002DFF 46                     	inc	esi
00002E00 43                     	inc	ebx
00002E01 EBCF                   	jmp	@@1		;keep looking till something happens.
                                	;
00002E03                        @@2:
00002E03 83C504                 	add	ebp,4		;next string.
00002E06 EBB0                   	jmp	@@0
                                	;
00002E08                        @@4:
00002E08 81ED 00000CF1o         	sub	ebp,offset SegFormatTexts	;get index *4
00002E0E C1ED02                 	shr	ebp,2		;get operation type.
00002E11 8BC5                   	mov	eax,ebp
00002E13 8807                   	mov	byte ptr[edi],al		;put it in the destination.
00002E15 47                     	inc	edi
00002E16 81C5 00000D1Do         	add	ebp,offset SegFormatSlots	;point at slot table.
00002E1C 3EC6450001             	mov	ds:byte ptr[ebp],1		;mark this operation type as present.
                                	;
00002E21 8BD6                   	mov	edx,esi
00002E23 803E00                 	cmp	byte ptr[esi],0		;did we finish on 0?
00002E26 7484                   	jz	@@5		;catch it up there.
00002E28 42                     	inc	edx		;skip space seperator.
00002E29 EB81                   	jmp	@@5		;scan the rest of the line.
                                	;
00002E2B                        @@6:
00002E2B C607FF                 	mov	byte ptr[edi],-1		;terminate the list.
00002E2E BE 00000D1Eo           	mov	esi,offset SegFormatSlots+1	;point at slot table. (ignore NULL entry)
00002E33 B903000000             	mov	ecx,3		;only 3 types at the moment.
00002E38 66C705 00000004o 10    	mov	ErrorNumber,16	;default to syntax error.
         00
00002E41                        @@8:
00002E41 AC                     	lodsb
00002E42 0AC0                   	or	al,al		;this entry used?
00002E44 7406                   	jz	@@9		;ALL positions have to be defined.
00002E46 E2F9                   	loop	@@8		;do them all.
                                	;
00002E48 6633C0                 	xor	ax,ax
00002E4B C3                     	ret
                                	;
00002E4C                        @@9:
00002E4C 66B8FFFF               	mov	ax,-1
00002E50 660BC0                 	or	ax,ax
00002E53 C3                     	ret
00002E54                        SegFormatCode	endp



                                ;-------------------------------------------------------------------------------
00002E54                        Bord	proc	near
                                	pushm	ax,dx
                             1  	IRP	X,<ax,dx,,,,,,,,>
 >                           1  	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1  	PUSH	X			;SAVE THE REGISTER
 >                           1  	ENDIF				;END IFNB
 >                           1  	ENDM				;END IRP
00002E54 6650                2  	PUSH	ax			;SAVE THE REGISTER
00002E56 6652                2  	PUSH	dx			;SAVE THE REGISTER
00002E58 8AE0                   	mov	ah,al
00002E5A 66BADA03               	mov	dx,3dah
00002E5E EC                     	in	al,dx
00002E5F B2C0                   	mov	dl,0c0h
00002E61 B011                   	mov	al,11h
00002E63 EE                     	out	dx,al
00002E64 8AC4                   	mov	al,ah
00002E66 EE                     	out	dx,al
00002E67 B020                   	mov	al,20h
00002E69 EE                     	out	dx,al
                                	popm	ax,dx
                             1  	IRP	X,<,,,,,,,,dx,ax> ;REPEAT FOR EACH PARM
 >                           1  	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1  	POP	X				;POP THE REGISTER
 >                           1  	ENDIF					;END IFNB
 >                           1  	ENDM					;END IRP
00002E6A 665A                2  	POP	dx				;POP THE REGISTER
00002E6C 6658                2  	POP	ax				;POP THE REGISTER
00002E6E C3                     	ret
00002E6F                        Bord	endp


                                ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-=-=-=-=-=-=-=-=-=
00002E6F                        UpperChar	proc	near
                                ;
                                ;Convert a character into upper case.
                                ;
                                ;On Entry:-
                                ;AL - Character to convert.
                                ;
                                ;On Exit:-
                                ;AL - New character code.
                                ;
00002E6F 3C61                   	cmp	al,61h		; 'a'
00002E71 7206                   	jb	@@0
00002E73 3C7A                   	cmp	al,7Ah		; 'z'
00002E75 7702                   	ja	@@0
00002E77 245F                   	and	al,5Fh
00002E79 C3                     @@0:	ret
00002E7A                        UpperChar	endp

                                ;--- get linear memory
                                ;--- in: size in ECX
                                ;--- out: linear address in ESI
                                ;--- must preserve ECX

00002E7A                        GetMemLinear32 PROC uses ecx bx di
00002E7F 51                     	push ecx
00002E80 6659                   	pop cx
00002E82 665B                   	pop bx
00002E84 66B80105               	mov ax, 501h
00002E88 CD31                   	int 31h
00002E8A 7205                   	jc fail
00002E8C 6653                   	push bx
00002E8E 6651                   	push cx
00002E90 5E                     	pop esi
00002E91                        fail:
                                	ret
00002E97                        GetMemLinear32 ENDP

                                ;--- free linear memory block
                                ;--- in: address in ESI

00002E97                        RelMemLinear32 PROC uses edi
00002E98 56                     	push esi
00002E99 665F                   	pop di
00002E9B 665E                   	pop si
00002E9D 66B80205               	mov ax, 502h
00002EA1 CD31                   	int 31h
                                	ret
00002EA5                        RelMemLinear32 ENDP

                                ;--- resize linear memory block
                                ;--- in: address in ESI, new size in ECX

00002EA5                        ResMemLinear32 PROC uses ecx edi ebx
00002EA8 56                     	push esi
00002EA9 665F                   	pop di
00002EAB 665E                   	pop si
00002EAD 51                     	push ecx
00002EAE 6659                   	pop cx
00002EB0 665B                   	pop bx
00002EB2 66B80305               	mov ax, 503h	; new size in BX:CX, handle (=address) in SI:DI
00002EB6 CD31                   	int 31h
00002EB8 6656                   	push si
00002EBA 6657                   	push di
00002EBC 5E                     	pop esi
                                	ret
00002EC1                        ResMemLinear32 ENDP

                                	include command.inc
                              C 
0000397B                      C _DATA segment
0000397B 00                   C OptionCounter	db 0
0000397C 000000000000000000   C OptionTable	db 128 dup (0)
000039FC 000000000000000000   C 	dd 128 dup (0)
00003BFC 00000000             C OptionPointer	dd ?
00003C00 000000000000000000   C OptionText	db 256 dup (0)
00003D00                      C _DATA ends
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
00002EC1                      C ReadCommand	proc	near
                              C ;
                              C ;Read the command line tail for parameters.
                              C ;
                              C ;supports / or - or + as switch/option settings. Options and names may be in
                              C ;any order, text can be tagged onto options, names must be in correct sequence
                              C ;for current program.
                              C ;
                              C ;Each character ( 33 to 127) has an entry in OptionTable & OptionTable+128.
                              C ;
                              C ;The first entry is a byte, and is 0 for OFF & none-zero for ON.
                              C ;The second entry is a pointer to any additional text specified, 0 means none.
                              C ;Entries 0-32 are reserved for text not preceded by - or + or /. These are
                              C ;intended to be file names, but neadn't be.
                              C ;All text entries are 0 terminated.
                              C ;
                              C ;To test flag:- cmp OptionTable+'?',0	;where ? is upper case character.
                              C ;To test text:- cmp w[offset OptionTable+128+('?'*2)],0
                              C ;To get text:-  mov bx,w[offset OptionTable+128+('?'*2)]
                              C ;
                              C ;To get first file name,  mov bx,w[offset OptionTable+128+0]
                              C ;       second            mov bx,w[offset OptionTable+128+2]
                              C ;
                              C ;The text gatherer will also accept : or = after the switch, eg,
                              C ;
                              C ;	Chop-Rob /aEJW1 test.pak
                              C ;	or
                              C ;	Chop-Rob /a:EJW1 test.pak
                              C ;	or
                              C ;	Chop-Rob /a=EJW1 test.pak
                              C ;
                              C ;Switches & file names may be in any position. Duplicate switch settings with
                              C ;text will store multiple text, but only the last will be addressable.
                              C ;
                              C 
00002EC1 8B1D 00000000o       C 	mov ebx, psp
00002EC7 BF 00003C00o         C 	mov	edi,offset OptionText
00002ECC 893D 00003BFCo       C 	mov	OptionPointer,edi
00002ED2 8DB380000000         C 	lea	esi,[ebx+80h]		;/
00002ED8 33C9                 C 	xor	ecx,ecx
00002EDA 8A0E                 C 	mov	cl,[esi]	;get tail length
00002EDC 80F902               C 	cmp	cl,2
00002EDF 0F8213010000         C 	jc	@@9		;not long enough!
00002EE5 8BFE                 C 	mov	edi,esi
00002EE7 03F9                 C 	add	edi,ecx
00002EE9 C6470100             C 	mov	byte ptr[edi+1],0	;terminate the tail.
00002EED 46                   C 	inc	esi		;skip length.
                              C 	;
00002EEE                      C @@0:
00002EEE 8A06                 C 	mov	al,[esi]		;need to skip leading spaces.
00002EF0 46                   C 	inc	esi		;/
00002EF1 0AC0                 C 	or	al,al		;/
00002EF3 0F84FF000000         C 	jz	@@9		;/
00002EF9 3C20                 C 	cmp	al,' '		;/
00002EFB 74F1                 C 	jz	@@0		;/
00002EFD 4E                   C 	dec	esi		;/
                              C 	;
00002EFE                      C @@1:
00002EFE 803E2F               C 	cmp	byte ptr[esi],'/'	;option switch?
00002F01 7474                 C 	jz	@@Option		;/
00002F03 803E2D               C 	cmp	byte ptr[esi],'-'	;/
00002F06 746F                 C 	jz	@@Option		;/
00002F08 803E2B               C 	cmp	byte ptr[esi],'+'	;/
00002F0B 746A                 C 	jz	@@Option		;/
                              C 	;
00002F0D                      C @@2:
00002F0D 33DB                 C 	xor	ebx,ebx		;/
00002F0F 8A1D 0000397Bo       C 	mov	bl,OptionCounter	;Get file entry number.
00002F15 FE05 0000397Bo       C 	inc	OptionCounter	;/
00002F1B C1E302               C 	shl	ebx,2		;/
00002F1E 81C3 000039FCo       C 	add	ebx,offset OptionTable+128 ;/
00002F24 8B3D 00003BFCo       C 	mov	edi,OptionPointer	;Current free space pointer.
00002F2A 893B                 C 	mov	[ebx],edi		;update table entry.
                              C 	;
00002F2C 32C9                 C 	xor	cl,cl
00002F2E                      C @@3:
00002F2E 803E00               C 	cmp	byte ptr[esi],0		;end of name?
00002F31 740F                 C 	jz	@@4		;/
00002F33 803E20               C 	cmp	byte ptr[esi],' '	;/
00002F36 740A                 C 	jz	@@4		;/
00002F38 8A06                 C 	mov	al,[esi]		;Copy this character.
00002F3A 8807                 C 	mov	[edi],al		;/
00002F3C 46                   C 	inc	esi		;/
00002F3D 47                   C 	inc	edi		;/
00002F3E B101                 C 	mov	cl,1		;flag SOMETHING found.
00002F40 EBEC                 C 	jmp	@@3		;keep fetching them.
                              C 	;
00002F42                      C @@4:
00002F42 C60700               C 	mov	byte ptr[edi],0		;Terminate the name.
00002F45 47                   C 	inc	edi		;/
00002F46 893D 00003BFCo       C 	mov	OptionPointer,edi	;Update table pointer.
                              C 	;
00002F4C 0AC9                 C 	or	cl,cl		;Make sure we found something.
00002F4E 759E                 C 	jnz	@@0		;Go look for more info.
00002F50 FF0D 00003BFCo       C 	dec	OptionPointer
00002F56 FE0D 0000397Bo       C 	dec	OptionCounter	;move pointer/counter back.
00002F5C 33DB                 C 	xor	ebx,ebx
00002F5E 8A1D 0000397Bo       C 	mov	bl,OptionCounter	;Get file entry number.
00002F64 C1E302               C 	shl	ebx,2		;/
00002F67 81C3 000039FCo       C 	add	ebx,offset OptionTable+128 ;/
00002F6D 66C7030000           C 	mov	word ptr[ebx],0		;reset table entry.
00002F72 E977FFFFFF           C 	jmp	@@0
                              C 	;
00002F77                      C @@Option:
00002F77 8A26                 C 	mov	ah,[esi]		;Get switch character.
00002F79 46                   C 	inc	esi
00002F7A                      C @@5:
00002F7A 803E00               C 	cmp	byte ptr[esi],0		;check for end of line.
00002F7D 7479                 C 	jz	@@9		;/
00002F7F 803E20               C 	cmp	byte ptr[esi],' '	;skip spaces.
00002F82 7503                 C 	jnz	@@6		;/
00002F84 46                   C 	inc	esi		;/
00002F85 EBF3                 C 	jmp	@@5		;/
                              C 	;
00002F87                      C @@6:
00002F87 8A06                 C 	mov	al,[esi]		;get the switched character.
00002F89 247F                 C 	and	al,127
00002F8B 46                   C 	inc	esi
00002F8C 3C61                 C 	cmp	al,61h		; 'a'
00002F8E 7206                 C 	jb	@@12
00002F90 3C7A                 C 	cmp	al,7Ah		; 'z'
00002F92 7702                 C 	ja	@@12
00002F94 245F                 C 	and	al,5Fh		;convert to upper case.
00002F96                      C @@12:
00002F96 33DB                 C 	xor	ebx,ebx
00002F98 8AD8                 C 	mov	bl,al
00002F9A 81C3 0000397Co       C 	add	ebx,offset OptionTable	;Index into the table.
00002FA0 80FC2D               C 	cmp	ah,'-'
00002FA3 7502                 C 	jnz	@@7
00002FA5 32E4                 C 	xor	ah,ah		;Convert '-' to zero.
00002FA7                      C @@7:
00002FA7 8823                 C 	mov	[ebx],ah		;Set flag accordingly.
                              C 	;
00002FA9 803E20               C 	cmp	byte ptr[esi],' '	;check for assosiated text.
00002FAC 0F843CFFFFFF         C 	jz	@@0
00002FB2 803E00               C 	cmp	byte ptr[esi],0
00002FB5 7441                 C 	jz	@@9
00002FB7 803E3D               C 	cmp	byte ptr[esi],'='
00002FBA 7405                 C 	jz	@@900
00002FBC 803E3A               C 	cmp	byte ptr[esi],':'	;allow colon as seperator.
00002FBF 7501                 C 	jnz	@@8
00002FC1                      C @@900:
00002FC1 46                   C 	inc	esi		;skip colon.
                              C 	;
00002FC2                      C @@8:
00002FC2 33DB                 C 	xor	ebx,ebx
00002FC4 8AD8                 C 	mov	bl,al		;Get the option number again.
00002FC6 C1E302               C 	shl	ebx,2		; &
00002FC9 81C3 000039FCo       C 	add	ebx,offset OptionTable+128 ;index into the table.
00002FCF 8B3D 00003BFCo       C 	mov	edi,OptionPointer	;current position in the table.
00002FD5 893B                 C 	mov	[ebx],edi		;store pointer in the table.
                              C 	;
00002FD7                      C @@10:
00002FD7 803E00               C 	cmp	byte ptr[esi],0		;end of line?
00002FDA 741C                 C 	jz	@@9
00002FDC 803E20               C 	cmp	byte ptr[esi],' '	;end of text?
00002FDF 7408                 C 	jz	@@11
00002FE1 8A06                 C 	mov	al,[esi]
00002FE3 8807                 C 	mov	[edi],al
00002FE5 46                   C 	inc	esi
00002FE6 47                   C 	inc	edi
00002FE7 EBEE                 C 	jmp	@@10
                              C 	;
00002FE9                      C @@11:
00002FE9 C60700               C 	mov	byte ptr[edi],0		;terminate string.
00002FEC 47                   C 	inc	edi
00002FED 893D 00003BFCo       C 	mov	OptionPointer,edi	;store new text pointer.
00002FF3 E9F6FEFFFF           C 	jmp	@@0		;scan some more text.
00002FF8                      C @@9:
00002FF8 A0 0000397Bo         C 	mov	al,OptionCounter
00002FFD 32E4                 C 	xor	ah,ah
00002FFF 660BC0               C 	or	ax,ax		;set flags for file names.
00003002 8B1D 000039FCo       C 	mov	ebx,dword ptr[OptionTable+128]	;point to first file name.
00003008 C3                   C 	ret
                              C ;
00003009                      C ReadCommand	endp
                              C 
                                	include files.inc
                              C 
00003D00                      C _DATA segment
                              C 
00003D00 00000000             C FileBufferCount dd 0
00003D04 00000000             C FileBufferPosition dd 0
                              C 
00003D08 FFFFFFFFFFFFFFFFFF   C OpenFilesList	dw 60 dup (-1)	;Enough for 60 files.
                              C 
00003D80                      C _DATA ends
                              C 
0000058C                      C _BSS segment 
0000058C 000000000000000000   C FileBuffer	db 2048 dup (?)
00000D8C                      C _BSS ends
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
00003009                      C OpenFile	proc	near
                              C ;
                              C ;Open a file and if succesful, add its handle to the list.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;DS:EDX	- File name pointer as normal.
                              C ;
                              C ;On Exit:-
                              C ;
                              C ;If carry clear,
                              C ;AX	- Handle for file.
                              C ;
                              C ;else file not opened.
                              C ;
00003009 66B8023D             C 	mov	ax,3d02h		;Open with read & write access.
0000300D CD21                 C 	int	21h
0000300F 721F                 C 	jc	@@9
                              C 	;
00003011 53                   C 	push	ebx
00003012 51                   C 	push	ecx
00003013 BB 00003D08o         C 	mov	ebx,offset OpenFilesList	;Point at the list.
00003018 B93C000000           C 	mov	ecx,60
0000301D 66833BFF             C @@0:	cmp	word ptr[ebx],-1		;free entry?
00003021 7407                 C 	jz	@@1
00003023 83C302               C 	add	ebx,2		;next entry.
00003026 E2F5                 C 	loop	@@0
00003028 EB07                 C 	jmp	@@8
0000302A 668903               C @@1:	mov	[ebx],ax		;store this handle.
0000302D 59                   C 	pop	ecx
0000302E 5B                   C 	pop	ebx
0000302F F8                   C 	clc			;restore sucess flag.
00003030 C3                   C @@9:	ret
                              C 	;
00003031 668BD8               C @@8:	mov	bx,ax
00003034 B43E                 C 	mov	ah,3eh		;close again cos not enough table space.
00003036 CD21                 C 	int	21h
00003038 59                   C 	pop	ecx
00003039 5B                   C 	pop	ebx
0000303A F9                   C 	stc
0000303B C3                   C 	ret
0000303C                      C OpenFile	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
0000303C                      C CreateFile	proc	near
                              C ;
                              C ;Create a file and if succesful, add its handle to the list.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;DS:EDX	- File name pointer as normal.
                              C ;
                              C ;On Exit:-
                              C ;
                              C ;If carry clear,
                              C ;AX	- Handle for file.
                              C ;
                              C ;else file not created.
                              C ;
0000303C B43C                 C 	mov	ah,3ch		;Create function.
0000303E 6633C9               C 	xor	cx,cx		;normal attributes.
00003041 CD21                 C 	int	21h
00003043 721F                 C 	jc	@@9
                              C 	;
00003045 53                   C 	push	ebx
00003046 51                   C 	push	ecx
00003047 BB 00003D08o         C 	mov	ebx,offset OpenFilesList	;Point at the list.
0000304C B93C000000           C 	mov	ecx,60
00003051 66833BFF             C @@0:	cmp	word ptr[ebx],-1		;free entry?
00003055 7407                 C 	jz	@@1
00003057 83C302               C 	add	ebx,2		;next entry.
0000305A E2F5                 C 	loop	@@0
0000305C EB07                 C 	jmp	@@8
0000305E 668903               C @@1:	mov	[ebx],ax		;store this handle.
00003061 59                   C 	pop	ecx
00003062 5B                   C 	pop	ebx
00003063 F8                   C 	clc			;restore sucess flag.
00003064 C3                   C @@9:	ret
                              C 	;
00003065 668BD8               C @@8:	mov	bx,ax
00003068 B43E                 C 	mov	ah,3eh		;close again cos not enough table space.
0000306A CD21                 C 	int	21h
0000306C 59                   C 	pop	ecx
0000306D 5B                   C 	pop	ebx
0000306E F9                   C 	stc
0000306F C3                   C 	ret
00003070                      C CreateFile	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
00003070                      C SetFilePointer	proc	near
                              C ;
                              C ;Set the file pointer position for a file.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;AL	- Method
                              C ;BX	- Handle
                              C ;DX:CX	- 32-bit position.
                              C ;
                              C ;Methods are:-
                              C ;
                              C ;0	- Absolute offset from start.
                              C ;1	- signed offset from current position.
                              C ;2	- signed offset from end of file.
                              C ;
00003070 6687D1               C 	xchg	dx,cx		;DOS has them in a stupid order.
00003073 6653                 C 	push	bx
00003075 B442                 C 	mov	ah,42h		;set pointer function.
00003077 CD21                 C 	int	21h
00003079 665B                 C 	pop	bx
0000307B 668BC8               C 	mov	cx,ax		;fetch small result.
0000307E C3                   C 	ret
0000307F                      C SetFilePointer	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
0000307F                      C ReadFile	proc	near
                              C ;
                              C ;Read some data from a file.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;BX	- Handle
                              C ;ECX	- Length
                              C ;EDI	- Position.
                              C ;
0000307F 33D2                 C 	xor	edx,edx
00003081                      C @@0:
                              C 	pushm	bx,ecx,edx,edi
                             1C 	IRP	X,<bx,ecx,edx,edi,,,,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
00003081 6653                2C 	PUSH	bx			;SAVE THE REGISTER
00003083 51                  2C 	PUSH	ecx			;SAVE THE REGISTER
00003084 52                  2C 	PUSH	edx			;SAVE THE REGISTER
00003085 57                  2C 	PUSH	edi			;SAVE THE REGISTER
00003086 81F9FFFF0000         C 	cmp	ecx,65535		;size of chunks to load.
0000308C 7205                 C 	jc	@@2
0000308E B9FFFF0000           C 	mov	ecx,65535		;as close to 64k as can get.
00003093 8BD7                 C @@2:	mov	edx,edi
00003095 B43F                 C 	mov	ah,3fh
00003097 CD21                 C 	int	21h		;read from the file.
                              C 	popm	bx,ecx,edx,edi
                             1C 	IRP	X,<,,,,,,edi,edx,ecx,bx> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
00003099 5F                  2C 	POP	edi				;POP THE REGISTER
0000309A 5A                  2C 	POP	edx				;POP THE REGISTER
0000309B 59                  2C 	POP	ecx				;POP THE REGISTER
0000309C 665B                2C 	POP	bx				;POP THE REGISTER
0000309E 7217                 C 	jc	@@9
000030A0 0FB7C0               C 	movzx	eax,ax		;get length read.
000030A3 03D0                 C 	add	edx,eax		;update length read counter.
000030A5 2BC8                 C 	sub	ecx,eax		;update length counter.
000030A7 03F8                 C 	add	edi,eax		;move memory pointer.
000030A9 0BC9                 C 	or	ecx,ecx
000030AB 7406                 C 	jz	@@8		;read as much as was wanted.
000030AD 0BC0                 C 	or	eax,eax		;did we read anything?
000030AF 7402                 C 	jz	@@8
000030B1 EBCE                 C 	jmp	@@0
000030B3 8BC2                 C @@8:	mov	eax,edx		;get accumulated length read.
000030B5 F8                   C 	clc
000030B6 C3                   C 	ret
                              C 	;
000030B7 F9                   C @@9:	stc
000030B8 C3                   C 	ret
000030B9                      C ReadFile	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
000030B9                      C WriteFile	proc	near
                              C ;
                              C ;Write some data to a file.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;BX	- Handle
                              C ;ECX	- Length
                              C ;ESI	- Position.
                              C ;
000030B9 33D2                 C 	xor	edx,edx
000030BB                      C @@0:
                              C 	pushm	bx,ecx,edx,esi
                             1C 	IRP	X,<bx,ecx,edx,esi,,,,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
000030BB 6653                2C 	PUSH	bx			;SAVE THE REGISTER
000030BD 51                  2C 	PUSH	ecx			;SAVE THE REGISTER
000030BE 52                  2C 	PUSH	edx			;SAVE THE REGISTER
000030BF 56                  2C 	PUSH	esi			;SAVE THE REGISTER
000030C0 81F9FFFF0000         C 	cmp	ecx,65535		;size of chunks to load.
000030C6 7205                 C 	jc	@@2
000030C8 B9FFFF0000           C 	mov	ecx,65535		;as close to 64k as can get.
000030CD 8BD6                 C @@2:	mov	edx,esi
000030CF B440                 C 	mov	ah,40h
000030D1 CD21                 C 	int	21h		;read from the file.
                              C 	popm	bx,ecx,edx,esi
                             1C 	IRP	X,<,,,,,,esi,edx,ecx,bx> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
000030D3 5E                  2C 	POP	esi				;POP THE REGISTER
000030D4 5A                  2C 	POP	edx				;POP THE REGISTER
000030D5 59                  2C 	POP	ecx				;POP THE REGISTER
000030D6 665B                2C 	POP	bx				;POP THE REGISTER
000030D8 7217                 C 	jc	@@9
000030DA 0FB7C0               C 	movzx	eax,ax		;get length read.
000030DD 03D0                 C 	add	edx,eax		;update length read counter.
000030DF 2BC8                 C 	sub	ecx,eax		;update length counter.
000030E1 03F0                 C 	add	esi,eax		;move memory pointer.
000030E3 0BC9                 C 	or	ecx,ecx
000030E5 7406                 C 	jz	@@8		;read as much as was wanted.
000030E7 0BC0                 C 	or	eax,eax		;did we write anything?
000030E9 7406                 C 	jz	@@9
000030EB EBCE                 C 	jmp	@@0
000030ED 8BC2                 C @@8:	mov	eax,edx		;get accumulated length read.
000030EF F8                   C 	clc
000030F0 C3                   C 	ret
                              C 	;
000030F1 F9                   C @@9:	stc
000030F2 C3                   C 	ret
000030F3                      C WriteFile	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
000030F3                      C CloseFile	proc	near
                              C ;
                              C ;Close a file and delete its handle from the list.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;BX	- Handle for file to close.
                              C ;
                              C 	pushm	ax,ebx,ecx
                             1C 	IRP	X,<ax,ebx,ecx,,,,,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
000030F3 6650                2C 	PUSH	ax			;SAVE THE REGISTER
000030F5 53                  2C 	PUSH	ebx			;SAVE THE REGISTER
000030F6 51                  2C 	PUSH	ecx			;SAVE THE REGISTER
000030F7 668BC3               C 	mov	ax,bx
000030FA BB 00003D08o         C 	mov	ebx,offset OpenFilesList	;Point at the list.
000030FF B93C000000           C 	mov	ecx,60
00003104 663903               C @@0:	cmp	[ebx],ax		;right entry?
00003107 7407                 C 	jz	@@1
00003109 83C302               C 	add	ebx,2		;next entry.
0000310C E2F6                 C 	loop	@@0
0000310E EB0E                 C 	jmp	@@9
00003110 66C703FFFF           C @@1:	mov	word ptr[ebx],-1		;clear this handle.
                              C 	popm	ax,ebx,ecx
                             1C 	IRP	X,<,,,,,,,ecx,ebx,ax> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
00003115 59                  2C 	POP	ecx				;POP THE REGISTER
00003116 5B                  2C 	POP	ebx				;POP THE REGISTER
00003117 6658                2C 	POP	ax				;POP THE REGISTER
00003119 B43E                 C 	mov	ah,3eh		;close file function.
0000311B CD21                 C 	int	21h
0000311D C3                   C 	ret
0000311E                      C @@9:
                              C 	popm	ax,ebx,ecx
                             1C 	IRP	X,<,,,,,,,ecx,ebx,ax> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
0000311E 59                  2C 	POP	ecx				;POP THE REGISTER
0000311F 5B                  2C 	POP	ebx				;POP THE REGISTER
00003120 6658                2C 	POP	ax				;POP THE REGISTER
00003122 F9                   C 	stc
00003123 C3                   C 	ret
00003124                      C CloseFile	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
00003124                      C CloseAllFiles	proc	near
                              C ;
                              C ;Close all files in the list.
                              C ;
00003124 6650                 C 	push	ax
00003126 53                   C 	push	ebx
00003127 51                   C 	push	ecx
00003128 BB 00003D08o         C 	mov	ebx,offset OpenFilesList	;Point at the list.
0000312D B93C000000           C 	mov	ecx,60		;size OpenFilesList /2
00003132 66833B00             C @@0:	cmp	word ptr[ebx],0		;used entry?
00003136 750A                 C 	jnz	@@2
00003138 83C302               C @@1:	add	ebx,2		;next entry.
0000313B E2F5                 C 	loop	@@0
0000313D 59                   C 	pop	ecx
0000313E 5B                   C 	pop	ebx
0000313F 6658                 C 	pop	ax
00003141 C3                   C 	ret
00003142 53                   C @@2:	push	ebx
00003143 51                   C 	push	ecx
00003144 668B1B               C 	mov	bx,[ebx]		;get this handle.
00003147 B43E                 C 	mov	ah,3eh		;close file function.
00003149 CD21                 C 	int	21h
0000314B 59                   C 	pop	ecx
0000314C 5B                   C 	pop	ebx
0000314D EBE9                 C 	jmp	@@1
0000314F                      C CloseAllFiles	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
0000314F                      C DeleteFile	proc	near
                              C ;
                              C ;Delete a file.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;DS:EDX	- File name to delete.
                              C ;
0000314F B441                 C 	mov	ah,41h
00003151 CD21                 C 	int	21h
00003153 C3                   C 	ret
00003154                      C DeleteFile	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
00003154                      C ReadLine	proc	near
                              C ;
                              C ;Read a line of text from input file specified.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;BX	- File handle.
                              C ;DS:EDI	- Buffer address.
                              C ;
                              C ;On Exit:-
                              C ;
                              C ;AX	- Status.
                              C ;	0 - Line is in the buffer.
                              C ;	1 - EOF.
                              C ;
                              C ;CX	- Line length.
                              C ;
00003154 6633C9               C 	xor	cx,cx		;reset bytes so far count.
00003157                      C @@0:
                              C ;	pushm	bx,cx,edi
                              C 
00003157 E873000000           C 	call	ReadBufferByte
                              C 
                              C ;	mov	edx,edi
                              C ;	mov	cx,1
                              C ;	mov	ah,3fh
                              C ;	int	21h		;read a byte.
                              C 
                              C ;	popm	bx,cx,edi
0000315C 7264                 C 	jc	@@9
0000315E 660BC0               C 	or	ax,ax		;read anything?
00003161 7451                 C 	jz	@@CheckEOF
00003163 803F0D               C 	cmp	byte ptr[edi],13		;EOL?
00003166 7411                 C 	jz	@@CheckLF
00003168 803F1A               C 	cmp	byte ptr[edi],26
0000316B 7427                 C 	jz	@@SoftEOF		;move to the end of the file, then do an EOL.
0000316D 47                   C 	inc	edi
0000316E 6641                 C 	inc	cx
00003170 6681F90004           C 	cmp	cx,1024		;line getting a bit long?
00003175 731D                 C 	jnc	@@SoftEOF
00003177 EBDE                 C 	jmp	@@0		;keep going.
                              C 	;
00003179 C60700               C @@CheckLF:	mov	byte ptr[edi],0		;terminate this line.
0000317C 47                   C 	inc	edi
                              C ;	pushm	bx,cx,edi
                              C 
0000317D E84D000000           C 	call	ReadBufferByte
                              C 
                              C ;	mov	edx,edi
                              C ;	mov	cx,1
                              C ;	mov	ah,3fh
                              C ;	int	21h		;read a byte.
                              C 
                              C ;	popm	bx,cx,edi
00003182 660BC0               C 	or	ax,ax		;read anything?
00003185 743B                 C 	jz	@@9		;no LF here is an error.
00003187 803F0A               C 	cmp	byte ptr[edi],10		;/
0000318A 7536                 C 	jnz	@@9		;/
                              C 	;
0000318C C60700               C @@EOL:	mov	byte ptr[edi],0		;terminate the line.
0000318F 6633C0               C 	xor	ax,ax
00003192 F8                   C 	clc
00003193 C3                   C 	ret
                              C 	;
00003194                      C @@SoftEOF:
                              C 	pushm	bx,cx,edi
                             1C 	IRP	X,<bx,cx,edi,,,,,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
00003194 6653                2C 	PUSH	bx			;SAVE THE REGISTER
00003196 6651                2C 	PUSH	cx			;SAVE THE REGISTER
00003198 57                  2C 	PUSH	edi			;SAVE THE REGISTER
00003199 6633C9               C 	xor	cx,cx
0000319C 668BD1               C 	mov	dx,cx
0000319F 66B80242             C 	mov	ax,4202h		;move to the end of the file.
000031A3 CD21                 C 	int	21h
                              C 	popm	bx,cx,edi		;fall through to treat like hard EOF.
                             1C 	IRP	X,<,,,,,,,edi,cx,bx> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
000031A5 5F                  2C 	POP	edi				;POP THE REGISTER
000031A6 6659                2C 	POP	cx				;POP THE REGISTER
000031A8 665B                2C 	POP	bx				;POP THE REGISTER
000031AA C705 00003D00o 00    C 	mov	FileBufferCount,0
         000000
                              C 	;
000031B4 660BC9               C @@CheckEOF:	or	cx,cx		;read anything on this line yet?
000031B7 75D3                 C 	jnz	@@EOL		;do EOL this time.
                              C 	;
000031B9 C60700               C @@EOF:	mov	byte ptr[edi],0		;terminate the line.
000031BC 66B80100             C 	mov	ax,1
000031C0 F8                   C 	clc
000031C1 C3                   C 	ret
                              C 	;
000031C2 F9                   C @@9:	stc
000031C3 C3                   C 	ret
000031C4                      C ReadLine	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
000031C4                      C InitFileBuffer	proc	near
000031C4 C705 00003D00o 00    C 	mov	FileBufferCount,0
         000000
000031CE C3                   C 	ret
000031CF                      C InitFileBuffer	endp
                              C 
                              C 
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
000031CF                      C ReadBufferByte	proc	near
000031CF 66B80000             C 	mov	ax,0
000031D3 833D 00003D00o 00    C 	cmp	FileBufferCount,0
000031DA 752E                 C 	jnz	@@0
                              C 	;
                              C 	;Need to re-fill the buffer.
                              C 	;
                              C 	pushm	eax,ebx,ecx,edx,esi,edi,ebp
                             1C 	IRP	X,<eax,ebx,ecx,edx,esi,edi,ebp,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
000031DC 50                  2C 	PUSH	eax			;SAVE THE REGISTER
000031DD 53                  2C 	PUSH	ebx			;SAVE THE REGISTER
000031DE 51                  2C 	PUSH	ecx			;SAVE THE REGISTER
000031DF 52                  2C 	PUSH	edx			;SAVE THE REGISTER
000031E0 56                  2C 	PUSH	esi			;SAVE THE REGISTER
000031E1 57                  2C 	PUSH	edi			;SAVE THE REGISTER
000031E2 55                  2C 	PUSH	ebp			;SAVE THE REGISTER
000031E3 BF 0000058Co         C 	mov	edi,offset FileBuffer
000031E8 B900040000           C 	mov	ecx,1024
000031ED E88DFEFFFF           C 	call	ReadFile
000031F2 A3 00003D00o         C 	mov	FileBufferCount,eax
000031F7 C705 00003D04o       C 	mov	FileBufferPosition,offset FileBuffer
         0000058Co
                              C 	popm	eax,ebx,ecx,edx,esi,edi,ebp
                             1C 	IRP	X,<,,,ebp,edi,esi,edx,ecx,ebx,eax> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
00003201 5D                  2C 	POP	ebp				;POP THE REGISTER
00003202 5F                  2C 	POP	edi				;POP THE REGISTER
00003203 5E                  2C 	POP	esi				;POP THE REGISTER
00003204 5A                  2C 	POP	edx				;POP THE REGISTER
00003205 59                  2C 	POP	ecx				;POP THE REGISTER
00003206 5B                  2C 	POP	ebx				;POP THE REGISTER
00003207 58                  2C 	POP	eax				;POP THE REGISTER
00003208 7223                 C 	jc	@@9
                              C 	;
0000320A                      C @@0:
0000320A 833D 00003D00o 00    C 	cmp	FileBufferCount,0	;still zero?
00003211 7419                 C 	jz	@@8
00003213 6640                 C 	inc	ax		;getting a byte then.
                              C 	pushm	esi,edi
                             1C 	IRP	X,<esi,edi,,,,,,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
00003215 56                  2C 	PUSH	esi			;SAVE THE REGISTER
00003216 57                  2C 	PUSH	edi			;SAVE THE REGISTER
00003217 8B35 00003D04o       C 	mov	esi,FileBufferPosition
0000321D A4                   C 	movsb
0000321E 8935 00003D04o       C 	mov	FileBufferPosition,esi
00003224 FF0D 00003D00o       C 	dec	FileBufferCount
                              C 	popm	esi,edi
                             1C 	IRP	X,<,,,,,,,,edi,esi> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
0000322A 5F                  2C 	POP	edi				;POP THE REGISTER
0000322B 5E                  2C 	POP	esi				;POP THE REGISTER
                              C 	;
0000322C                      C @@8:
0000322C F8                   C 	clc
0000322D                      C @@9:
0000322D C3                   C 	ret
0000322E                      C ReadBufferByte	endp
                              C 
                                	include print.inc
                              C ;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
0000322E                      C StringPrint	proc	near
                              C ;
                              C ;Print characters on the screen.
                              C ;
                              C ;On Entry:-
                              C ;
                              C ;DS:EDX	- String (0 terminated)
                              C ;
                              C ;ALL registers preserved.
                              C ;
                              C 	pushm	eax,ebx,ecx,edx,esi,edi,ebp
                             1C 	IRP	X,<eax,ebx,ecx,edx,esi,edi,ebp,,,>
 >                           1C 	IFNB	<X>			;IF THIS PARM NOT BLANK
 >                           1C 	PUSH	X			;SAVE THE REGISTER
 >                           1C 	ENDIF				;END IFNB
 >                           1C 	ENDM				;END IRP
0000322E 50                  2C 	PUSH	eax			;SAVE THE REGISTER
0000322F 53                  2C 	PUSH	ebx			;SAVE THE REGISTER
00003230 51                  2C 	PUSH	ecx			;SAVE THE REGISTER
00003231 52                  2C 	PUSH	edx			;SAVE THE REGISTER
00003232 56                  2C 	PUSH	esi			;SAVE THE REGISTER
00003233 57                  2C 	PUSH	edi			;SAVE THE REGISTER
00003234 55                  2C 	PUSH	ebp			;SAVE THE REGISTER
00003235 8BF2                 C 	mov	esi,edx
00003237                      C @@0:
00003237 8A06                 C 	mov	al,[esi]
00003239 46                   C 	inc	esi
0000323A 0AC0                 C 	or	al,al
0000323C 740A                 C 	jz	@@9
0000323E 56                   C 	push	esi
0000323F 8AD0                 C 	mov	dl,al
00003241 B402                 C 	mov	ah,2
00003243 CD21                 C 	int	21h
00003245 5E                   C 	pop	esi
00003246 EBEF                 C 	jmp	@@0
00003248                      C @@9:
                              C 	popm	eax,ebx,ecx,edx,esi,edi,ebp
                             1C 	IRP	X,<,,,ebp,edi,esi,edx,ecx,ebx,eax> ;REPEAT FOR EACH PARM
 >                           1C 	IFNB	<X>				;IF THIS PARM NOT BLANK
 >                           1C 	POP	X				;POP THE REGISTER
 >                           1C 	ENDIF					;END IFNB
 >                           1C 	ENDM					;END IRP
00003248 5D                  2C 	POP	ebp				;POP THE REGISTER
00003249 5F                  2C 	POP	edi				;POP THE REGISTER
0000324A 5E                  2C 	POP	esi				;POP THE REGISTER
0000324B 5A                  2C 	POP	edx				;POP THE REGISTER
0000324C 59                  2C 	POP	ecx				;POP THE REGISTER
0000324D 5B                  2C 	POP	ebx				;POP THE REGISTER
0000324E 58                  2C 	POP	eax				;POP THE REGISTER
0000324F C3                   C 	ret
00003250                      C StringPrint	endp
                              C 
                              C 
                              C 

                                ifndef CWAPP
                                 if @Model ne 7
                                 endif
                                endif

                                	end start


Macros:

                N a m e                 Type

@CatStr  . . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func
@dprintf . . . . . . . . . . . .        Proc
Popm . . . . . . . . . . . . . .        Proc
Pushm  . . . . . . . . . . . . .        Proc


Structures and Unions:

                N a m e                 Size/Ofs   Type

Desc . . . . . . . . . . . . . .               8
  Limit  . . . . . . . . . . . .               0   Word
  Base_l . . . . . . . . . . . .               2   Word
  Base_m . . . . . . . . . . . .               4   Byte
  Access . . . . . . . . . . . .               5   Byte
  Gran . . . . . . . . . . . . .               6   Byte
  Base_H . . . . . . . . . . . .               7   Byte
GATE . . . . . . . . . . . . . .               8
  OfsLow . . . . . . . . . . . .               0   Word
  sel  . . . . . . . . . . . . .               2   Word
  attr . . . . . . . . . . . . .               4   Word
  OfsHigh  . . . . . . . . . . .               6   Word
LE_Header  . . . . . . . . . . .              C4
  LE_ID  . . . . . . . . . . . .               0   Word
  LE_ByteOrder . . . . . . . . .               2   Byte
  LE_WordOrder . . . . . . . . .               3   Byte
  LE_Format  . . . . . . . . . .               4   DWord
  LE_CPU . . . . . . . . . . . .               8   Word
  LE_OS  . . . . . . . . . . . .               A   Word
  LE_Version . . . . . . . . . .               C   DWord
  LE_Type  . . . . . . . . . . .              10   DWord
  LE_Pages . . . . . . . . . . .              14   DWord
  LE_EntryCS . . . . . . . . . .              18   DWord
  LE_EntryEIP  . . . . . . . . .              1C   DWord
  LE_EntrySS . . . . . . . . . .              20   DWord
  LE_EntryESP  . . . . . . . . .              24   DWord
  LE_PageSize  . . . . . . . . .              28   DWord
  LE_LastBytes . . . . . . . . .              2C   DWord
  LE_FixupSize . . . . . . . . .              30   DWord
  LE_FixupChk  . . . . . . . . .              34   DWord
  LE_LoaderSize  . . . . . . . .              38   DWord
  LE_LoaderChk . . . . . . . . .              3C   DWord
  LE_ObjOffset . . . . . . . . .              40   DWord
  LE_ObjNum  . . . . . . . . . .              44   DWord
  LE_PageMap . . . . . . . . . .              48   DWord
  LE_IterateMap  . . . . . . . .              4C   DWord
  LE_Resource  . . . . . . . . .              50   DWord
  LE_ResourceNum . . . . . . . .              54   DWord
  LE_ResidentNames . . . . . . .              58   DWord
  LE_EntryTable  . . . . . . . .              5C   DWord
  LE_Directives  . . . . . . . .              60   DWord
  LE_DirectivesNum . . . . . . .              64   DWord
  LE_Fixups  . . . . . . . . . .              68   DWord
  LE_FixupsRec . . . . . . . . .              6C   DWord
  LE_ImportModNames  . . . . . .              70   DWord
  LE_ImportModNum  . . . . . . .              74   DWord
  LE_ImportNames . . . . . . . .              78   DWord
  LE_PageChk . . . . . . . . . .              7C   DWord
  LE_Data  . . . . . . . . . . .              80   DWord
  LE_PreLoadNum  . . . . . . . .              84   DWord
  LE_NoneRes . . . . . . . . . .              88   DWord
  LE_NoneResSize . . . . . . . .              8C   DWord
  LE_NoneResChk  . . . . . . . .              90   DWord
  LE_AutoDS  . . . . . . . . . .              94   DWord
  LE_Debug . . . . . . . . . . .              98   DWord
  LE_DebugSize . . . . . . . . .              9C   DWord
  LE_PreLoadInstNum  . . . . . .              A0   DWord
  LE_DemandInstNum . . . . . . .              A4   DWord
  LE_HeapExtra . . . . . . . . .              A8   DWord
  LE_Reserved  . . . . . . . . .              AC   Byte[20]
  LE_DeviceID  . . . . . . . . .              C0   Word
  LE_DDK . . . . . . . . . . . .              C2   Word
MZHdr  . . . . . . . . . . . . .              1B
  Signature  . . . . . . . . . .               0   Word
  _Length  . . . . . . . . . . .               2   Word
  RelocNum . . . . . . . . . . .               6   Word
  HeaderSize . . . . . . . . . .               8   Word
  MinAlloc . . . . . . . . . . .               A   Word
  MaxAlloc . . . . . . . . . . .               C   Word
  StackSeg . . . . . . . . . . .               E   Word
  EntrySP  . . . . . . . . . . .              10   Word
  CheckSum . . . . . . . . . . .              12   Word
  EntryIP  . . . . . . . . . . .              14   Word
  EntryCS  . . . . . . . . . . .              16   Word
  RelocFirst . . . . . . . . . .              18   Word
  OverlayNum . . . . . . . . . .              1A   Byte
NewHeaderStruc . . . . . . . . .              40
  NewID  . . . . . . . . . . . .               0   Byte[2]
  NewSize  . . . . . . . . . . .               2   DWord
  NewLength  . . . . . . . . . .               6   DWord
  NewAlloc . . . . . . . . . . .               A   DWord
  NewSegments  . . . . . . . . .               E   Word
  NewRelocs  . . . . . . . . . .              10   DWord
  NewEntryEIP  . . . . . . . . .              14   DWord
  NewEntryCS . . . . . . . . . .              18   Word
  NewEntryESP  . . . . . . . . .              1A   DWord
  NewEntrySS . . . . . . . . . .              1E   Word
  NewFlags . . . . . . . . . . .              20   DWord
  NewAutoStack . . . . . . . . .              24   DWord
  NewAutoDS  . . . . . . . . . .              28   Word
  NewExports . . . . . . . . . .              2A   DWord
  NewImports . . . . . . . . . .              2E   DWord
  NewImportModCnt  . . . . . . .              32   DWord
  NewReserved  . . . . . . . . .              36   Byte[10]
PSP_Struc  . . . . . . . . . . .             100
  PSP_INT20  . . . . . . . . . .               0   Word
  PSP_MemTop . . . . . . . . . .               2   Word
  PSP_Filler1  . . . . . . . . .               4   Byte
  PSP_CPM  . . . . . . . . . . .               5   Byte
  PSP_INT22  . . . . . . . . . .               A   DWord
  PSP_INT23  . . . . . . . . . .               E   DWord
  PSP_INT24  . . . . . . . . . .              12   DWord
  PSP_Parent . . . . . . . . . .              16   Word
  PSP_HandleList . . . . . . . .              18   Byte[20]
  PSP_Environment  . . . . . . .              2C   Word
  PSP_INT21SSSP  . . . . . . . .              2E   DWord
  PSP_Handles  . . . . . . . . .              32   Word
  PSP_HandlePtr  . . . . . . . .              34   DWord
  PSP_Previous . . . . . . . . .              38   DWord
  PSP_Filler2  . . . . . . . . .              3C   DWord
  PSP_DOSVersion . . . . . . . .              40   Word
  PSP_NextPSP  . . . . . . . . .              42   Word
  PSP_Filler3  . . . . . . . . .              44   DWord
  PSP_WinOldAp . . . . . . . . .              48   Byte
  PSP_Filler4  . . . . . . . . .              49   Byte[7]
  PSP_INT21  . . . . . . . . . .              50   Byte[3]
  PSP_Filler5  . . . . . . . . .              53   Byte[9]
  PSP_FCB1 . . . . . . . . . . .              5C   Byte[16]
  PSP_FCB2 . . . . . . . . . . .              6C   Byte[16]
  PSP_Filler6  . . . . . . . . .              7C   DWord
  PSP_CommandTail  . . . . . . .              80   Byte[128]
ResHead  . . . . . . . . . . . .               C
  ResHead_Prev . . . . . . . . .               0   DWord
  ResHead_Next . . . . . . . . .               4   DWord
  ResHead_Handle . . . . . . . .               8   DWord
TSSFields  . . . . . . . . . . .              68
  Back . . . . . . . . . . . . .               0   Word[2]
  ESP0 . . . . . . . . . . . . .               4   DWord
  SS0  . . . . . . . . . . . . .               8   Word[2]
  ESP1 . . . . . . . . . . . . .               C   DWord
  SS1  . . . . . . . . . . . . .              10   Word[2]
  ESP2 . . . . . . . . . . . . .              14   DWord
  SS2  . . . . . . . . . . . . .              18   Word[2]
  tCR3 . . . . . . . . . . . . .              1C   DWord
  tEIP . . . . . . . . . . . . .              20   DWord
  tEFlags  . . . . . . . . . . .              24   DWord
  tEAX . . . . . . . . . . . . .              28   DWord
  tECX . . . . . . . . . . . . .              2C   DWord
  tEDX . . . . . . . . . . . . .              30   DWord
  tEBX . . . . . . . . . . . . .              34   DWord
  tESP . . . . . . . . . . . . .              38   DWord
  tEBP . . . . . . . . . . . . .              3C   DWord
  tESI . . . . . . . . . . . . .              40   DWord
  tEDI . . . . . . . . . . . . .              44   DWord
  tES  . . . . . . . . . . . . .              48   DWord
  tCS  . . . . . . . . . . . . .              4C   DWord
  tSS  . . . . . . . . . . . . .              50   DWord
  tDS  . . . . . . . . . . . . .              54   DWord
  tFS  . . . . . . . . . . . . .              58   DWord
  tGS  . . . . . . . . . . . . .              5C   DWord
  tLDT . . . . . . . . . . . . .              60   Word
  IOMap  . . . . . . . . . . . .              66   Word
_Seg_  . . . . . . . . . . . . .              10
  Seg_BaseAddress  . . . . . . .               0   DWord
  Seg_Type . . . . . . . . . . .               4   DWord
  Seg_Length . . . . . . . . . .               8   DWord
  Seg_Memory . . . . . . . . . .               C   DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .        GROUP
STACK  . . . . . . . . . . . . .        32 Bit   00001000 DWord   Stack   'STACK'
_BSS . . . . . . . . . . . . . .        32 Bit   00000D8C DWord   Public  'BSS'
_DATA  . . . . . . . . . . . . .        32 Bit   00003D80 DWord   Public  'DATA'
_TEXT  . . . . . . . . . . . . .        32 Bit   00003250 DWord   Public  'CODE'


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

ASCII2Bin  . . . . . . . . . . .        P Near   00002B2F _TEXT    00000023 Public   
  @@9  . . . . . . . . . . . . .        L Near   00002B50 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00002B4E _TEXT
  @@Dec  . . . . . . . . . . . .        L Near   00002B48 _TEXT
AddRelocationEntry . . . . . . .        P Near   00000F1D _TEXT    0000004D Public   
  @@10 . . . . . . . . . . . . .        L Near   00000F68 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00000F3F _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00000F67 _TEXT
Bin2Hex  . . . . . . . . . . . .        P Near   00001DC5 _TEXT    0000002E Public   
  @@0  . . . . . . . . . . . . .        L Near   00001DD1 _TEXT
Bord . . . . . . . . . . . . . .        P Near   00002E54 _TEXT    0000001B Public   
CloseAllFiles  . . . . . . . . .        P Near   00003124 _TEXT    0000002B Public   
  @@2  . . . . . . . . . . . . .        L Near   00003142 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00003138 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00003132 _TEXT
CloseFile  . . . . . . . . . . .        P Near   000030F3 _TEXT    00000031 Public   
  @@1  . . . . . . . . . . . . .        L Near   00003110 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00003104 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   0000311E _TEXT
Create3PFile . . . . . . . . . .        P Near   00000F6A _TEXT    00000192 Public   
  @@3  . . . . . . . . . . . . .        L Near   00001083 _TEXT
  @@2  . . . . . . . . . . . . .        L Near   0000107D _TEXT
  @@1  . . . . . . . . . . . . .        L Near   0000106B _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00000FA5 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   000010D9 _TEXT
  @@6  . . . . . . . . . . . . .        L Near   000010D3 _TEXT
  @@5  . . . . . . . . . . . . .        L Near   000010C4 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00001095 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   000010FA _TEXT
  @@0_0  . . . . . . . . . . . .        L Near   00000FD3 _TEXT
Create3PHeader . . . . . . . . .        P Near   00000AF9 _TEXT    00000084 Public   
  @@0  . . . . . . . . . . . . .        L Near   00000B38 _TEXT
CreateFile . . . . . . . . . . .        P Near   0000303C _TEXT    00000034 Public   
  @@1  . . . . . . . . . . . . .        L Near   0000305E _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00003051 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00003064 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00003065 _TEXT
CreateRelocations  . . . . . . .        P Near   00000B7D _TEXT    000003A0 Public   
  @@sfBig0 . . . . . . . . . . .        L Near   00000DDD _TEXT
  @@Big0 . . . . . . . . . . . .        L Near   00000D45 _TEXT
  @@Big1 . . . . . . . . . . . .        L Near   00000E99 _TEXT
  @@Seg16  . . . . . . . . . . .        L Near   00000C96 _TEXT
  @@Seg1632BitOff  . . . . . . .        L Near   00000E01 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   00000EDE _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00000C18 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00000BF3 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00000BD4 _TEXT
  @@sfNeg1 . . . . . . . . . . .        L Near   00000DE7 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00000EEC _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00000F1B _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00000F19 _TEXT
  @@Neg0 . . . . . . . . . . . .        L Near   00000CF9 _TEXT
  @@Neg1 . . . . . . . . . . . .        L Near   00000D7B _TEXT
  @@Neg2 . . . . . . . . . . . .        L Near   00000ECB _TEXT
  @@32BitOff . . . . . . . . . .        L Near   00000D04 _TEXT
  @@Self32Off  . . . . . . . . .        L Near   00000D95 _TEXT
DeleteFile . . . . . . . . . . .        P Near   0000314F _TEXT    00000005 Public   
Entry  . . . . . . . . . . . . .        P Far    000001CC _TEXT    00000346 Public   
  @@Info . . . . . . . . . . . .        L Near   000004A1 _TEXT
  @@update . . . . . . . . . . .        L Near   000004B1 _TEXT
  medexe2  . . . . . . . . . . .        L Near   00000426 _TEXT
  @@fastload . . . . . . . . . .        L Near   000004C1 _TEXT
  @@Reset  . . . . . . . . . . .        L Near   00000484 _TEXT
  @@70 . . . . . . . . . . . . .        L Near   000002DB _TEXT
  @@3  . . . . . . . . . . . . .        L Near   0000029B _TEXT
  @@NoGroupDel . . . . . . . . .        L Near   00000255 _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00000291 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00000277 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   0000026E _TEXT
  @@5  . . . . . . . . . . . . .        L Near   000002A7 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   0000028A _TEXT
  @@9  . . . . . . . . . . . . .        L Near   0000050C _TEXT
  @@10a  . . . . . . . . . . . .        L Near   000002C3 _TEXT
  nextchar . . . . . . . . . . .        L Near   000002EE _TEXT
  @@InfoDump . . . . . . . . . .        L Near   000004D1 _TEXT
  @@DoExe  . . . . . . . . . . .        L Near   00000414 _TEXT
  noslash  . . . . . . . . . . .        L Near   000002E3 _TEXT
  @@LEReset  . . . . . . . . . .        L Near   000003BA _TEXT
  @@DualMode . . . . . . . . . .        L Near   000004D1 _TEXT
ExeAndMap2NewExe . . . . . . . .        P Near   000016FB _TEXT    0000003C Public   
  @@9  . . . . . . . . . . . . .        L Near   00001736 _TEXT
FastLoad3P . . . . . . . . . . .        P Near   00000576 _TEXT    0000030F Public   
  @@SymbolCount  . . . . . . . .        DWord             ebp - 0004
  @@iValue . . . . . . . . . . .        DWord             ebp - 0008
  @@vValue . . . . . . . . . . .        DWord             ebp - 000C
  @@iloop  . . . . . . . . . . .        L Near   00000738 _TEXT
  @@sortend  . . . . . . . . . .        L Near   000007DA _TEXT
  @@01 . . . . . . . . . . . . .        L Near   000007E6 _TEXT
  @@00 . . . . . . . . . . . . .        L Near   000006F1 _TEXT
  medexe3  . . . . . . . . . . .        L Near   000005FF _TEXT
  @@whileloop  . . . . . . . . .        L Near   00000753 _TEXT
  @@dochange . . . . . . . . . .        L Near   00000782 _TEXT
  @@sort2  . . . . . . . . . . .        L Near   00000728 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00000883 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   0000086D _TEXT
  @@nexth  . . . . . . . . . . .        L Near   000007C9 _TEXT
  @@whilefail  . . . . . . . . .        L Near   000007AC _TEXT
  @@sethloop . . . . . . . . . .        L Near   0000071F _TEXT
  @@hloop  . . . . . . . . . . .        L Near   0000072A _TEXT
FetchLEFile  . . . . . . . . . .        P Near   000010FC _TEXT    000000E1 Public   
  @@9  . . . . . . . . . . . . .        L Near   000011DB _TEXT
GetMemLinear32 . . . . . . . . .        P Near   00002E7A _TEXT    0000001D Public   
  fail . . . . . . . . . . . . .        L Near   00002E91 _TEXT
InitFileBuffer . . . . . . . . .        P Near   000031C4 _TEXT    0000000B Public   
LECloseFile  . . . . . . . . . .        P Near   0000123E _TEXT    00000007 Public   
LECreateFile . . . . . . . . . .        P Near   000011DD _TEXT    00000018 Public   
  l0 . . . . . . . . . . . . . .        L Near   000011EF _TEXT
LEMalloc . . . . . . . . . . . .        P Near   00001245 _TEXT    00000010 Public   
  l0 . . . . . . . . . . . . . .        L Near   00001250 _TEXT
  l1 . . . . . . . . . . . . . .        L Near   00001253 _TEXT
LEOpenFile . . . . . . . . . . .        P Near   000012A2 _TEXT    00000015 Public   
  l0 . . . . . . . . . . . . . .        L Near   000012B2 _TEXT
LEPrintString  . . . . . . . . .        P Near   000012B7 _TEXT    00000014 Public   
  l0 . . . . . . . . . . . . . .        L Near   000012BA _TEXT
  l1 . . . . . . . . . . . . . .        L Near   000012C7 _TEXT
LEProcess  . . . . . . . . . . .        P Near   00000885 _TEXT    0000002E Public   
  @@9  . . . . . . . . . . . . .        L Near   000008B2 _TEXT
LEReMalloc . . . . . . . . . . .        P Near   0000122C _TEXT    00000012 Public   
  l0 . . . . . . . . . . . . . .        L Near   00001238 _TEXT
  l1 . . . . . . . . . . . . . .        L Near   0000123B _TEXT
LEReadFile . . . . . . . . . . .        P Near   00001255 _TEXT    00000035 Public   
  @@2  . . . . . . . . . . . . .        L Near   00001284 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   0000126B _TEXT
  @@0  . . . . . . . . . . . . .        L Near   0000125A _TEXT
LESetFilePointer . . . . . . . .        P Near   0000128A _TEXT    00000018 Public   
LEWriteFile  . . . . . . . . . .        P Near   000011F5 _TEXT    00000037 Public   
  @@2  . . . . . . . . . . . . .        L Near   00001226 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   0000120B _TEXT
  @@0  . . . . . . . . . . . . .        L Near   000011FA _TEXT
NewCauseWay  . . . . . . . . . .        P Near   000012CB _TEXT    000003A1 Public   
  medexe5  . . . . . . . . . . .        L Near   000013AE _TEXT
  medexe6  . . . . . . . . . . .        L Near   000014D3 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00001664 _TEXT
NewExeInfo . . . . . . . . . . .        P Near   00001737 _TEXT    0000068E Public   
  @@10 . . . . . . . . . . . . .        L Near   000017BA _TEXT
  @@Offset32 . . . . . . . . . .        L Near   00001D4E _TEXT
  @@nospeed  . . . . . . . . . .        L Near   00001875 _TEXT
  @@Seg16  . . . . . . . . . . .        L Near   00001D6A _TEXT
  medexe7  . . . . . . . . . . .        L Near   000017CC _TEXT
  @@its16  . . . . . . . . . . .        L Near   00001859 _TEXT
  @@RelInv . . . . . . . . . . .        L Near   00001D36 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   00001D3F _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00001CDA _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00001C5C _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00001C19 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   00001CAE _TEXT
  @@6  . . . . . . . . . . . . .        L Near   00001CA8 _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00001BEC _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00001D96 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00001DC4 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00001DBB _TEXT
  @@ImageLoaded  . . . . . . . .        L Near   00001BD1 _TEXT
  @@Look3P . . . . . . . . . . .        L Near   000017EE _TEXT
  @@NotComp  . . . . . . . . . .        L Near   00001BAC _TEXT
OpenFile . . . . . . . . . . . .        P Near   00003009 _TEXT    00000033 Public   
  @@1  . . . . . . . . . . . . .        L Near   0000302A _TEXT
  @@0  . . . . . . . . . . . . .        L Near   0000301D _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00003030 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00003031 _TEXT
PostMortem . . . . . . . . . . .        P Near   00000575 _TEXT    00000001 Public   
ProcessFile  . . . . . . . . . .        P Near   00001DF3 _TEXT    00000780 Public   
  @@10 . . . . . . . . . . . . .        L Near   0000220F _TEXT
  @@NotFlat  . . . . . . . . . .        L Near   00002419 _TEXT
  @@Small  . . . . . . . . . . .        L Near   0000237E _TEXT
  @@NoReloc  . . . . . . . . . .        L Near   00002442 _TEXT
  @@NormStack2 . . . . . . . . .        L Near   000021BE _TEXT
  @@NormStack  . . . . . . . . .        L Near   0000214D _TEXT
  medexe8  . . . . . . . . . . .        L Near   00001F1F _TEXT
  medexe9  . . . . . . . . . . .        L Near   000020E7 _TEXT
  @@GotStackNear . . . . . . . .        L Near   00002157 _TEXT
  @@NoRoundUp  . . . . . . . . .        L Near   00002376 _TEXT
  @@31 . . . . . . . . . . . . .        L Near   00002438 _TEXT
  @@30 . . . . . . . . . . . . .        L Near   00002409 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   000023EE _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00002295 _TEXT
  @@NoRelocMem . . . . . . . . .        L Near   000022AC _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00002359 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   00002203 _TEXT
  @@6  . . . . . . . . . . . . .        L Near   000021D4 _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00002194 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   0000217B _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00002545 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00002209 _TEXT
  @@NoBind . . . . . . . . . . .        L Near   0000203A _TEXT
  @@6_0  . . . . . . . . . . . .        L Near   000021E4 _TEXT
ReadBufferByte . . . . . . . . .        P Near   000031CF _TEXT    0000005F Public   
  @@0  . . . . . . . . . . . . .        L Near   0000320A _TEXT
  @@9  . . . . . . . . . . . . .        L Near   0000322D _TEXT
  @@8  . . . . . . . . . . . . .        L Near   0000322C _TEXT
ReadCommand  . . . . . . . . . .        P Near   00002EC1 _TEXT    00000148 Public   
  @@10 . . . . . . . . . . . . .        L Near   00002FD7 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   00002F2E _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00002F0D _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00002EFE _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00002EEE _TEXT
  @@7  . . . . . . . . . . . . .        L Near   00002FA7 _TEXT
  @@6  . . . . . . . . . . . . .        L Near   00002F87 _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00002F7A _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00002F42 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00002FF8 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00002FC2 _TEXT
  @@Option . . . . . . . . . . .        L Near   00002F77 _TEXT
  @@900  . . . . . . . . . . . .        L Near   00002FC1 _TEXT
  @@12 . . . . . . . . . . . . .        L Near   00002F96 _TEXT
  @@11 . . . . . . . . . . . . .        L Near   00002FE9 _TEXT
ReadConfig . . . . . . . . . . .        P Near   00002B52 _TEXT    000001AC Public   
  @@10 . . . . . . . . . . . . .        L Near   00002CCB _TEXT
  @@90 . . . . . . . . . . . . .        L Near   00002CD8 _TEXT
  @@c99  . . . . . . . . . . . .        L Near   00002BC4 _TEXT
  @@ConfigOK . . . . . . . . . .        L Near   00002BE7 _TEXT
  @@NoOveride  . . . . . . . . .        L Near   00002B6F _TEXT
  @@c3 . . . . . . . . . . . . .        L Near   00002BB8 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   00002C64 _TEXT
  @@c2 . . . . . . . . . . . . .        L Near   00002BAF _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00002C90 _TEXT
  @@c1 . . . . . . . . . . . . .        L Near   00002B9A _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00002C5A _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00002C40 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   00002CAA _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00002C8B _TEXT
  @@c4 . . . . . . . . . . . . .        L Near   00002BD0 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00002C94 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00002CF6 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00002CC1 _TEXT
  @@Scan . . . . . . . . . . . .        L Near   00002C2A _TEXT
  @@NotCurrent . . . . . . . . .        L Near   00002B83 _TEXT
  @@Read . . . . . . . . . . . .        L Near   00002BED _TEXT
ReadFile . . . . . . . . . . . .        P Near   0000307F _TEXT    0000003A Public   
  @@2  . . . . . . . . . . . . .        L Near   00003093 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00003081 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   000030B7 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   000030B3 _TEXT
ReadLine . . . . . . . . . . . .        P Near   00003154 _TEXT    00000070 Public   
  @@EOF  . . . . . . . . . . . .        L Near   000031B9 _TEXT
  @@SoftEOF  . . . . . . . . . .        L Near   00003194 _TEXT
  @@EOL  . . . . . . . . . . . .        L Near   0000318C _TEXT
  @@CheckLF  . . . . . . . . . .        L Near   00003179 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00003157 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   000031C2 _TEXT
  @@CheckEOF . . . . . . . . . .        L Near   000031B4 _TEXT
ReadMapFile  . . . . . . . . . .        P Near   00002573 _TEXT    000005BC Public   
  @@10 . . . . . . . . . . . . .        L Near   0000273D _TEXT
  @@17 . . . . . . . . . . . . .        L Near   00002847 _TEXT
  @@16 . . . . . . . . . . . . .        L Near   00002866 _TEXT
  @@90 . . . . . . . . . . . . .        L Near   00002AEB _TEXT
  @@15 . . . . . . . . . . . . .        L Near   000027B9 _TEXT
  @@14 . . . . . . . . . . . . .        L Near   0000279E _TEXT
  @@19 . . . . . . . . . . . . .        L Near   00002802 _TEXT
  @@18 . . . . . . . . . . . . .        L Near   0000286D _TEXT
  @@Class  . . . . . . . . . . .        L Near   0000278E _TEXT
  @@LookID . . . . . . . . . . .        L Near   000025D8 _TEXT
  @@NoBaseChk  . . . . . . . . .        L Near   00002AC3 _TEXT
  @@GotESPSize . . . . . . . . .        L Near   000029AB _TEXT
  @@NextSeg  . . . . . . . . . .        L Near   000028BC _TEXT
  @@Start  . . . . . . . . . . .        L Near   0000270F _TEXT
  @@NoRound  . . . . . . . . . .        L Near   000028D1 _TEXT
  @@LookSeg  . . . . . . . . . .        L Near   000026B4 _TEXT
  @@NoFlat . . . . . . . . . . .        L Near   000029C0 _TEXT
  @@31 . . . . . . . . . . . . .        L Near   0000277F _TEXT
  @@30 . . . . . . . . . . . . .        L Near   0000273C _TEXT
  @@Ignore . . . . . . . . . . .        L Near   00002702 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   0000263F _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00002635 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00002632 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00002628 _TEXT
  @@G1 . . . . . . . . . . . . .        L Near   00002A50 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   000026E1 _TEXT
  @@G0 . . . . . . . . . . . . .        L Near   00002A42 _TEXT
  @@6  . . . . . . . . . . . . .        L Near   000026D7 _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00002668 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00002642 _TEXT
  @@NoGroup  . . . . . . . . . .        L Near   00002A55 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00002B09 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   000026E4 _TEXT
  @@23 . . . . . . . . . . . . .        L Near   00002A07 _TEXT
  @@22 . . . . . . . . . . . . .        L Near   00002854 _TEXT
  @@21 . . . . . . . . . . . . .        L Near   00002875 _TEXT
  @@20 . . . . . . . . . . . . .        L Near   00002813 _TEXT
  @@27 . . . . . . . . . . . . .        L Near   000027F3 _TEXT
  @@Length . . . . . . . . . . .        L Near   00002752 _TEXT
  @@26 . . . . . . . . . . . . .        L Near   000027E9 _TEXT
  @@25 . . . . . . . . . . . . .        L Near   000027DF _TEXT
  @@24 . . . . . . . . . . . . .        L Near   00002A18 _TEXT
  @@SameBase3  . . . . . . . . .        L Near   00002A92 _TEXT
  @@SameBase2  . . . . . . . . .        L Near   00002A84 _TEXT
  @@SameBase1  . . . . . . . . .        L Near   00002A74 _TEXT
  @@SameBase0  . . . . . . . . .        L Near   00002A6A _TEXT
  @@SameBase5  . . . . . . . . .        L Near   00002AB9 _TEXT
  @@DoSegs . . . . . . . . . . .        L Near   0000293C _TEXT
  @@SameBase4  . . . . . . . . .        L Near   00002A7E _TEXT
  @@13 . . . . . . . . . . . . .        L Near   00002780 _TEXT
  @@12 . . . . . . . . . . . . .        L Near   00002754 _TEXT
  @@11 . . . . . . . . . . . . .        L Near   00002711 _TEXT
RelMemLinear32 . . . . . . . . .        P Near   00002E97 _TEXT    0000000E Public   
ResMemLinear32 . . . . . . . . .        P Near   00002EA5 _TEXT    0000001C Public   
SegFormatCode  . . . . . . . . .        P Near   00002DA6 _TEXT    000000AE Public   
  @@3  . . . . . . . . . . . . .        L Near   00002DE1 _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00002E03 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00002DD2 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00002DB8 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   00002DDC _TEXT
  @@6  . . . . . . . . . . . . .        L Near   00002E2B _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00002DAC _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00002E08 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00002E4C _TEXT
  @@8  . . . . . . . . . . . . .        L Near   00002E41 _TEXT
SetFilePointer . . . . . . . . .        P Near   00003070 _TEXT    0000000F Public   
SetSystemConfig  . . . . . . . .        P Near   0000166C _TEXT    0000008F Public   
  @@NoAutoESP  . . . . . . . . .        L Near   000016FA _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00001683 _TEXT
  @@1  . . . . . . . . . . . . .        L Near   0000169F _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00001691 _TEXT
  @@ss1  . . . . . . . . . . . .        L Near   000016F2 _TEXT
  @@ss0  . . . . . . . . . . . .        L Near   000016C9 _TEXT
StringPRint  . . . . . . . . . .        P Near   0000322E _TEXT    00000022 Public   
  @@0  . . . . . . . . . . . . .        L Near   00003237 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00003248 _TEXT
System . . . . . . . . . . . . .        P Near   00000512 _TEXT    00000063 Public   
  @@NoError  . . . . . . . . . .        L Near   0000053B _TEXT
  @@DoneError  . . . . . . . . .        L Near   00000545 _TEXT
  @@NoName . . . . . . . . . . .        L Near   00000559 _TEXT
UpperChar  . . . . . . . . . . .        P Near   00002E6F _TEXT    0000000B Public   
  @@0  . . . . . . . . . . . . .        L Near   00002E79 _TEXT
WhiteSpaceString . . . . . . . .        P Near   00002CFE _TEXT    000000A8 Public   
  @@30 . . . . . . . . . . . . .        L Near   00002D14 _TEXT
  @@3  . . . . . . . . . . . . .        L Near   00002D86 _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00002D7A _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00002D89 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00002D23 _TEXT
  @@7  . . . . . . . . . . . . .        L Near   00002D97 _TEXT
  @@6  . . . . . . . . . . . . .        L Near   00002D52 _TEXT
  @@5  . . . . . . . . . . . . .        L Near   00002D63 _TEXT
  @@4  . . . . . . . . . . . . .        L Near   00002D97 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00002D9E _TEXT
  @@AtStart  . . . . . . . . . .        L Near   00002D1D _TEXT
Write3PFile  . . . . . . . . . .        P Near   000008B3 _TEXT    00000246 Public   
  medexe4  . . . . . . . . . . .        L Near   00000945 _TEXT
  @@2  . . . . . . . . . . . . .        L Near   00000AAC _TEXT
  @@1  . . . . . . . . . . . . .        L Near   00000AA1 _TEXT
  @@0  . . . . . . . . . . . . .        L Near   00000A50 _TEXT
  @@9  . . . . . . . . . . . . .        L Near   00000AF7 _TEXT
WriteFile  . . . . . . . . . . .        P Near   000030B9 _TEXT    0000003A Public   
  @@2  . . . . . . . . . . . . .        L Near   000030CD _TEXT
  @@0  . . . . . . . . . . . . .        L Near   000030BB _TEXT
  @@9  . . . . . . . . . . . . .        L Near   000030F1 _TEXT
  @@8  . . . . . . . . . . . . .        L Near   000030ED _TEXT
dprintf  . . . . . . . . . . . .        P Near   00000062 _TEXT    00000167 Public   
  size_  . . . . . . . . . . . .        DWord             ebp - 0004
  flag . . . . . . . . . . . . .        Byte              ebp - 0005
  longarg  . . . . . . . . . . .        Byte              ebp - 0006
  fill . . . . . . . . . . . . .        Byte              ebp - 0007
  szTmp  . . . . . . . . . . . .        Byte[12]          ebp - 0013
  print_char . . . . . . . . . .        L Near   000001B3 _TEXT
  done . . . . . . . . . . . . .        L Near   00000081 _TEXT
  L&_0008  . . . . . . . . . . .        L Near   000001C0 _TEXT
  @C000A . . . . . . . . . . . .        L Near   0000019D _TEXT
  L&_0006  . . . . . . . . . . .        L Near   000000E7 _TEXT
  @C000B . . . . . . . . . . . .        L Near   000001A4 _TEXT
  @@lprt262  . . . . . . . . . .        L Near   0000012F _TEXT
  L&_0007  . . . . . . . . . . .        L Near   0000013E _TEXT
  @C000C . . . . . . . . . . . .        L Near   000001AD _TEXT
  L&_0004  . . . . . . . . . . .        L Near   000000AC _TEXT
  L&_0005  . . . . . . . . . . .        L Near   000000B8 _TEXT
  print_string . . . . . . . . .        L Near   0000016D _TEXT
  @@L335 . . . . . . . . . . . .        L Near   0000006D _TEXT
  @C0004 . . . . . . . . . . . .        L Near   00000174 _TEXT
  handle_i . . . . . . . . . . .        L Near   00000125 _TEXT
  @C0005 . . . . . . . . . . . .        L Near   00000175 _TEXT
  @C0006 . . . . . . . . . . . .        L Near   00000195 _TEXT
  @C0007 . . . . . . . . . . . .        L Near   00000187 _TEXT
  @C0001 . . . . . . . . . . . .        L Near   000000BF _TEXT
  @C0002 . . . . . . . . . . . .        L Near   000000D9 _TEXT
  @C0003 . . . . . . . . . . . .        L Near   000000CD _TEXT
  handle_c . . . . . . . . . . .        L Near   00000113 _TEXT
  @C0008 . . . . . . . . . . . .        L Near   00000190 _TEXT
  @C0009 . . . . . . . . . . . .        L Near   00000197 _TEXT
  handle_d . . . . . . . . . . .        L Near   00000125 _TEXT
  handle_x . . . . . . . . . . .        L Near   0000011F _TEXT
  handle_s . . . . . . . . . . .        L Near   00000152 _TEXT
  handle_u . . . . . . . . . . .        L Near   0000012B _TEXT
  formatitem . . . . . . . . . .        L Near   00000096 _TEXT
  nextchar . . . . . . . . . . .        L Near   00000070 _TEXT
  @@L359 . . . . . . . . . . . .        L Near   00000119 _TEXT
ltob . . . . . . . . . . . . . .        P Near   0000001C _TEXT    00000046 Public   
  L&_0002  . . . . . . . . . . .        L Near   0000004B _TEXT
  L&_0003  . . . . . . . . . . .        L Near   0000005D _TEXT
  L&_0001  . . . . . . . . . . .        L Near   00000034 _TEXT
  @@nextdigit  . . . . . . . . .        L Near   0000003C _TEXT


Symbols:

                N a m e                 Type       Value     Attr

@@Source . . . . . . . . . . . .        DWord            588h _BSS 
@@WildStart1 . . . . . . . . . .        DWord            580h _BSS 
@@WildStart2 . . . . . . . . . .        DWord            584h _BSS 
@CodeSize  . . . . . . . . . . .        Number             0h 
@DataSize  . . . . . . . . . . .        Number             0h 
@Interface . . . . . . . . . . .        Number             0h 
@Model . . . . . . . . . . . . .        Number             7h 
@code  . . . . . . . . . . . . .        Text   _TEXT
@data  . . . . . . . . . . . . .        Text   FLAT
@stack . . . . . . . . . . . . .        Text   FLAT
Bit16Text  . . . . . . . . . . .        Byte[22]        3660h _DATA 
Bit32Text  . . . . . . . . . . .        Byte[22]        3676h _DATA 
BitDualText  . . . . . . . . . .        Byte[25]        368Ch _DATA 
BuildHeaderText  . . . . . . . .        Byte[29]        38CDh _DATA 
BuildImageText . . . . . . . . .        Byte[34]        388Eh _DATA 
BuildRelocsText  . . . . . . . .        Byte[29]        38B0h _DATA 
CWStubName . . . . . . . . . . .        Byte[11]         AEDh _DATA 
CarriageReturn . . . . . . . . .        Byte[3]          ADEh _DATA 
CarriageReturn2  . . . . . . . .        Byte[3]          AE1h _DATA 
ClassText  . . . . . . . . . . .        Byte[6]          D17h _DATA 
CodeClassVAR . . . . . . . . . .        Byte[10]         C1Eh _DATA 
ConfigHandle . . . . . . . . . .        Word             AF8h _DATA 
ConfigName . . . . . . . . . . .        Byte[9]          AE4h _DATA 
ConfigPath . . . . . . . . . . .        Byte[128]          0h _BSS 
ConstClassVAR  . . . . . . . . .        Byte[11]         C3Dh _DATA 
DBGOPT . . . . . . . . . . . . .        Number     -00000001h 
DataClassVAR . . . . . . . . . .        Byte[10]         C28h _DATA 
Desc286Call  . . . . . . . . . .        Number             4h 
Desc286Int . . . . . . . . . . .        Number             6h 
Desc286Trap  . . . . . . . . . .        Number             7h 
Desc286Tss . . . . . . . . . . .        Number             1h 
Desc286TssB  . . . . . . . . . .        Number             3h 
Desc32Bit  . . . . . . . . . . .        Number            40h 
Desc386Call  . . . . . . . . . .        Number             Ch 
Desc386Int . . . . . . . . . . .        Number             Eh 
Desc386Trap  . . . . . . . . . .        Number             Fh 
Desc386Tss . . . . . . . . . . .        Number             9h 
Desc386TssB  . . . . . . . . . .        Number             Bh 
DescAvailable  . . . . . . . . .        Number            10h 
DescECCode . . . . . . . . . . .        Number             Ch 
DescECode  . . . . . . . . . . .        Number             8h 
DescERCCode  . . . . . . . . . .        Number             Eh 
DescERCode . . . . . . . . . . .        Number             Ah 
DescLDT  . . . . . . . . . . . .        Number             2h 
DescMemory . . . . . . . . . . .        Number            10h 
DescPL0  . . . . . . . . . . . .        Number             0h 
DescPL1  . . . . . . . . . . . .        Number            20h 
DescPL2  . . . . . . . . . . . .        Number            40h 
DescPL3  . . . . . . . . . . . .        Number            60h 
DescPresent  . . . . . . . . . .        Number            80h 
DescRData  . . . . . . . . . . .        Number             0h 
DescRDataDown  . . . . . . . . .        Number             4h 
DescRWData . . . . . . . . . . .        Number             2h 
DescRWDataDown . . . . . . . . .        Number             6h 
DescTssGate  . . . . . . . . . .        Number             5h 
ERR_ALREADY3P  . . . . . . . . .        Number            1Ah 
ERR_HDRFMT . . . . . . . . . . .        Number             7h 
ERR_IO . . . . . . . . . . . . .        Number             8h 
ERR_NOFILES  . . . . . . . . . .        Number             5h 
ERR_OPENFIL  . . . . . . . . . .        Number             6h 
EXEFileName  . . . . . . . . . .        Byte[64]         100h _BSS 
EXEHandle  . . . . . . . . . . .        Word             B00h _DATA 
EXEextension . . . . . . . . . .        Byte[4]          AFCh _DATA 
ErrorM10 . . . . . . . . . . . .        Byte[28]         5ABh _DATA 
ErrorM11 . . . . . . . . . . . .        Byte[42]         5C7h _DATA 
ErrorM12 . . . . . . . . . . . .        Byte[26]         5F1h _DATA 
ErrorM13 . . . . . . . . . . . .        Byte[32]         60Bh _DATA 
ErrorM14 . . . . . . . . . . . .        Byte[42]         62Bh _DATA 
ErrorM15 . . . . . . . . . . . .        Byte[47]         655h _DATA 
ErrorM16 . . . . . . . . . . . .        Byte[38]         684h _DATA 
ErrorM17 . . . . . . . . . . . .        Byte[32]         6AAh _DATA 
ErrorM18 . . . . . . . . . . . .        Byte[32]         6CAh _DATA 
ErrorM19 . . . . . . . . . . . .        Byte[32]         6EAh _DATA 
ErrorM20 . . . . . . . . . . . .        Byte[40]         70Ah _DATA 
ErrorM21 . . . . . . . . . . . .        Byte[20]         732h _DATA 
ErrorM22 . . . . . . . . . . . .        Byte[48]         746h _DATA 
ErrorM23 . . . . . . . . . . . .        Byte[28]         776h _DATA 
ErrorM24 . . . . . . . . . . . .        Byte[50]         792h _DATA 
ErrorM25 . . . . . . . . . . . .        Byte[52]         7C4h _DATA 
ErrorM26 . . . . . . . . . . . .        Byte[34]         7F8h _DATA 
ErrorM27 . . . . . . . . . . . .        Byte[28]         81Ah _DATA 
ErrorM32 . . . . . . . . . . . .        Byte[36]         836h _DATA 
ErrorM33 . . . . . . . . . . . .        Byte[27]         85Ah _DATA 
ErrorM34 . . . . . . . . . . . .        Byte[37]         875h _DATA 
ErrorM35 . . . . . . . . . . . .        Byte[25]         89Ah _DATA 
ErrorM36 . . . . . . . . . . . .        Byte[39]         8B3h _DATA 
ErrorM37 . . . . . . . . . . . .        Byte[32]         8DAh _DATA 
ErrorM38 . . . . . . . . . . . .        Byte[44]         8FAh _DATA 
ErrorM39 . . . . . . . . . . . .        Byte[40]         926h _DATA 
ErrorM40 . . . . . . . . . . . .        Byte[34]         94Eh _DATA 
ErrorM41 . . . . . . . . . . . .        Byte[57]         970h _DATA 
ErrorM42 . . . . . . . . . . . .        Byte[38]         9A9h _DATA 
ErrorM43 . . . . . . . . . . . .        Byte[31]         9CFh _DATA 
ErrorM9  . . . . . . . . . . . .        Byte[48]         57Bh _DATA 
ErrorMessages  . . . . . . . . .        DWord              6h _DATA 
ErrorNumber  . . . . . . . . . .        Word               4h _DATA 
ErrorText  . . . . . . . . . . .        Byte[8]          9EEh _DATA 
Errorm0  . . . . . . . . . . . .        Byte[40]          B6h _DATA 
Errorm1  . . . . . . . . . . . .        Byte[61]          DEh _DATA 
Errorm2  . . . . . . . . . . . .        Byte[35]         11Bh _DATA 
Errorm3  . . . . . . . . . . . .        Byte[44]         13Eh _DATA 
Errorm4  . . . . . . . . . . . .        Byte[33]         4E1h _DATA 
Errorm5  . . . . . . . . . . . .        Byte[29]         502h _DATA 
Errorm6  . . . . . . . . . . . .        Byte[29]         51Fh _DATA 
Errorm7  . . . . . . . . . . . .        Byte[27]         53Ch _DATA 
Errorm8  . . . . . . . . . . . .        Byte[36]         557h _DATA 
ExeSegment . . . . . . . . . . .        DWord            B23h _DATA 
ExeSize1 . . . . . . . . . . . .        Word[2]          B46h _DATA 
ExeSize2 . . . . . . . . . . . .        Word[2]          B4Ah _DATA 
FileBuffer . . . . . . . . . . .        Byte[2048]       58Ch _BSS 
FileBufferCount  . . . . . . . .        DWord           3D00h _DATA 
FileBufferPosition . . . . . . .        DWord           3D04h _DATA 
GenerateExeText  . . . . . . . .        Byte[34]         ABCh _DATA 
HexTable . . . . . . . . . . . .        Byte[16]        1DE3h _TEXT 
HiThere  . . . . . . . . . . . .        Byte[28]           0h _TEXT 
InternalConfig . . . . . . . . .        Byte[48]         A32h _DATA 
InvalidText  . . . . . . . . . .        Byte[8]         3865h _DATA 
KernalA000 . . . . . . . . . . .        Number          A003h 
KernalB000 . . . . . . . . . . .        Number          B003h 
KernalB800 . . . . . . . . . . .        Number          B803h 
LEAddress  . . . . . . . . . . .        DWord           38FEh _DATA 
LELength . . . . . . . . . . . .        DWord           3902h _DATA 
LEOffset . . . . . . . . . . . .        DWord           3906h _DATA 
LE_CPU_286 . . . . . . . . . . .        Number             1h 
LE_CPU_386 . . . . . . . . . . .        Number             2h 
LE_CPU_486 . . . . . . . . . . .        Number             3h 
LE_CPU_586 . . . . . . . . . . .        Number             4h 
LE_CPU_N11 . . . . . . . . . . .        Number            21h 
LE_CPU_R2000 . . . . . . . . . .        Number            40h 
LE_CPU_R4000 . . . . . . . . . .        Number            42h 
LE_CPU_R6000 . . . . . . . . . .        Number            41h 
LE_CPU_i860  . . . . . . . . . .        Number            20h 
LE_OBJ_Flags_16Alias . . . . . .        Number          1000h 
LE_OBJ_Flags_Big . . . . . . . .        Number          2000h 
LE_OBJ_Flags_Conform . . . . . .        Number          4000h 
LE_OBJ_Flags_Discard . . . . . .        Number            10h 
LE_OBJ_Flags_Exec  . . . . . . .        Number             4h 
LE_OBJ_Flags_FillMsk . . . . . .        Number           300h 
LE_OBJ_Flags_IOPriv  . . . . . .        Number          8000h 
LE_OBJ_Flags_Invalid . . . . . .        Number            80h 
LE_OBJ_Flags_LongLoc . . . . . .        Number           400h 
LE_OBJ_Flags_Normal  . . . . . .        Number             0h 
LE_OBJ_Flags_PreLoad . . . . . .        Number            40h 
LE_OBJ_Flags_Read  . . . . . . .        Number             1h 
LE_OBJ_Flags_Res . . . . . . . .        Number             8h 
LE_OBJ_Flags_Res1  . . . . . . .        Number           200h 
LE_OBJ_Flags_Res2  . . . . . . .        Number           300h 
LE_OBJ_Flags_Shared  . . . . . .        Number            20h 
LE_OBJ_Flags_Write . . . . . . .        Number             2h 
LE_OBJ_Flags_Zero  . . . . . . .        Number           100h 
LE_OS_DOS4 . . . . . . . . . . .        Number             3h 
LE_OS_OS2  . . . . . . . . . . .        Number             1h 
LE_OS_Win386 . . . . . . . . . .        Number             4h 
LE_OS_Windows  . . . . . . . . .        Number             2h 
LE_Type_DLL  . . . . . . . . . .        Number          8000h 
LE_Type_ExtFixup . . . . . . . .        Number            20h 
LE_Type_InitPer  . . . . . . . .        Number             4h 
LE_Type_IntFixup . . . . . . . .        Number            10h 
LE_Type_NoLoad . . . . . . . . .        Number          2000h 
LengthText . . . . . . . . . . .        Byte[7]          D10h _DATA 
LineBuffer . . . . . . . . . . .        Byte[1024]       180h _BSS 
MAPFileName  . . . . . . . . . .        Byte[64]         140h _BSS 
MAPHandle  . . . . . . . . . . .        Word             B06h _DATA 
MAPextension . . . . . . . . . .        Byte[4]          B02h _DATA 
MEM_END  . . . . . . . . . . . .        Number             2h 
MEM_FILL . . . . . . . . . . . .        Number            3Dh 
MEM_FREE . . . . . . . . . . . .        Number             0h 
MEM_LOCK . . . . . . . . . . . .        Number             4h 
MEM_LOCK_MASK  . . . . . . . . .        Number             Fh 
MEM_LOCK_SHIFT . . . . . . . . .        Number             2h 
MEM_MASK . . . . . . . . . . . .        Number             3h 
MEM_PHYS . . . . . . . . . . . .        Number            20h 
MEM_START  . . . . . . . . . . .        Number             1h 
NearClassVAR . . . . . . . . . .        Byte[10]         C48h _DATA 
NewAllocT  . . . . . . . . . . .        Byte[14]        36D9h _DATA 
NewEntryAutoSS . . . . . . . . .        Byte[14]        373Bh _DATA 
NewEntryCSt  . . . . . . . . . .        Byte[14]        3711h _DATA 
NewEntryEIPt . . . . . . . . . .        Byte[14]        3703h _DATA 
NewEntryESPt . . . . . . . . . .        Byte[14]        371Fh _DATA 
NewEntrySSt  . . . . . . . . . .        Byte[14]        372Dh _DATA 
NewHeader  . . . . . . . . . . .        NewHeaderStruc       B4Eh _DATA 
NewLengthT . . . . . . . . . . .        Byte[14]        36CBh _DATA 
NewRelocsT . . . . . . . . . . .        Byte[14]        36F5h _DATA 
NewSegmentsT . . . . . . . . . .        Byte[14]        36E7h _DATA 
NewSizeT . . . . . . . . . . . .        Byte[14]        36BDh _DATA 
NullText . . . . . . . . . . . .        Byte[5]          D05h _DATA 
ObjectBase . . . . . . . . . . .        DWord           390Eh _DATA 
ObjectCount  . . . . . . . . . .        DWord           390Ah _DATA 
ObjectList . . . . . . . . . . .        DWord           3912h _DATA 
OpenFilesList  . . . . . . . . .        Word[60]        3D08h _DATA 
OptionCounter  . . . . . . . . .        Byte            397Bh _DATA 
OptionPointer  . . . . . . . . .        DWord           3BFCh _DATA 
OptionTable  . . . . . . . . . .        Byte[128]       397Ch _DATA 
OptionText . . . . . . . . . . .        Byte[256]       3C00h _DATA 
P3Offset . . . . . . . . . . . .        DWord           3976h _DATA 
PageCount  . . . . . . . . . . .        DWord[2]        391Eh _DATA 
ProcessExeText . . . . . . . . .        Byte[35]         A99h _DATA 
ProcessMapText . . . . . . . . .        Byte[23]         A82h _DATA 
ProcessStubText  . . . . . . . .        Byte[32]         A62h _DATA 
ReadingLEText  . . . . . . . . .        Byte[29]        3871h _DATA 
ReadingMainText  . . . . . . . .        Byte[50]        3749h _DATA 
Real3POffset . . . . . . . . . .        DWord           386Dh _DATA 
RealHeader . . . . . . . . . . .        NewHeaderStruc      3926h _DATA 
RelocMem . . . . . . . . . . . .        DWord[2]        396Eh _DATA 
RelocSegment . . . . . . . . . .        DWord            B27h _DATA 
RelocStuff . . . . . . . . . . .        Byte[27]        37F8h _DATA 
RelocationCount  . . . . . . . .        DWord           396Ah _DATA 
RelocationList . . . . . . . . .        DWord           3916h _DATA 
ResCount . . . . . . . . . . . .        Number           32Ch 
ResHeadSize  . . . . . . . . . .        Number            10h 
ResNum . . . . . . . . . . . . .        Number           330h 
ResSize  . . . . . . . . . . . .        Number          1000h 
Res_CALLBACK . . . . . . . . . .        Number             6h 
Res_CHAIN  . . . . . . . . . . .        Number            FFh 
Res_DOSMEM . . . . . . . . . . .        Number             5h 
Res_LOCK . . . . . . . . . . . .        Number             4h 
Res_MEM  . . . . . . . . . . . .        Number             3h 
Res_NOTHING  . . . . . . . . . .        Number            FEh 
Res_NULL . . . . . . . . . . . .        Number             0h 
Res_PSP  . . . . . . . . . . . .        Number             1h 
Res_SEL  . . . . . . . . . . . .        Number             2h 
SHELLFileName  . . . . . . . . .        Byte[128]         80h _BSS 
SHELLHandle  . . . . . . . . . .        Word             AFAh _DATA 
SegClassCODE . . . . . . . . . .        Byte[5]          E41h _DATA 
SegClassCONST  . . . . . . . . .        Byte[6]         2654h _DATA 
SegClassDATA . . . . . . . . . .        Byte[5]         1647h _DATA 
SegClassList . . . . . . . . . .        DWord[6]         E28h _DATA 
SegClassNEAR . . . . . . . . . .        Byte[5]         2E5Bh _DATA 
SegClassSTACK  . . . . . . . . .        Byte[6]         1E4Dh _DATA 
SegCurrent . . . . . . . . . . .        DWord            B1Bh _DATA 
SegFormatSlots . . . . . . . . .        Byte[5]          D1Dh _DATA 
SegFormatTexts . . . . . . . . .        DWord[5]         CF1h _DATA 
SegFormatVAR . . . . . . . . . .        Byte[14]         C10h _DATA 
SegHeaderText  . . . . . . . . .        Byte[30]         C53h _DATA 
SegHeaderVAR . . . . . . . . . .        Byte[14]         C02h _DATA 
SegLayout  . . . . . . . . . . .        Byte[6]          D22h _DATA 
SegSamet . . . . . . . . . . . .        Byte[60]         9F6h _DATA 
SegmentBase  . . . . . . . . . .        DWord           391Ah _DATA 
SegmentList  . . . . . . . . . .        DWord            B17h _DATA 
SegmentStuff . . . . . . . . . .        Byte[29]        377Bh _DATA 
SegmentTotal . . . . . . . . . .        DWord            B1Fh _DATA 
SpeedLoadText  . . . . . . . . .        Byte[24]        36A5h _DATA 
StackClassVAR  . . . . . . . . .        Byte[11]         C32h _DATA 
StartText  . . . . . . . . . . .        Byte[6]          D0Ah _DATA 
StubMem  . . . . . . . . . . . .        DWord           3966h _DATA 
TempFileName . . . . . . . . . .        Byte[13]         B08h _DATA 
TempHandle . . . . . . . . . . .        Word             B15h _DATA 
VariableList . . . . . . . . . .        DWord[4]         B8Eh _DATA 
Write3PText  . . . . . . . . . .        Byte[20]        38EAh _DATA 
_DEBUG . . . . . . . . . . . . .        Text   
b  . . . . . . . . . . . . . . .        Text   byte ptr
d  . . . . . . . . . . . . . . .        Text   dword ptr
exehdr . . . . . . . . . . . . .        MZHdr            B2Bh _DATA 
fmt  . . . . . . . . . . . . . .        Text   
psp  . . . . . . . . . . . . . .        DWord              0h _DATA 
start  . . . . . . . . . . . . .        L Near           1CCh _TEXT 
w  . . . . . . . . . . . . . . .        Text   word ptr

cwem.asm: 4631 lines, 5 passes, 27 ms, 0 warnings, 0 errors
